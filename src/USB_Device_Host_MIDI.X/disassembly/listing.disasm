Disassembly Listing for USB_Device_Host_MIDI
Generated From:
/home/sladekm/MPLABXProjects/USB_Device_Host_MIDI.X/dist/usb_msd/debug/USB_Device_Host_MIDI.X.debug.elf
May 30, 2020 12:42:31 AM

---  /home/sladekm/MPLABXProjects/USB_Device_Host_MIDI.X/usb/src/usb_host_midi.c  -----------------------
1:                 // DOM-IGNORE-BEGIN
2:                 /*******************************************************************************
3:                 Copyright 2015 Microchip Technology Inc. (www.microchip.com)
4:                 
5:                 Licensed under the Apache License, Version 2.0 (the "License");
6:                 you may not use this file except in compliance with the License.
7:                 You may obtain a copy of the License at
8:                 
9:                     http://www.apache.org/licenses/LICENSE-2.0
10:                
11:                Unless required by applicable law or agreed to in writing, software
12:                distributed under the License is distributed on an "AS IS" BASIS,
13:                WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
14:                See the License for the specific language governing permissions and
15:                limitations under the License.
16:                
17:                To request to license the code under the MLA license (www.microchip.com/mla_license),
18:                please contact mla_licensing@microchip.com
19:                *******************************************************************************/
20:                //DOM-IGNORE-END
21:                
22:                #include <stdlib.h>
23:                #include <string.h>
24:                #include <stdbool.h>
25:                #include <stdint.h>
26:                
27:                #include "usb.h"
28:                #include "usb_host.h"
29:                #include "usb_host_midi.h"
30:                
31:                //#define DEBUG_MODE
32:                #ifdef DEBUG_MODE
33:                    #include "uart2.h"
34:                #endif
35:                
36:                
37:                // *****************************************************************************
38:                // *****************************************************************************
39:                // Section: Configuration
40:                // *****************************************************************************
41:                // *****************************************************************************
42:                
43:                // *****************************************************************************
44:                /* Max Number of Supported Devices
45:                
46:                This value represents the maximum number of attached devices this class driver
47:                can support.  If the user does not define a value, it will be set to 1.
48:                Currently this must be set to 1, due to limitations in the USB Host layer.
49:                */
50:                #ifndef USB_MAX_MIDI_DEVICES
51:                    #define USB_MAX_MIDI_DEVICES     1
52:                #endif
53:                
54:                #if USB_MAX_MIDI_DEVICES != 1
55:                    #error The MIDI client driver supports only one attached device.
56:                #endif
57:                
58:                // *****************************************************************************
59:                // *****************************************************************************
60:                // Section: Global Variables
61:                // *****************************************************************************
62:                // *****************************************************************************
63:                
64:                static MIDI_DEVICE devices[USB_MAX_MIDI_DEVICES];
65:                
66:                
67:                // *****************************************************************************
68:                // *****************************************************************************
69:                // Section: Host Stack Interface Functions
70:                // *****************************************************************************
71:                // *****************************************************************************
72:                
73:                /****************************************************************************
74:                  Function:
75:                    bool USBHostMIDIInit ( uint8_t address, uint32_t flags, uint8_t clientDriverID )
76:                
77:                  Summary:
78:                    This function is called by the USB Embedded Host layer when a MIDI
79:                    device attaches.
80:                
81:                  Description:
82:                    This routine is a call out from the USB Embedded Host layer to the USB
83:                    MIDI client driver.  It is called when a MIDI device has been connected
84:                    to the host.  Its purpose is to initialize and activate the USB
85:                    MIDI client driver.
86:                
87:                  Preconditions:
88:                    The device has been configured.
89:                
90:                  Parameters:
91:                    uint8_t address        - Device's address on the bus
92:                    uint32_t flags         - Initialization flags
93:                    uint8_t clientDriverID - ID to send when issuing a Device Request via
94:                                            USBHostIssueDeviceRequest(), USBHostSetDeviceConfiguration(),
95:                                            or USBHostSetDeviceInterface().
96:                
97:                  Return Values:
98:                    true    - Initialization was successful
99:                    false   - Initialization failed
100:               
101:                 Remarks:
102:                   Multiple client drivers may be used in a single application.  The USB
103:                   Embedded Host layer will call the initialize routine required for the
104:                   attached device.
105:                 ***************************************************************************/
106:               
107:               bool USBHostMIDIInit ( uint8_t address, uint32_t flags, uint8_t clientDriverID )
00A730  B3C015     MOV.B #0x1, W5
00A732  200404     MOV #0x40, W4
00A734  78018C     MOV W12, W3
00A736  EB4080     CLR.B W1
00A738  97ECFF     MOV.B [W15-17], W9
00A778  784105     MOV.B W5, W2
00A77A  900193     MOV [W3+2], W3
00A77C  518F84     SUB W3, W4, [W15]
00A77E  3E0001     BRA GTU, .L11
00A780  784109     MOV.B W9, W2
108:               {
00A6A2  4787E6     ADD W15, #0x6, W15
00A6A4  BE9F88     MOV.D W8, [W15++]
00A6A6  BE9F8A     MOV.D W10, [W15++]
00A6A8  BE9F8C     MOV.D W12, [W15++]
00A6AA  781F8E     MOV W14, [W15++]
00A6AC  784700     MOV.B W0, W14
00A6AE  9FF781     MOV.B W1, [W15-16]
109:                   uint8_t *config_descriptor;
110:                   uint8_t *ptr;
111:                   uint8_t bDescriptorType;
112:                   uint8_t bLength;
113:                   uint8_t bNumEndpoints;
114:                   uint8_t bNumInterfaces;
115:                   uint8_t bInterfaceNumber;
116:                   uint8_t bAlternateSetting;
117:                   uint8_t Class;
118:                   uint8_t SubClass;
119:                   uint8_t Protocol;
120:                   uint8_t currentEndpoint;
121:                   uint16_t wTotalLength;
122:               
123:                   uint8_t index = 0;
124:                   bool error = false;
125:               
126:                   MIDI_DEVICE *device = &devices[0];
127:               
128:                   config_descriptor = USBHostGetCurrentConfigurationDescriptor(address);
00A6B0  807D2A     MOV pCurrentConfigurationDescriptor, W10
129:                   ptr = config_descriptor;
130:               
131:                   // Load up the values from the Configuration Descriptor
132:                   bLength              = *ptr++;
00A6B2  78000A     MOV W10, W0
00A6B4  784430     MOV.B [W0++], W8
133:                   bDescriptorType      = *ptr++;
134:                   wTotalLength         = *ptr++;           // In case these are not word aligned
00A6B6  FB80D0     ZE [++W0], W1
135:                   wTotalLength        += (*ptr++) << 8;
00A6B8  904590     MOV.B [W0+1], W11
00A6BA  DD5DC8     SL W11, #8, W11
00A6BC  458581     ADD W11, W1, W11
136:                   bNumInterfaces       = *ptr++;
137:               
138:                   // Skip over the rest of the Configuration Descriptor
139:                   index += bLength;
140:                   ptr    = &config_descriptor[index];
00A6BE  FB8008     ZE W8, W0
00A6C4  450000     ADD W10, W0, W0
141:               
142:                   while (!error && (index < wTotalLength))
00A6C0  558F80     SUB W11, W0, [W15]
00A6C2  360092     BRA LEU, .L2
00A7BE  E00402     CP0.B W2
00A7C0  3A0004     BRA NZ, .L13
00A7C2  FB8008     ZE W8, W0
00A7C4  558F80     SUB W11, W0, [W15]
00A7C6  3EFF82     BRA GTU, .L14
00A7C8  37000F     BRA .L2
143:                   {
144:                       // Check the descriptor length and type
145:                       bLength         = *ptr++;
00A6CC  78449C     MOV.B [W12], W9
146:                       bDescriptorType = *ptr++;
147:               
148:                       // Find an interface descriptor
149:                       if (bDescriptorType != USB_DESCRIPTOR_INTERFACE)
00A6CE  B3C042     MOV.B #0x4, W2
00A6D0  114FDC     SUBR.B W2, [++W12], [W15]
00A6D2  320004     BRA Z, .L3
150:                       {
151:                           // Skip over the rest of the Descriptor
152:                           index += bLength;
00A6D4  444409     ADD.B W8, W9, W8
153:                           ptr = &config_descriptor[index];
00A6D6  FB8608     ZE W8, W12
00A6D8  45060C     ADD W10, W12, W12
00A6DA  370073     BRA .L16
154:                       }
155:                       else
156:                       {
157:                           // Read some data from the interface descriptor
158:                           bInterfaceNumber  = *ptr++;
159:                           bAlternateSetting = *ptr++;
160:                           bNumEndpoints     = *ptr++;
00A6DC  460063     ADD W12, #0x3, W0
00A6DE  7846B0     MOV.B [W0++], W13
161:                           Class             = *ptr++;
00A6E0  780600     MOV W0, W12
162:                           SubClass          = *ptr++;
00A6E2  7840DC     MOV.B [++W12], W1
163:                           Protocol          = *ptr++;
00A6E4  78415C     MOV.B [++W12], W2
00A716  E8060C     INC W12, W12
164:               
165:                           // Check to see if this is a MIDI inteface descripter
166:                           if (Class != AUDIO_CLASS || SubClass != MIDI_SUB_CLASS || Protocol != MIDI_PROTOCOL)
00A6E6  B3C013     MOV.B #0x1, W3
00A6E8  11CF90     SUBR.B W3, [W0], [W15]
00A6EA  3A0004     BRA NZ, .L5
00A6EC  50CFE3     SUB.B W1, #0x3, [W15]
00A6EE  3A0002     BRA NZ, .L5
00A6F0  E00402     CP0.B W2
00A6F2  320004     BRA Z, .L6
167:                           {
168:                               // If we cannot support this interface, skip it.
169:                               index += bLength;
00A6F4  444409     ADD.B W8, W9, W8
170:                               ptr = &config_descriptor[index];
00A6F6  FB8608     ZE W8, W12
00A6F8  45060C     ADD W10, W12, W12
171:                               continue;
00A6FA  370063     BRA .L16
172:                           }
173:               
174:                           // Initialize the device
175:                           device->deviceAddress = address;
00A6FC  20A427     MOV #0xA42, W7
00A6FE  784B8E     MOV.B W14, [W7]
176:                           device->clientDriverID = clientDriverID;
00A700  97F08F     MOV.B [W15-16], W1
00A702  E80007     INC W7, W0
00A704  784801     MOV.B W1, [W0]
177:                           device->numEndpoints = bNumEndpoints;
00A706  E80100     INC W0, W2
00A708  78490D     MOV.B W13, [W2]
178:               
179:               
180:                           // Allocate enough memory for each endpoint
181:                           if ((device->endpoints = (MIDI_ENDPOINT_DATA*)malloc( sizeof(MIDI_ENDPOINT_DATA) * bNumEndpoints)) == NULL)
00A70A  FB800D     ZE W13, W0
00A70C  DD0042     SL W0, #2, W0
00A70E  07AEA1     RCALL 0x452
00A710  885230     MOV W0, 0xA46
00A712  E00000     CP0 W0
00A714  3A0003     BRA NZ, .L7
182:                           {
183:                               // Out of memory
184:                               error = true;
00A718  B3C012     MOV.B #0x1, W2
00A71A  37004E     BRA .L8
185:                           }
186:               
187:                           if (!error)
188:                           {
189:                               // Skip over the rest of the Interface Descriptor
190:                               index += bLength;
00A71C  444409     ADD.B W8, W9, W8
191:                               ptr = &config_descriptor[index];
00A71E  FB8008     ZE W8, W0
00A720  450600     ADD W10, W0, W12
192:               
193:                               // Find the Endpoint Descriptors.  There might be Class and Vendor descriptors in here
194:                               currentEndpoint = 0;
00A72A  EB4180     CLR.B W3
00A72C  9FEFE3     MOV.B W3, [W15-18]
00A7A4  9FEFE2     MOV.B W2, [W15-18]
00A7A6  370008     BRA .L8
00A7A8  780603     MOV W3, W12
00A7AA  784101     MOV.B W1, W2
00A7AC  9FEFE2     MOV.B W2, [W15-18]
00A7F8  EB4000     CLR.B W0
00A7FA  9FEFE0     MOV.B W0, [W15-18]
00A7FC  37FFE2     BRA .L16
195:                               while (!error && (index < wTotalLength) && (currentEndpoint < bNumEndpoints))
00A722  558F80     SUB W11, W0, [W15]
00A724  36003E     BRA LEU, .L17
00A726  E0040D     CP0.B W13
00A728  320067     BRA Z, .L18
00A78A  E00402     CP0.B W2
00A78C  3A0012     BRA NZ, .L23
00A78E  FB8008     ZE W8, W0
00A790  558F80     SUB W11, W0, [W15]
00A792  36000A     BRA LEU, .L19
00A794  56CF81     SUB.B W13, W1, [W15]
00A796  3EFFD1     BRA GTU, .L12
00A798  780603     MOV W3, W12
00A79A  784001     MOV.B W1, W0
00A79C  9FEFE0     MOV.B W0, [W15-18]
00A79E  EB4100     CLR.B W2
00A7A0  37000B     BRA .L8
00A7A2  EB4100     CLR.B W2
00A7AE  EB4100     CLR.B W2
00A7B0  370003     BRA .L8
00A7B2  780603     MOV W3, W12
00A7B4  784181     MOV.B W1, W3
00A7B6  9FEFE3     MOV.B W3, [W15-18]
196:                               {
197:                                   bLength = *ptr++;
00A73A  784013     MOV.B [W3], W0
198:                                   bDescriptorType = *ptr++;
199:               
200:                                   if (bDescriptorType != USB_DESCRIPTOR_ENDPOINT)
00A73C  B3C057     MOV.B #0x5, W7
00A73E  13CFD3     SUBR.B W7, [++W3], [W15]
00A740  320004     BRA Z, .L9
201:                                   {
202:                                       // Skip over the rest of the Descriptor
203:                                       index += bLength;
00A742  444400     ADD.B W8, W0, W8
204:                                       ptr = &config_descriptor[index];
00A744  FB8188     ZE W8, W3
00A746  450183     ADD W10, W3, W3
00A748  370022     BRA .L10
205:                                   }
206:                                   else
207:                                   {
208:                                       device->endpoints[currentEndpoint].endpointAddress = *ptr++;
00A74A  FB8101     ZE W1, W2
00A74C  DD1142     SL W2, #2, W2
00A74E  805237     MOV 0xA46, W7
00A750  438382     ADD W7, W2, W7
00A752  E80183     INC W3, W3
00A754  784633     MOV.B [W3++], W12
00A756  98439C     MOV.B W12, [W7+1]
209:                                       ptr++;
210:                                       device->endpoints[currentEndpoint].endpointSize = *ptr++;
00A758  805237     MOV 0xA46, W7
00A75A  438382     ADD W7, W2, W7
00A75C  FB8653     ZE [++W3], W12
00A75E  98039C     MOV W12, [W7+2]
211:                                       device->endpoints[currentEndpoint].endpointSize += (*ptr++) << 8;
00A72E  20A466     MOV #0xA46, W6
00A760  410396     ADD W2, [W6], W7
00A762  904193     MOV.B [W3+1], W3
00A764  DD19C8     SL W3, #8, W3
00A766  900617     MOV [W7+2], W12
00A768  460183     ADD W12, W3, W3
00A76A  980393     MOV W3, [W7+2]
212:                                       device->endpoints[currentEndpoint].busy = false;
00A6C6  EB4080     CLR.B W1
00A6C8  9FEFF1     MOV.B W1, [W15-17]
00A6CA  780600     MOV W0, W12
00A76C  805233     MOV 0xA46, W3
00A76E  418182     ADD W3, W2, W3
00A770  EB4380     CLR.B W7
00A772  784987     MOV.B W7, [W3]
213:               
214:                                       if(device->endpoints[currentEndpoint].endpointSize > 64)
00A774  805233     MOV 0xA46, W3
00A776  418182     ADD W3, W2, W3
215:                                       {
216:                                           // For full speed bulk endpoints, only 8, 16, 32, and 64 byte packets are supported
217:                                           // But we will accept anything less than or equal to 64.
218:                                           error = true;
219:                                       }
220:               
221:                                       // Get ready for the next endpoint.
222:                                       currentEndpoint++;
00A782  E84081     INC.B W1, W1
223:                                       index += bLength;
00A784  444400     ADD.B W8, W0, W8
224:                                       ptr = &config_descriptor[index];
00A786  FB8188     ZE W8, W3
00A788  450183     ADD W10, W3, W3
225:                                   }
226:                               }
227:                           }
228:               
229:                           // Ensure that we found all the endpoints for this interface.
230:                           if (currentEndpoint != bNumEndpoints)
00A7B8  97EBEF     MOV.B [W15-18], W7
00A7BA  53CF8D     SUB.B W7, W13, [W15]
00A7BC  3A0006     BRA NZ, .L13
231:                           {
232:                               error = true;
233:                           }
234:                       }
235:                   }
236:               
237:                   if (error)
238:                   {
239:                       // Destroy whatever list of interfaces, settings, and endpoints we created.
240:                       // The "new" variables point to the current node we are trying to remove.
241:                       if (device->endpoints != NULL)
00A7CA  805231     MOV 0xA46, W1
00A7CE  E00001     CP0 W1
00A7D0  320005     BRA Z, .L15
242:                       {
243:                           free( device->endpoints );
00A7D2  780001     MOV W1, W0
00A7D4  07ADD9     RCALL 0x388
244:                           device->endpoints = NULL;
00A7D6  20A460     MOV #0xA46, W0
00A7D8  EB0800     CLR [W0]
245:                       }
246:                       return false;
00A7CC  EB4000     CLR.B W0
00A7DA  EB4000     CLR.B W0
247:                   }
248:               
249:                   #ifdef DEBUG_MODE
250:                       UART2PrintString( "USB MIDI Client Initalized: " );
251:                       UART2PrintString( " address=" );
252:                       UART2PutDec( address );
253:                       UART2PrintString( " Number of Endpoings=" );
254:                       UART2PutHex( bNumEndpoints );
255:                       UART2PrintString( "\r\n" );
256:                   #endif
257:               
258:                   // Notify that application that we've been attached to a device.
259:                   USB_HOST_APP_EVENT_HANDLER(address, EVENT_MIDI_ATTACH, device, sizeof(MIDI_DEVICE) );
00A7E8  200064     MOV #0x6, W4
00A7EA  200005     MOV #0x0, W5
00A7EC  20A422     MOV #0xA42, W2
00A7EE  203E81     MOV #0x3E8, W1
00A7F0  78400E     MOV.B W14, W0
00A7F2  070160     RCALL USB_Host_ApplicationEventHandler
260:               
261:                   return true;
00A7F4  B3C010     MOV.B #0x1, W0
00A7F6  37FFF2     BRA .L15
262:               
263:               } // USBHostMIDIInit
00A7DC  78074F     MOV [--W15], W14
00A7DE  BE064F     MOV.D [--W15], W12
00A7E0  BE054F     MOV.D [--W15], W10
00A7E2  BE044F     MOV.D [--W15], W8
00A7E4  B1006F     SUB #0x6, W15
00A7E6  060000     RETURN
00A7E8  200064     MOV #0x6, W4
00A7EA  200005     MOV #0x0, W5
00A7EC  20A422     MOV #0xA42, W2
00A7EE  203E81     MOV #0x3E8, W1
00A7F0  78400E     MOV.B W14, W0
00A7F2  070160     RCALL USB_Host_ApplicationEventHandler
00A7F4  B3C010     MOV.B #0x1, W0
00A7F6  37FFF2     BRA .L15
00A7F8  EB4000     CLR.B W0
00A7FA  9FEFE0     MOV.B W0, [W15-18]
00A7FC  37FFE2     BRA .L16
264:               
265:               
266:               /****************************************************************************
267:                 Function:
268:                   bool USBHostMIDIEventHandler ( uint8_t address, USB_EVENT event,
269:                                           void *data, uint32_t size )
270:               
271:                 Summary:
272:                   This routine is called by the Host layer to notify the general client of
273:                   events that occur.
274:               
275:                 Description:
276:                   This routine is called by the Host layer to notify the general client of
277:                   events that occur.  If the event is recognized, it is handled and the
278:                   routine returns true.  Otherwise, it is ignored and the routine returns
279:                   false.
280:               
281:                 Preconditions:
282:                   None
283:               
284:                 Parameters:
285:                   uint8_t address    - Address of device with the event
286:                   USB_EVENT event - The bus event that occured
287:                   void *data      - Pointer to event-specific data
288:                   uint32_t size      - Size of the event-specific data
289:               
290:                 Return Values:
291:                   true    - The event was handled
292:                   false   - The event was not handled
293:               
294:                 Remarks:
295:                   None
296:                 ***************************************************************************/
297:               
298:               bool USBHostMIDIEventHandler ( uint8_t address, USB_EVENT event, void *data, uint32_t size )
00A87E  428064     ADD W5, #0x4, W0
00A880  200042     MOV #0x4, W2
00A882  EB4080     CLR.B W1
00A884  370001     BRA .L30
299:               {
00A7FE  781F88     MOV W8, [W15++]
00A800  BE0304     MOV.D W4, W6
300:                   unsigned char i;
301:               
302:                   // Make sure it was for one of our devices
303:                   for( i = 0; i < USB_MAX_MIDI_DEVICES; i++)
304:                   {
305:                       if ( address == devices[i].deviceAddress)
00A802  20A423     MOV #0xA42, W3
00A804  784193     MOV.B [W3], W3
00A808  51CF80     SUB.B W3, W0, [W15]
00A80A  3A0042     BRA NZ, .L25, .LBE2
306:                       {
307:                           break;
308:                       }
309:               
310:                   }
311:                   if(i == USB_MAX_MIDI_DEVICES)
312:                   {
313:                       return false;
00A806  EB4280     CLR.B W5
314:                   }
315:               
316:                   // Handle specific events
317:                   switch (event)
00A80C  200710     MOV #0x71, W0
00A80E  508F80     SUB W1, W0, [W15]
00A810  320005     BRA Z, .L26
00A812  E80000     INC W0, W0
00A816  508F80     SUB W1, W0, [W15]
00A818  3A003B     BRA NZ, .L25, .LBE2
00A81A  37000E     BRA .L41
318:                   {
319:                       case EVENT_DETACH:
320:                           // Notify that application that the device has been detached.
321:                           USB_HOST_APP_EVENT_HANDLER(devices[i].deviceAddress, EVENT_MIDI_DETACH, &devices[i], sizeof(MIDI_DEVICE) );
00A81C  200064     MOV #0x6, W4
00A81E  200005     MOV #0x0, W5
00A820  20A422     MOV #0xA42, W2
00A822  203E91     MOV #0x3E9, W1
00A824  784003     MOV.B W3, W0
00A826  070146     RCALL USB_Host_ApplicationEventHandler
322:                           devices[i].deviceAddress = 0;
00A828  20A420     MOV #0xA42, W0
00A82A  EB4800     CLR.B [W0]
323:                           free(devices[i].endpoints);
00A82C  400464     ADD W0, #0x4, W8
00A82E  780018     MOV [W8], W0
00A830  07ADAB     RCALL 0x388
324:                           devices[i].endpoints = NULL;
00A832  EB0C00     CLR [W8]
325:                           #ifdef DEBUG_MODE
326:                               UART2PrintString( "USB MIDI Client Device Detached: address=" );
327:                               UART2PutDec( address );
328:                               UART2PrintString( "\r\n" );
329:                           #endif
330:                           return true;
00A834  B3C015     MOV.B #0x1, W5
00A836  37002C     BRA .L25, .LBE2
331:               
332:                       #ifdef USB_ENABLE_TRANSFER_EVENT
333:                       case EVENT_TRANSFER:
334:                           if ( (data != NULL) && (size == sizeof(HOST_TRANSFER_DATA)) )
00A83A  E00002     CP0 W2
00A83C  320029     BRA Z, .L25, .LBE2
00A83E  530FEA     SUB W6, #0xA, [W15]
00A840  5B8FE0     SUBB W7, #0x0, [W15]
00A842  3A0026     BRA NZ, .L25, .LBE2
335:                           {
336:                               unsigned char currentEndpoint;
337:                               //uint32_t dataCount = ((HOST_TRANSFER_DATA *)data)->dataCount;
338:               
339:                               for(currentEndpoint = 0; currentEndpoint < devices[i].numEndpoints; currentEndpoint++)
00A844  20A440     MOV #0xA44, W0
00A846  784310     MOV.B [W0], W6
00A848  E00406     CP0.B W6
00A84A  320022     BRA Z, .L25, .LBE2
00A888  E84081     INC.B W1, W1
00A88A  534F81     SUB.B W6, W1, [W15]
00A88C  3EFFE5     BRA GTU, .L31
340:                               {
341:                                   if ( ((HOST_TRANSFER_DATA *)data)->bEndpointAddress == devices[i].endpoints[currentEndpoint].endpointAddress )
00A84C  9043E2     MOV.B [W2+6], W7
00A84E  805235     MOV 0xA46, W5
00A850  904015     MOV.B [W5+1], W0
00A852  53CF80     SUB.B W7, W0, [W15]
00A854  3A0014     BRA NZ, .L40
00A856  370007     BRA .L42
00A858  780280     MOV W0, W5
00A85A  904190     MOV.B [W0+1], W3
00A85C  410264     ADD W2, #0x4, W4
00A85E  400064     ADD W0, #0x4, W0
00A860  51CF87     SUB.B W3, W7, [W15]
00A862  3A0011     BRA NZ, .L38
00A864  370001     BRA .L28
00A866  EB0100     CLR W2
00A886  780104     MOV W4, W2
342:                                   {
343:                                       devices[i].endpoints[currentEndpoint].busy = 0;
00A868  EB4A80     CLR.B [W5]
344:                                       USB_HOST_APP_EVENT_HANDLER(devices[i].deviceAddress, EVENT_MIDI_TRANSFER_DONE, &devices[i].endpoints[currentEndpoint], sizeof(MIDI_ENDPOINT_DATA));
00A86A  20A460     MOV #0xA46, W0
00A86C  410110     ADD W2, [W0], W2
00A86E  200044     MOV #0x4, W4
00A870  200005     MOV #0x0, W5
00A872  203EA1     MOV #0x3EA, W1
00A874  500064     SUB W0, #0x4, W0
00A876  784010     MOV.B [W0], W0
00A878  07011D     RCALL USB_Host_ApplicationEventHandler
345:                                       return true;
00A87A  B3C015     MOV.B #0x1, W5
00A87C  370009     BRA .L25, .LBE2
346:                                   }
347:                               }
348:                           }
349:                           return false;
00A838  EB4280     CLR.B W5
00A88E  EB4280     CLR.B W5
350:                       #endif
351:               
352:                       case EVENT_SUSPEND:
353:                       case EVENT_RESUME:
354:                       case EVENT_BUS_ERROR:
355:                       default:
356:                           break;
357:                   }
358:               
359:                   return false;
00A814  EB4280     CLR.B W5
360:               } // USBHostMIDIEventHandler
00A890  784005     MOV.B W5, W0
00A892  78044F     MOV [--W15], W8
00A894  060000     RETURN
361:               
362:               
363:               // *****************************************************************************
364:               // *****************************************************************************
365:               // Section: Application Callable Functions
366:               // *****************************************************************************
367:               // *****************************************************************************
368:               
369:               /****************************************************************************
370:                 Function:
371:                   bool USBHostMIDIDeviceDetached( void* handle )
372:               
373:                 Description:
374:                   This interface is used to check if the device has been detached from the
375:                   bus.
376:               
377:                 Preconditions:
378:                   None
379:               
380:                 Parameters:
381:                   void* handle - Pointer to a structure containing the Device Info
382:               
383:                 Return Values:
384:                   true    - The device has been detached, or an invalid handle is given.
385:                   false   - The device is attached
386:               
387:                 Example:
388:                   <code>
389:                   if (USBHostMIDIDeviceDetached( deviceAddress ))
390:                   {
391:                       // Handle detach
392:                   }
393:                   </code>
394:               
395:                 Remarks:
396:                   None
397:                 ***************************************************************************/
398:               
399:                // Implemented as a macro. See usb_host_midi.h
400:               
401:               
402:               /****************************************************************************
403:                 Function:
404:                   MIDI_ENDPOINT_DIRECTION USBHostMIDIEndpointDirection( void* handle, uint8_t endpointIndex )
405:               
406:                 Description:
407:                   This function retrieves the endpoint direction of the endpoint at
408:                   endpointIndex for device that's located at handle.
409:               
410:                 Preconditions:
411:                   The device must be connected and enumerated.
412:               
413:                 Parameters:
414:                   void* handle       - Pointer to a structure containing the Device Info
415:                   uint8_t endpointIndex - the index of the endpoint whose direction is requested
416:               
417:                 Returns:
418:                   MIDI_ENDPOINT_DIRECTION - Returns the direction of the endpoint (IN or OUT)
419:               
420:                 Remarks:
421:                   None
422:                 ***************************************************************************/
423:               
424:                // Implemented as a macro. See usb_host_midi.h
425:               
426:               
427:               /****************************************************************************
428:                 Function:
429:                   uint32_t USBHostMIDISizeOfEndpoint( void* handle, uint8_t endpointIndex )
430:               
431:                 Description:
432:                   This function retrieves the endpoint size of the endpoint at
433:                   endpointIndex for device that's located at handle.
434:               
435:                 Preconditions:
436:                   The device must be connected and enumerated.
437:               
438:                 Parameters:
439:                   void* handle       - Pointer to a structure containing the Device Info
440:                   uint8_t endpointIndex - the index of the endpoint whose direction is requested
441:               
442:                 Returns:
443:                   uint32_t - Returns the number of bytes for the endpoint (4 - 64 bytes per USB spec)
444:               
445:                 Remarks:
446:                   None
447:                 ***************************************************************************/
448:               
449:               // Implemented as a macro. See usb_host_midi.h
450:               
451:               
452:               /****************************************************************************
453:                 Function:
454:                   uint8_t USBHostMIDINumberOfEndpoints( void* handle )
455:               
456:                 Description:
457:                   This function retrieves the number of endpoints for the device that's
458:                   located at handle.
459:               
460:                 Preconditions:
461:                   The device must be connected and enumerated.
462:               
463:                 Parameters:
464:                   void* handle - Pointer to a structure containing the Device Info
465:               
466:                 Returns:
467:                   uint8_t - Returns the number of endpoints for the device at handle.
468:               
469:                 Remarks:
470:                   None
471:                 ***************************************************************************/
472:               
473:                 // Implemented as a macro. See usb_host_midi.h
474:               
475:               
476:               /****************************************************************************
477:                 Function:
478:                   uint8_t USBHostMIDIRead( void* handle, uint8_t endpointIndex, void *buffer, uint16_t length)
479:               
480:                 Description:
481:                   This function will attempt to read length number of bytes from the attached MIDI
482:                   device located at handle, and will save the contents to ram located at buffer.
483:               
484:                 Preconditions:
485:                   The device must be connected and enumerated. The array at *buffer should have
486:                   at least length number of bytes available.
487:               
488:                 Parameters:
489:                   void* handle       - Pointer to a structure containing the Device Info
490:                   uint8_t endpointIndex - the index of the endpoint whose direction is requested
491:                   void* buffer       - Pointer to the data buffer
492:                   uint16_t length        - Number of bytes to be read
493:               
494:                 Return Values:
495:                   USB_SUCCESS         - The Read was started successfully
496:                   (USB error code)    - The Read was not started.  See USBHostRead() for
497:                                           a list of errors.
498:               
499:                 Example:
500:                   <code>
501:                   if (!USBHostMIDITransferIsBusy( deviceHandle, currentEndpoint )
502:                   {
503:                       USBHostMIDIRead( deviceHandle, currentEndpoint, &buffer, sizeof(buffer));
504:                   }
505:                   </code>
506:               
507:                 Remarks:
508:                   None
509:                 ***************************************************************************/
510:               
511:               uint8_t USBHostMIDIRead( void* handle, uint8_t endpointIndex, void *buffer, uint16_t length)
512:               {
00A896  BE9F88     MOV.D W8, [W15++]
513:                   MIDI_DEVICE *device = (MIDI_DEVICE*)handle;
00A898  780400     MOV W0, W8
514:                   uint8_t RetVal;
515:               
516:                   RetVal = USBHostRead( device->deviceAddress, device->endpoints[endpointIndex].endpointAddress, (uint8_t *)buffer, length );
00A89A  FB8481     ZE W1, W9
00A89C  DD4CC2     SL W9, #2, W9
00A89E  900028     MOV [W8+4], W0
00A8A0  400009     ADD W0, W9, W0
00A8A2  904090     MOV.B [W0+1], W1
00A8A4  B81A61     MUL.UU W3, #1, W4
00A8A6  784018     MOV.B [W8], W0
00A8A8  07D0C8     RCALL USBHostRead
517:               
518:                   if (RetVal == USB_SUCCESS)
00A8AA  E00400     CP0.B W0
00A8AC  3A0003     BRA NZ, .L44
519:                   {
520:                       // Set the busy flag
521:                       device->endpoints[endpointIndex].busy = true;
00A8AE  9000A8     MOV [W8+4], W1
00A8B0  B3C012     MOV.B #0x1, W2
00A8B2  7CF082     MOV.B W2, [W1+W9]
522:                   }
523:               
524:                   return RetVal;
525:               
526:               } // USBHostMIDIRead
00A8B4  BE044F     MOV.D [--W15], W8
00A8B6  060000     RETURN
527:               
528:               /****************************************************************************
529:                 Function:
530:                   bool USBHostMIDITransferIsBusy( void* handle, uint8_t endpointIndex )
531:               
532:                 Summary:
533:                   This interface is used to check if the client driver is currently busy
534:                   transferring data over endponitIndex for the device at handle.
535:               
536:                 Description:
537:                   This interface is used to check if the client driver is currently busy
538:                   receiving or sending data from the device at the endpoint with number
539:                   endpointIndex.  This function is intended for use with transfer events.
540:                   With polling, the function USBHostMIDITransferIsComplete()
541:                   should be used.
542:               
543:                 Preconditions:
544:                   The device must be connected and enumerated.
545:               
546:                 Parameters:
547:                   void* handle       - Pointer to a structure containing the Device Info
548:                   uint8_t endpointIndex - the index of the endpoint whose direction is requested
549:               
550:                 Return Values:
551:                   true    - The device is receiving data or an invalid handle is
552:                               given.
553:                   false   - The device is not receiving data
554:               
555:                 Example:
556:                   <code>
557:                   if (!USBHostMIDITransferIsBusy( handle, endpointIndex ))
558:                   {
559:                       USBHostMIDIRead( handle, endpointIndex, &buffer, sizeof( buffer ) );
560:                   }
561:                   </code>
562:               
563:                 Remarks:
564:                   None
565:                 ***************************************************************************/
566:               
567:                // Implemented as a macro. See usb_host_midi.h
568:               
569:               
570:               /****************************************************************************
571:                 Function:
572:                   bool USBHostMIDITransferIsComplete( void* handle, uint8_t endpointIndex,
573:                                                       uint8_t *errorCode, uint32_t *byteCount );
574:               
575:                 Summary:
576:                   This routine indicates whether or not the last transfer over endpointIndex
577:                   is complete.
578:               
579:                 Description:
580:                   This routine indicates whether or not the last transfer over endpointIndex
581:                   is complete. If it is, then the returned errorCode and byteCount are valid,
582:                   and reflect the error code and the number of bytes received.
583:               
584:                   This function is intended for use with polling.  With transfer events,
585:                   the function USBHostMIDITransferIsBusy() should be used.
586:               
587:                 Preconditions:
588:                   None
589:               
590:                 Parameters:
591:                   void* handle        - Pointer to a structure containing the Device Info
592:                   uint8_t endpointIndex  - index of endpoint in endpoints array
593:                   uint8_t *errorCode     - Error code of the last transfer, if complete
594:                   uint32_t *byteCount    - Bytes transferred during the last transfer, if
595:                                           complete
596:               
597:                 Return Values:
598:                   true    - The IN transfer is complete.  errorCode and byteCount are valid.
599:                   false   - The IN transfer is not complete.  errorCode and byteCount are
600:                               invalid.
601:               
602:                 Remarks:
603:                   None
604:                 ***************************************************************************/
605:               
606:               #ifndef USB_ENABLE_TRANSFER_EVENT
607:               bool USBHostMIDITransferIsComplete(void* handle, uint8_t endpointIndex, uint8_t* errorCode, uint32_t *byteCount )
608:               {
609:                   MIDI_DEVICE* device = (MIDI_DEVICE*)handle;
610:               
611:                   if (USBHostTransferIsComplete(device->deviceAddress, endpointIndex, errorCode, byteCount) == true)
612:                   {
613:                       device->endpoints[endpointIndex].busy = 0;
614:                       return true;
615:                   }
616:               
617:                   // Then this transfer is not complete
618:                   return false;
619:               }
620:               #endif
621:               
622:               
623:               /****************************************************************************
624:                 Function:
625:                   uint8_t USBHostMIDIWrite(void* handle, uint8_t endpointIndex, void *buffer, uint16_t length)
626:               
627:                 Description:
628:                   This function will attempt to write length number of bytes from memory at location
629:                   buffer to the attached MIDI device located at handle.
630:               
631:                 Preconditions:
632:                   The device must be connected and enumerated. The array at *buffer should have
633:                   at least length number of bytes available.
634:               
635:                 Parameters:
636:                   handle          - Pointer to a structure containing the Device Info
637:                   endpointIndex   - Index of the endpoint
638:                   buffer          - Pointer to the data being transferred
639:                   length          - Size of the data being transferred
640:               
641:                 Return Values:
642:                   USB_SUCCESS         - The Write was started successfully
643:                   (USB error code)    - The Write was not started.  See USBHostWrite() for
644:                                           a list of errors.
645:               
646:                 Example:
647:                   <code>
648:                   if (!USBHostMIDITransferIsBusy( deviceHandle, currentEndpoint )
649:                   {
650:                       USBHostMIDIWrite( deviceAddress, &buffer, sizeof(buffer) );
651:                   }
652:                   </code>
653:               
654:                 Remarks:
655:                   None
656:                 ***************************************************************************/
657:               
658:               uint8_t USBHostMIDIWrite(void* handle, uint8_t endpointIndex, void *buffer, uint16_t length)
659:               {
00A8B8  BE9F88     MOV.D W8, [W15++]
660:                   MIDI_DEVICE *device = (MIDI_DEVICE*)handle;
00A8BA  780400     MOV W0, W8
661:                   uint8_t RetVal;
662:               
663:                   RetVal = USBHostWrite( device->deviceAddress, device->endpoints[endpointIndex].endpointAddress, (uint8_t *)buffer, length );
00A8BC  FB8481     ZE W1, W9
00A8BE  DD4CC2     SL W9, #2, W9
00A8C0  900028     MOV [W8+4], W0
00A8C2  400009     ADD W0, W9, W0
00A8C4  904090     MOV.B [W0+1], W1
00A8C6  B81A61     MUL.UU W3, #1, W4
00A8C8  784018     MOV.B [W8], W0
00A8CA  07D115     RCALL USBHostWrite
664:                   if (RetVal == USB_SUCCESS)
00A8CC  E00400     CP0.B W0
00A8CE  3A0003     BRA NZ, .L46
665:                   {
666:                       // Set the busy flag
667:                       device->endpoints[endpointIndex].busy = true;
00A8D0  9000A8     MOV [W8+4], W1
00A8D2  B3C012     MOV.B #0x1, W2
00A8D4  7CF082     MOV.B W2, [W1+W9]
668:                   }
669:               
670:                   return RetVal;
671:               
672:               } // USBHostMIDIWrite
00A8D6  BE044F     MOV.D [--W15], W8
00A8D8  060000     RETURN
673:               
674:               
675:               /*************************************************************************
676:                * EOF usb_client_midi.c
677:                */
---  /home/sladekm/MPLABXProjects/USB_Device_Host_MIDI.X/usb/src/usb_host.c  ----------------------------
1:                 // DOM-IGNORE-BEGIN
2:                 /*******************************************************************************
3:                 Copyright 2015 Microchip Technology Inc. (www.microchip.com)
4:                 
5:                 Licensed under the Apache License, Version 2.0 (the "License");
6:                 you may not use this file except in compliance with the License.
7:                 You may obtain a copy of the License at
8:                 
9:                     http://www.apache.org/licenses/LICENSE-2.0
10:                
11:                Unless required by applicable law or agreed to in writing, software
12:                distributed under the License is distributed on an "AS IS" BASIS,
13:                WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
14:                See the License for the specific language governing permissions and
15:                limitations under the License.
16:                
17:                To request to license the code under the MLA license (www.microchip.com/mla_license),
18:                please contact mla_licensing@microchip.com
19:                *******************************************************************************/
20:                //DOM-IGNORE-END
21:                
22:                #include <usb_device_config.h>
23:                #include <stdlib.h>
24:                #include <string.h>
25:                #include <usb.h>
26:                #include "usb_host_local.h"
27:                #include "usb_hal_local.h"
28:                
29:                #ifndef USB_MALLOC
30:                    #define USB_MALLOC(size) malloc(size)
31:                #endif
32:                
33:                #ifndef USB_FREE
34:                    #define USB_FREE(ptr) free(ptr)
35:                #endif
36:                
37:                #define USB_FREE_AND_CLEAR(ptr) {USB_FREE(ptr); ptr = NULL;}
38:                
39:                #if defined( USB_ENABLE_TRANSFER_EVENT )
40:                    #include "usb_struct_queue.h"
41:                #endif
42:                
43:                // *****************************************************************************
44:                // Low Level Functionality Configurations.
45:                
46:                // If the TPL includes an entry specifying a VID of 0xFFFF and a PID of 0xFFFF,
47:                // the specified client driver will be used for any device that attaches.  This
48:                // can be useful for debugging or for providing generic charging functionality.
49:                #define ALLOW_GLOBAL_VID_AND_PID
50:                
51:                // If we allow multiple control transactions during a frame and a NAK is
52:                // generated, we don't get TRNIF.  So we will allow only one control transaction
53:                // per frame.
54:                #define ONE_CONTROL_TRANSACTION_PER_FRAME
55:                
56:                // This definition allow Bulk transfers to take all of the remaining bandwidth
57:                // of a frame.
58:                #define ALLOW_MULTIPLE_BULK_TRANSACTIONS_PER_FRAME
59:                
60:                // If this is defined, then we will repeat a NAK'd request in the same frame.
61:                // Otherwise, we will wait until the next frame to repeat the request.  Some
62:                // mass storage devices require the host to wait until the next frame to
63:                // repeat the request.
64:                //#define ALLOW_MULTIPLE_NAKS_PER_FRAME
65:                
66:                //#define USE_MANUAL_DETACH_DETECT
67:                
68:                // The USB specification states that transactions should be tried three times
69:                // if there is a bus error.  We will allow that number to be configurable. The
70:                // maximum value is 31.
71:                #define USB_TRANSACTION_RETRY_ATTEMPTS  20
72:                
73:                //******************************************************************************
74:                //******************************************************************************
75:                // Section: Host Global Variables
76:                //******************************************************************************
77:                //******************************************************************************
78:                
79:                // When using the PIC32, ping pong mode must be set to FULL.
80:                #if defined (__PIC32__)
81:                    #if (USB_PING_PONG_MODE != USB_PING_PONG__FULL_PING_PONG)
82:                        #undef USB_PING_PONG_MODE
83:                        #define USB_PING_PONG_MODE USB_PING_PONG__FULL_PING_PONG
84:                    #endif
85:                #endif
86:                
87:                #if (USB_PING_PONG_MODE == USB_PING_PONG__NO_PING_PONG) || (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0)
88:                    #if !defined(USB_SUPPORT_OTG) && !defined(USB_SUPPORT_DEVICE)
89:                    static BDT_ENTRY __attribute__ ((aligned(512)))    BDT[2];
90:                    #endif
91:                    #define BDT_IN                                  (&BDT[0])           // EP0 IN Buffer Descriptor
92:                    #define BDT_OUT                                 (&BDT[1])           // EP0 OUT Buffer Descriptor
93:                #elif (USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY)
94:                    #if !defined(USB_SUPPORT_OTG) && !defined(USB_SUPPORT_DEVICE)
95:                    static BDT_ENTRY __attribute__ ((aligned(512)))    BDT[3];
96:                    #endif
97:                    #define BDT_IN                                  (&BDT[0])           // EP0 IN Buffer Descriptor
98:                    #define BDT_OUT                                 (&BDT[1])           // EP0 OUT Even Buffer Descriptor
99:                    #define BDT_OUT_ODD                             (&BDT[2])           // EP0 OUT Odd Buffer Descriptor
100:               #elif (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)
101:                   #if !defined(USB_SUPPORT_OTG) && !defined(USB_SUPPORT_DEVICE)
102:                   static BDT_ENTRY __attribute__ ((aligned(512)))    BDT[4];
103:                   #endif
104:                   #define BDT_IN                                  (&BDT[0])           // EP0 IN Even Buffer Descriptor
105:                   #define BDT_IN_ODD                              (&BDT[1])           // EP0 IN Odd Buffer Descriptor
106:                   #define BDT_OUT                                 (&BDT[2])           // EP0 OUT Even Buffer Descriptor
107:                   #define BDT_OUT_ODD                             (&BDT[3])           // EP0 OUT Odd Buffer Descriptor
108:               #endif
109:               
110:               #if defined(USB_SUPPORT_OTG) || defined(USB_SUPPORT_DEVICE)
111:                   extern BDT_ENTRY BDT[] __attribute__ ((aligned (512)));
112:               #endif
113:               
114:               // These should all be moved into the USB_DEVICE_INFO structure.
115:               static uint8_t                          countConfigurations;                        // Count the Configuration Descriptors read during enumeration.
116:               static uint8_t                          numCommandTries;                            // The number of times the current command has been tried.
117:               static uint8_t                          numEnumerationTries;                        // The number of times enumeration has been attempted on the attached device.
118:               static volatile uint16_t                 numTimerInterrupts;                         // The number of milliseconds elapsed during the current waiting period.
119:               static volatile USB_ENDPOINT_INFO   *pCurrentEndpoint;                           // Pointer to the endpoint currently performing a transfer.
120:               uint8_t                                *pCurrentConfigurationDescriptor    = NULL;  // Pointer to the current configuration descriptor of the attached device.
121:               uint8_t                                *pDeviceDescriptor                  = NULL;  // Pointer to the Device Descriptor of the attached device.
122:               static uint8_t                         *pEP0Data                           = NULL;  // A data buffer for use by EP0.
123:               static volatile uint16_t                 usbHostState;                               // State machine state of the attached device.
124:               volatile uint16_t                 usbOverrideHostState;                       // Next state machine state, when set by interrupt processing.
125:               #ifdef ENABLE_STATE_TRACE   // Debug trace support
126:                   static uint16_t prevHostState;
127:               #endif
128:               
129:               static USB_BUS_INFO                  usbBusInfo;                                 // Information about the USB bus.
130:               static USB_DEVICE_INFO               usbDeviceInfo;                              // A collection of information about the attached device.
131:               #if defined( USB_ENABLE_TRANSFER_EVENT )
132:                   static USB_EVENT_QUEUE           usbEventQueue;                              // Queue of USB events used to synchronize ISR to main tasks loop.
133:               #endif
134:               static USB_ROOT_HUB_INFO             usbRootHubInfo;                             // Information about a specific port.
135:               
136:               static volatile uint16_t msec_count = 0;                                             // The current millisecond count.
137:               
138:               // *****************************************************************************
139:               // *****************************************************************************
140:               // Section: Application Callable Functions
141:               // *****************************************************************************
142:               // *****************************************************************************
143:               
144:               /****************************************************************************
145:                 Function:
146:                   uint8_t USBHostClearEndpointErrors( uint8_t deviceAddress, uint8_t endpoint )
147:               
148:                 Summary:
149:                   This function clears an endpoint's internal error condition.
150:               
151:                 Description:
152:                   This function is called to clear the internal error condition of a device's
153:                   endpoint.  It should be called after the application has dealt with the
154:                   error condition on the device.  This routine clears internal status only;
155:                   it does not interact with the device.
156:               
157:                 Precondition:
158:                   None
159:               
160:                 Parameters:
161:                   uint8_t deviceAddress  - Address of device
162:                   uint8_t endpoint       - Endpoint to clear error condition
163:               
164:                 Return Values:
165:                   USB_SUCCESS             - Errors cleared
166:                   USB_UNKNOWN_DEVICE      - Device not found
167:                   USB_ENDPOINT_NOT_FOUND  - Specified endpoint not found
168:               
169:                 Remarks:
170:                   None
171:                 ***************************************************************************/
172:               
173:               uint8_t USBHostClearEndpointErrors( uint8_t deviceAddress, uint8_t endpoint )
174:               {
175:                   USB_ENDPOINT_INFO *ep;
176:               
177:                   // Find the required device
178:                   if (deviceAddress != usbDeviceInfo.deviceAddress)
004782  209613     MOV #0x961, W3
004784  104F93     SUBR.B W0, [W3], [W15]
004786  3A000C     BRA NZ, .L70
179:                   {
180:                       return USB_UNKNOWN_DEVICE;
004780  B3C062     MOV.B #0x6, W2
181:                   }
182:               
183:                   ep = _USB_FindEndpoint( endpoint );
004788  784001     MOV.B W1, W0
00478A  07FF87     RCALL _USB_FindEndpoint
184:               
185:                   if (ep != NULL)
00478E  E00000     CP0 W0
004790  320007     BRA Z, .L70
186:                   {
187:                       ep->status.bfStalled    = 0;
004792  900090     MOV [W0+2], W1
004794  A15001     BCLR W1, #5
004796  980011     MOV W1, [W0+2]
188:                       ep->status.bfError      = 0;
004798  900090     MOV [W0+2], W1
00479A  A16001     BCLR W1, #6
00479C  980011     MOV W1, [W0+2]
189:               
190:                       return USB_SUCCESS;
00479E  EB4100     CLR.B W2
191:                   }
192:                   return USB_ENDPOINT_NOT_FOUND;
00478C  B3C142     MOV.B #0x14, W2
193:               }
0047A0  784002     MOV.B W2, W0
0047A2  060000     RETURN
194:               
195:               
196:               /****************************************************************************
197:                 Function:
198:                   bool    USBHostDeviceSpecificClientDriver( uint8_t deviceAddress )
199:               
200:                 Summary:
201:                   This function indicates if the specified device has explicit client
202:                   driver support specified in the TPL.
203:               
204:                 Description:
205:                   This function indicates if the specified device has explicit client
206:                   driver support specified in the TPL.  It is used in client drivers'
207:                   USB_CLIENT_INIT routines to indicate that the client driver should be
208:                   used even though the class, subclass, and protocol values may not match
209:                   those normally required by the class.  For example, some printing devices
210:                   do not fulfill all of the requirements of the printer class, so their
211:                   class, subclass, and protocol fields indicate a custom driver rather than
212:                   the printer class.  But the printer class driver can still be used, with
213:                   minor limitations.
214:               
215:                 Precondition:
216:                   None
217:               
218:                 Parameters:
219:                   uint8_t deviceAddress  - Address of device
220:               
221:                 Return Values:
222:                   true    - This device is listed in the TPL by VID andPID, and has explicit
223:                               client driver support.
224:                   false   - This device is not listed in the TPL by VID and PID.
225:               
226:                 Remarks:
227:                   This function is used so client drivers can allow certain
228:                   devices to enumerate.  For example, some printer devices indicate a custom
229:                   class rather than the printer class, even though the device has only minor
230:                   limitations from the full printer class.   The printer client driver will
231:                   fail to initialize the device if it does not indicate printer class support
232:                   in its interface descriptor.  The printer client driver could allow any
233:                   device with an interface that matches the printer class endpoint
234:                   configuration, but both printer and mass storage devices utilize one bulk
235:                   IN and one bulk OUT endpoint.  So a mass storage device would be
236:                   erroneously initialized as a printer device.  This function allows a
237:                   client driver to know that the client driver support was specified
238:                   explicitly in the TPL, so for this particular device only, the class,
239:                   subclass, and protocol fields can be safely ignored.
240:                 ***************************************************************************/
241:               
242:               bool    USBHostDeviceSpecificClientDriver( uint8_t deviceAddress )
243:               {
244:                   return usbDeviceInfo.flags.bfUseDeviceClientDriver;
00446C  804B70     MOV 0x96E, W0
00446E  DD0049     SL W0, #9, W0
004470  DE004F     LSR W0, #15, W0
245:               }
004472  060000     RETURN
246:               
247:               
248:               /****************************************************************************
249:                 Function:
250:                   uint8_t USBHostDeviceStatus( uint8_t deviceAddress )
251:               
252:                 Summary:
253:                   This function returns the current status of a device.
254:               
255:                 Description:
256:                   This function returns the current status of a device.  If the device is
257:                   in a holding state due to an error, the error is returned.
258:               
259:                 Precondition:
260:                   None
261:               
262:                 Parameters:
263:                   uint8_t deviceAddress  - Device address
264:               
265:                 Return Values:
266:                   USB_DEVICE_ATTACHED                 - Device is attached and running
267:                   USB_DEVICE_DETACHED                 - No device is attached
268:                   USB_DEVICE_ENUMERATING              - Device is enumerating
269:                   USB_HOLDING_OUT_OF_MEMORY           - Not enough heap space available
270:                   USB_HOLDING_UNSUPPORTED_DEVICE      - Invalid configuration or
271:                                                           unsupported class
272:                   USB_HOLDING_UNSUPPORTED_HUB         - Hubs are not supported
273:                   USB_HOLDING_INVALID_CONFIGURATION   - Invalid configuration requested
274:                   USB_HOLDING_PROCESSING_CAPACITY     - Processing requirement excessive
275:                   USB_HOLDING_POWER_REQUIREMENT       - Power requirement excessive
276:                   USB_HOLDING_CLIENT_INIT_ERROR       - Client driver failed to initialize
277:                   USB_DEVICE_SUSPENDED                - Device is suspended
278:                   Other                               - Device is holding in an error
279:                                                           state. The return value
280:                                                           indicates the error.
281:               
282:                 Remarks:
283:                   None
284:                 ***************************************************************************/
285:               
286:               uint8_t USBHostDeviceStatus( uint8_t deviceAddress )
287:               {
288:                   if ((usbHostState & STATE_MASK) == STATE_DETACHED)
004474  20F001     MOV #0xF00, W1
004476  807D60     MOV usbHostState, W0
004478  608080     AND W1, W0, W1
00447C  32001E     BRA Z, .L3
289:                   {
290:                       return USB_DEVICE_DETACHED;
00447A  B3C310     MOV.B #0x31, W0
291:                   }
292:               
293:                   if ((usbHostState & STATE_MASK) == STATE_RUNNING)
00447E  20F001     MOV #0xF00, W1
004480  807D60     MOV usbHostState, W0
004482  608080     AND W1, W0, W1
004484  204000     MOV #0x400, W0
004486  508F80     SUB W1, W0, [W15]
004488  3A0008     BRA NZ, .L4
294:                   {
295:                       if ((usbHostState & SUBSTATE_MASK) == SUBSTATE_SUSPEND_AND_RESUME)
00448A  200F01     MOV #0xF0, W1
00448C  807D60     MOV usbHostState, W0
00448E  608080     AND W1, W0, W1
004492  508FF0     SUB W1, #0x10, [W15]
004494  3A0012     BRA NZ, .L3
296:                       {
297:                           return USB_DEVICE_SUSPENDED;
004496  40406A     ADD.B W0, #0xA, W0
004498  370010     BRA .L3
298:                       }
299:                       else
300:                       {
301:                           return USB_DEVICE_ATTACHED;
004490  B3C300     MOV.B #0x30, W0
302:                       }
303:                   }
304:               
305:                   if ((usbHostState & STATE_MASK) == STATE_HOLDING)
00449A  20F001     MOV #0xF00, W1
00449C  807D60     MOV usbHostState, W0
00449E  608080     AND W1, W0, W1
0044A0  205000     MOV #0x500, W0
0044A2  508F80     SUB W1, W0, [W15]
0044A4  3A0003     BRA NZ, .L5
306:                   {
307:                       return usbDeviceInfo.errorCode;
0044A6  209620     MOV #0x962, W0
0044A8  784010     MOV.B [W0], W0
0044AA  370007     BRA .L3
308:                   }
309:               
310:               
311:                   if ((usbHostState > STATE_ATTACHED) &&
0044AC  807D62     MOV usbHostState, W2
0044AE  B11012     SUB #0x101, W2
0044B2  202FE1     MOV #0x2FE, W1
0044B4  510F81     SUB W2, W1, [W15]
0044B6  3E0001     BRA GTU, .L3
312:                       (usbHostState < STATE_RUNNING)
313:                      )
314:                   {
315:                       return USB_DEVICE_ENUMERATING;
0044B8  E9C000     DEC2.B W0, W0
316:                   }
317:               
318:                   return USB_HOLDING_UNSUPPORTED_DEVICE;
0044B0  B3C340     MOV.B #0x34, W0
319:               }
0044BA  060000     RETURN
320:               
321:               /****************************************************************************
322:                 Function:
323:                   bool USBHostInit(  unsigned long flags  )
324:               
325:                 Summary:
326:                   This function initializes the variables of the USB host stack.
327:               
328:                 Description:
329:                   This function initializes the variables of the USB host stack.  It does
330:                   not initialize the hardware.  The peripheral itself is initialized in one
331:                   of the state machine states.  Therefore, USBHostTasks() should be called
332:                   soon after this function.
333:               
334:                 Precondition:
335:                   None
336:               
337:                 Parameters:
338:                   flags - reserved
339:               
340:                 Return Values:
341:                   true  - Initialization successful
342:                   false - Could not allocate memory.
343:               
344:                 Remarks:
345:                   If the endpoint list is empty, an entry is created in the endpoint list
346:                   for EP0.  If the list is not empty, free all allocated memory other than
347:                   the EP0 node.  This allows the routine to be called multiple times by the
348:                   application.
349:                 ***************************************************************************/
350:               
351:               bool USBHostInit(  unsigned long flags  )
352:               {
353:                   // Allocate space for Endpoint 0.  We will initialize it in the state machine,
354:                   // so we can reinitialize when another device connects.  If the Endpoint 0
355:                   // node already exists, free all other allocated memory.
356:                   if (usbDeviceInfo.pEndpoint0 == NULL)
00490C  804B60     MOV 0x96C, W0
00490E  E00000     CP0 W0
004910  3A0009     BRA NZ, .L117
357:                   {
358:                       if ((usbDeviceInfo.pEndpoint0 = (USB_ENDPOINT_INFO*)USB_MALLOC( sizeof(USB_ENDPOINT_INFO) )) == NULL)
004912  200220     MOV #0x22, W0
004914  07DD9E     RCALL 0x452
004916  780080     MOV W0, W1
004918  884B61     MOV W1, 0x96C
00491C  E00001     CP0 W1
00491E  320013     BRA Z, .L118
359:                       {
360:               #if defined (DEBUG_ENABLE)
361:                           DEBUG_PutString( "HOST: Cannot allocate for endpoint 0.\r\n" );
362:               #endif
363:                           return false;
00491A  EB4000     CLR.B W0
364:                       }
365:                       usbDeviceInfo.pEndpoint0->next = NULL;
004920  EB0880     CLR [W1]
004922  370001     BRA .L119
366:                   }
367:                   else
368:                   {
369:                       _USB_FreeMemory();
004924  07FFD1     RCALL _USB_FreeMemory
370:                   }
371:               
372:                   // Initialize other variables.
373:                   pCurrentEndpoint                        = usbDeviceInfo.pEndpoint0;
004926  804B60     MOV 0x96C, W0
004928  887D70     MOV W0, pCurrentEndpoint
374:                   usbHostState                            = STATE_DETACHED;
00492A  EF2FAC     CLR usbHostState
375:                   usbOverrideHostState                    = NO_STATE;
00492C  EFAFA8     SETM usbOverrideHostState
376:                   usbDeviceInfo.deviceAddressAndSpeed     = 0;
00492E  EB4000     CLR.B W0
004930  209601     MOV #0x960, W1
004932  784880     MOV.B W0, [W1]
377:                   usbDeviceInfo.deviceAddress             = 0;
004934  E80081     INC W1, W1
004936  784880     MOV.B W0, [W1]
378:                   usbRootHubInfo.flags.bPowerGoodPort0    = 1;
004938  A80FB8     BSET usbRootHubInfo, #0
379:               
380:                   // Initialize event queue
381:                   #if defined( USB_ENABLE_TRANSFER_EVENT )
382:                       StructQueueInit(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
00493A  200040     MOV #0x4, W0
00493C  884B80     MOV W0, usbEventQueue
00493E  884B90     MOV W0, 0x972
004940  209740     MOV #0x974, W0
004942  EB0800     CLR [W0]
383:                   #endif
384:               
385:                   return true;
004944  B3C010     MOV.B #0x1, W0
386:               }
004946  060000     RETURN
387:               
388:               
389:               /****************************************************************************
390:                 Function:
391:                   bool USBHostIsochronousBuffersCreate( ISOCHRONOUS_DATA * isocData,
392:                           uint8_t numberOfBuffers, uint16_t bufferSize )
393:               
394:                 Description:
395:                   This function initializes the isochronous data buffer information and
396:                   allocates memory for each buffer.  This function will not allocate memory
397:                   if the buffer pointer is not NULL.
398:               
399:                 Precondition:
400:                   None
401:               
402:                 Parameters:
403:                   None
404:               
405:                 Return Values:
406:                   true    - All buffers are allocated successfully.
407:                   false   - Not enough heap space to allocate all buffers - adjust the
408:                               project to provide more heap space.
409:               
410:                 Remarks:
411:                   This function is available only if USB_SUPPORT_ISOCHRONOUS_TRANSFERS
412:                   is defined in usb_config.h.
413:               ***************************************************************************/
414:               #ifdef USB_SUPPORT_ISOCHRONOUS_TRANSFERS
415:               
416:               bool USBHostIsochronousBuffersCreate( ISOCHRONOUS_DATA * isocData, uint8_t numberOfBuffers, uint16_t bufferSize )
417:               {
418:                   uint8_t i;
419:                   uint8_t j;
420:               
421:                   USBHostIsochronousBuffersReset( isocData, numberOfBuffers );
422:                   for (i=0; i<numberOfBuffers; i++)
423:                   {
424:                       if (isocData->buffers[i].pBuffer == NULL)
425:                       {
426:                           isocData->buffers[i].pBuffer = USB_MALLOC( bufferSize );
427:                           if (isocData->buffers[i].pBuffer == NULL)
428:                           {
429:               #if defined (DEBUG_ENABLE)
430:                               DEBUG_PutString( "HOST:  Not enough memory for isoc buffers.\r\n" );
431:               #endif
432:               
433:                               // Release all previous buffers.
434:                               for (j=0; j<i; j++)
435:                               {
436:                                   USB_FREE_AND_CLEAR( isocData->buffers[j].pBuffer );
437:                                   isocData->buffers[j].pBuffer = NULL;
438:                               }
439:                               return false;
440:                           }
441:                       }
442:                   }
443:                   return true;
444:               }
445:               #endif
446:               
447:               /****************************************************************************
448:                 Function:
449:                   void USBHostIsochronousBuffersDestroy( ISOCHRONOUS_DATA * isocData, uint8_t numberOfBuffers )
450:               
451:                 Description:
452:                   This function releases all of the memory allocated for the isochronous
453:                   data buffers.  It also resets all other information about the buffers.
454:               
455:                 Precondition:
456:                   None
457:               
458:                 Parameters:
459:                   None
460:               
461:                 Returns:
462:                   None
463:               
464:                 Remarks:
465:                   This function is available only if USB_SUPPORT_ISOCHRONOUS_TRANSFERS
466:                   is defined in usb_config.h.
467:               ***************************************************************************/
468:               #ifdef USB_SUPPORT_ISOCHRONOUS_TRANSFERS
469:               
470:               void USBHostIsochronousBuffersDestroy( ISOCHRONOUS_DATA * isocData, uint8_t numberOfBuffers )
471:               {
472:                   uint8_t i;
473:               
474:                   USBHostIsochronousBuffersReset( isocData, numberOfBuffers );
475:                   for (i=0; i<numberOfBuffers; i++)
476:                   {
477:                       if (isocData->buffers[i].pBuffer != NULL)
478:                       {
479:                           USB_FREE_AND_CLEAR( isocData->buffers[i].pBuffer );
480:                       }
481:                   }
482:               }
483:               #endif
484:               
485:               
486:               /****************************************************************************
487:                 Function:
488:                   void USBHostIsochronousBuffersReset( ISOCHRONOUS_DATA * isocData, uint8_t numberOfBuffers )
489:               
490:                 Description:
491:                   This function resets all the isochronous data buffers.  It does not do
492:                   anything with the space allocated for the buffers.
493:               
494:                 Precondition:
495:                   None
496:               
497:                 Parameters:
498:                   None
499:               
500:                 Returns:
501:                   None
502:               
503:                 Remarks:
504:                   This function is available only if USB_SUPPORT_ISOCHRONOUS_TRANSFERS
505:                   is defined in usb_config.h.
506:               ***************************************************************************/
507:               #ifdef USB_SUPPORT_ISOCHRONOUS_TRANSFERS
508:               
509:               void USBHostIsochronousBuffersReset( ISOCHRONOUS_DATA * isocData, uint8_t numberOfBuffers )
510:               {
511:                   uint8_t    i;
512:               
513:                   for (i=0; i<numberOfBuffers; i++)
514:                   {
515:                       isocData->buffers[i].dataLength        = 0;
516:                       isocData->buffers[i].bfDataLengthValid = 0;
517:                   }
518:               
519:                   isocData->totalBuffers         = numberOfBuffers;
520:                   isocData->currentBufferUser    = 0;
521:                   isocData->currentBufferUSB     = 0;
522:                   isocData->pDataUser            = NULL;
523:               }
524:               #endif
525:               
526:               /****************************************************************************
527:                 Function:
528:                   uint8_t USBHostIssueDeviceRequest( uint8_t deviceAddress, uint8_t bmRequestType,
529:                                   uint8_t bRequest, uint16_t wValue, uint16_t wIndex, uint16_t wLength,
530:                                   uint8_t *data, uint8_t dataDirection, uint8_t clientDriverID )
531:               
532:                 Summary:
533:                   This function sends a standard device request to the attached device.
534:               
535:                 Description:
536:                   This function sends a standard device request to the attached device.
537:                   The user must pass in the parameters of the device request.  If there is
538:                   input or output data associated with the request, a pointer to the data
539:                   must be provided.  The direction of the associated data (input or output)
540:                   must also be indicated.
541:               
542:                   This function does no special processing in regards to the request except
543:                   for three requests.  If SET INTERFACE is sent, then DTS is reset for all
544:                   endpoints.  If CLEAR FEATURE (ENDPOINT HALT) is sent, then DTS is reset
545:                   for that endpoint.  If SET CONFIGURATION is sent, the request is aborted
546:                   with a failure.  The function USBHostSetDeviceConfiguration() must be
547:                   called to change the device configuration, since endpoint definitions may
548:                   change.
549:               
550:                 Precondition:
551:                   The host state machine should be in the running state, and no reads or
552:                   writes to EP0 should be in progress.
553:               
554:                 Parameters:
555:                   uint8_t deviceAddress  - Device address
556:                   uint8_t bmRequestType  - The request type as defined by the USB
557:                                           specification.
558:                   uint8_t bRequest       - The request as defined by the USB specification.
559:                   uint16_t wValue         - The value for the request as defined by the USB
560:                                           specification.
561:                   uint16_t wIndex         - The index for the request as defined by the USB
562:                                           specification.
563:                   uint16_t wLength        - The data length for the request as defined by the
564:                                           USB specification.
565:                   uint8_t *data          - Pointer to the data for the request.
566:                   uint8_t dataDirection  - USB_DEVICE_REQUEST_SET or USB_DEVICE_REQUEST_GET
567:                   uint8_t clientDriverID - Client driver to send the event to.
568:               
569:                 Return Values:
570:                   USB_SUCCESS                 - Request processing started
571:                   USB_UNKNOWN_DEVICE          - Device not found
572:                   USB_INVALID_STATE           - The host must be in a normal running state
573:                                                   to do this request
574:                   USB_ENDPOINT_BUSY           - A read or write is already in progress
575:                   USB_ILLEGAL_REQUEST         - SET CONFIGURATION cannot be performed with
576:                                                   this function.
577:               
578:                 Remarks:
579:                   DTS reset is done before the command is issued.
580:                 ***************************************************************************/
581:               
582:               uint8_t USBHostIssueDeviceRequest( uint8_t deviceAddress, uint8_t bmRequestType, uint8_t bRequest,
583:                           uint16_t wValue, uint16_t wIndex, uint16_t wLength, uint8_t *data, uint8_t dataDirection,
584:                           uint8_t clientDriverID )
585:               {
0057DC  E8878F     INC2 W15, W15
0057DE  BE9F88     MOV.D W8, [W15++]
0057E0  BE9F8A     MOV.D W10, [W15++]
0057E2  BE9F8C     MOV.D W12, [W15++]
0057E4  781F8E     MOV W14, [W15++]
0057E6  784681     MOV.B W1, W13
0057E8  784602     MOV.B W2, W12
0057EA  780483     MOV W3, W9
0057EC  780404     MOV W4, W8
0057EE  780505     MOV W5, W10
0057F0  780586     MOV W6, W11
0057F2  784707     MOV.B W7, W14
586:                   // Find the required device
587:                   if (deviceAddress != usbDeviceInfo.deviceAddress)
0057F6  209612     MOV #0x961, W2
0057F8  104F92     SUBR.B W0, [W2], [W15]
0057FA  3A0066     BRA NZ, .L385
588:                   {
589:                       return USB_UNKNOWN_DEVICE;
0057F4  B3C061     MOV.B #0x6, W1
590:                   }
591:               
592:                   // If we are not in a normal user running state, we cannot do this.
593:                   if ((usbHostState & STATE_MASK) != STATE_RUNNING)
0057FC  20F002     MOV #0xF00, W2
0057FE  807D60     MOV usbHostState, W0
005800  610100     AND W2, W0, W2
005804  204000     MOV #0x400, W0
005806  510F80     SUB W2, W0, [W15]
005808  3A005F     BRA NZ, .L385
594:                   {
595:                       return USB_INVALID_STATE;
005802  B3C011     MOV.B #0x1, W1
596:                   }
597:               
598:                   // Make sure no other reads or writes on EP0 are in progress.
599:                   if (!usbDeviceInfo.pEndpoint0->status.bfTransferComplete)
00580A  804B60     MOV 0x96C, W0
00580C  900010     MOV [W0+2], W0
005810  A39800     BTST.Z W0, #9
005812  32005A     BRA Z, .L385
600:                   {
601:                       return USB_ENDPOINT_BUSY;
00580E  B3C101     MOV.B #0x10, W1
602:                   }
603:               
604:                   // We can't do a SET CONFIGURATION here.  Must use USBHostSetDeviceConfiguration().
605:                   // ***** Some USB classes need to be able to do this, so we'll remove
606:                   // the constraint.
607:               //    if (bRequest == USB_REQUEST_SET_CONFIGURATION)
608:               //    {
609:               //        return USB_ILLEGAL_REQUEST;
610:               //    }
611:               
612:                   // If the user is doing a SET INTERFACE, we must reset DATA0 for all endpoints.
613:                   if (bRequest == USB_REQUEST_SET_INTERFACE)
005814  564FEB     SUB.B W12, #0xB, [W15]
005816  3A002E     BRA NZ, .L386, .LBE6
614:                   {
615:                       USB_ENDPOINT_INFO           *pEndpoint;
616:                       USB_INTERFACE_INFO          *pInterface;
617:                       USB_INTERFACE_SETTING_INFO  *pSetting;
618:               
619:                       // Make sure there are no transfers currently in progress on the current
620:                       // interface setting.
621:                       pInterface = usbDeviceInfo.pInterfaceList;
005818  804B50     MOV 0x96A, W0
622:                       while (pInterface && (pInterface->interface != wIndex))
00581C  E00000     CP0 W0
00581E  320054     BRA Z, .L385
005820  9040E0     MOV.B [W0+6], W1
005822  FB8081     ZE W1, W1
005824  508F88     SUB W1, W8, [W15]
005826  320057     BRA Z, .L387
00582A  E00000     CP0 W0
00582C  320048     BRA Z, .L402
00582E  9040E0     MOV.B [W0+6], W1
005830  FB8081     ZE W1, W1
005832  508F88     SUB W1, W8, [W15]
005834  3AFFF9     BRA NZ, .L409
005836  37004F     BRA .L387
623:                       {
624:                           pInterface = pInterface->next;
005828  780010     MOV [W0], W0
625:                       }
626:                       if ((pInterface == NULL) || (pInterface->pCurrentSetting == NULL))
0058D6  900120     MOV [W0+4], W2
0058DA  E00002     CP0 W2
0058DC  3AFFAD     BRA NZ, .L414
0058DE  37FFF4     BRA .L385
627:                       {
628:                           // The specified interface was not found.
629:                           return USB_ILLEGAL_REQUEST;
00581A  B3C031     MOV.B #0x3, W1
0058BE  B3C031     MOV.B #0x3, W1
0058C0  370003     BRA .L385
0058D8  B3C031     MOV.B #0x3, W1
630:                       }
631:                       pEndpoint = pInterface->pCurrentSetting->pEndpointList;
005838  900122     MOV [W2+4], W2
632:                       while (pEndpoint)
00583A  E00002     CP0 W2
00583C  32000B     BRA Z, .L389
005850  E00002     CP0 W2
005852  3AFFFA     BRA NZ, .L391
633:                       {
634:                           if (!pEndpoint->status.bfTransferComplete)
00583E  900192     MOV [W2+2], W3
005842  A39803     BTST.Z W3, #9
005844  3A0004     BRA NZ, .L413
005846  370040     BRA .L385
005848  900092     MOV [W2+2], W1
00584A  A39801     BTST.Z W1, #9
00584C  32003A     BRA Z, .L404
635:                           {
636:                               // An endpoint on this setting is still transferring data.
637:                               return USB_ILLEGAL_REQUEST;
005840  B3C031     MOV.B #0x3, W1
0058C2  B3C031     MOV.B #0x3, W1
0058C4  370001     BRA .L385
638:                           }
639:                           pEndpoint = pEndpoint->next;
00584E  780112     MOV [W2], W2
640:                       }
641:               
642:                       // Make sure the new setting is valid.
643:                       pSetting = pInterface->pInterfaceSettings;
005854  900110     MOV [W0+2], W2
644:                       while( pSetting && (pSetting->interfaceAltSetting != wValue))
005858  E00002     CP0 W2
00585A  320036     BRA Z, .L385
00585C  9040A2     MOV.B [W2+2], W1
00585E  FB8081     ZE W1, W1
005860  508F89     SUB W1, W9, [W15]
005862  32003E     BRA Z, .L392
005866  E00002     CP0 W2
005868  32002E     BRA Z, .L406
00586A  9040A2     MOV.B [W2+2], W1
00586C  FB8081     ZE W1, W1
00586E  508F89     SUB W1, W9, [W15]
005870  3AFFF9     BRA NZ, .L408
005872  370036     BRA .L392
645:                       {
646:                           pSetting = pSetting->next;
005864  780112     MOV [W2], W2
647:                       }
648:                       if (pSetting == NULL)
649:                       {
650:                           return USB_ILLEGAL_REQUEST;
005856  B3C031     MOV.B #0x3, W1
0058C6  B3C031     MOV.B #0x3, W1
651:                       }
652:               
653:                       // Set the pointer to the new setting.
654:                       pInterface->pCurrentSetting = pSetting;
0058E0  980022     MOV W2, [W0+4]
0058E2  37FFD0     BRA .L394
655:                   }
656:               
657:                   // If the user is doing a CLEAR FEATURE(ENDPOINT_HALT), we must reset DATA0 for that endpoint.
658:                   if ((bRequest == USB_REQUEST_CLEAR_FEATURE) && (wValue == USB_FEATURE_ENDPOINT_HALT))
005874  564FE1     SUB.B W12, #0x1, [W15]
005876  3A0006     BRA NZ, .L394
005878  E00009     CP0 W9
00587A  3A0004     BRA NZ, .L394
659:                   {
660:                       switch(bmRequestType)
00587C  56CFE2     SUB.B W13, #0x2, [W15]
00587E  3E0002     BRA GTU, .L394
661:                       {
662:                           case 0x00:
663:                           case 0x01:
664:                           case 0x02:
665:                               _USB_ResetDATA0( (uint8_t)wIndex );
005880  784008     MOV.B W8, W0
005882  07FF8D     RCALL _USB_ResetDATA0
666:                               break;
667:                           default:
668:                               break;
669:                       }
670:                   }
671:               
672:                   // Set up the control packet.
673:                   pEP0Data[0] = bmRequestType;
005884  807DA1     MOV pEP0Data, W1
005886  78488D     MOV.B W13, [W1]
674:                   pEP0Data[1] = bRequest;
005888  98409C     MOV.B W12, [W1+1]
675:                   pEP0Data[2] = wValue & 0xFF;
00588A  9840A9     MOV.B W9, [W1+2]
676:                   pEP0Data[3] = (wValue >> 8) & 0xFF;
00588C  DE4CC8     LSR W9, #8, W9
00588E  9840B9     MOV.B W9, [W1+3]
677:                   pEP0Data[4] = wIndex & 0xFF;
005890  9840C8     MOV.B W8, [W1+4]
678:                   pEP0Data[5] = (wIndex >> 8) & 0xFF;
005892  DE4448     LSR W8, #8, W8
005894  9840D8     MOV.B W8, [W1+5]
679:                   pEP0Data[6] = wLength & 0xFF;
005896  9840EA     MOV.B W10, [W1+6]
680:                   pEP0Data[7] = (wLength >> 8) & 0xFF;
005898  DE5048     LSR W10, #8, W0
00589A  9840F0     MOV.B W0, [W1+7]
681:               
682:                   // Set up the client driver for the event.
683:                   usbDeviceInfo.pEndpoint0->clientDriver = clientDriverID;
00589C  804B60     MOV 0x96C, W0
00589E  97E92F     MOV.B [W15-22], W2
0058A0  985812     MOV.B W2, [W0+25]
684:               
685:                   if (dataDirection == USB_DEVICE_REQUEST_SET)
0058A2  E0040E     CP0.B W14
0058A4  3A0006     BRA NZ, .L396
686:                   {
687:                       // We are doing a SET command that requires data be sent.
688:                       _USB_InitControlWrite( usbDeviceInfo.pEndpoint0, pEP0Data,8, data, wLength );
0058A6  78020A     MOV W10, W4
0058A8  78018B     MOV W11, W3
0058AA  200082     MOV #0x8, W2
0058AC  07F871     RCALL _USB_InitControlWrite
689:                   }
690:                   else
691:                   {
692:                       // We are doing a GET request.
693:                       _USB_InitControlRead( usbDeviceInfo.pEndpoint0, pEP0Data, 8, data, wLength );
0058B2  78020A     MOV W10, W4
0058B4  78018B     MOV W11, W3
0058B6  200082     MOV #0x8, W2
0058B8  07F847     RCALL _USB_InitControlRead
694:                   }
695:               
696:                   return USB_SUCCESS;
0058AE  EB4080     CLR.B W1
0058B0  37000B     BRA .L385
0058BA  EB4080     CLR.B W1
0058BC  370005     BRA .L385
697:               }
0058C8  784001     MOV.B W1, W0
0058CA  78074F     MOV [--W15], W14
0058CC  BE064F     MOV.D [--W15], W12
0058CE  BE054F     MOV.D [--W15], W10
0058D0  BE044F     MOV.D [--W15], W8
0058D2  B1002F     SUB #0x2, W15
0058D4  060000     RETURN
0058D6  900120     MOV [W0+4], W2
0058D8  B3C031     MOV.B #0x3, W1
0058DA  E00002     CP0 W2
0058DC  3AFFAD     BRA NZ, .L414
0058DE  37FFF4     BRA .L385
0058E0  980022     MOV W2, [W0+4]
0058E2  37FFD0     BRA .L394
698:               
699:               /****************************************************************************
700:                 Function:
701:                   uint8_t USBHostRead( uint8_t deviceAddress, uint8_t endpoint, uint8_t *pData,
702:                                       uint32_t size )
703:                 Summary:
704:                   This function initiates a read from the attached device.
705:               
706:                 Description:
707:                   This function initiates a read from the attached device.
708:               
709:                   If the endpoint is isochronous, special conditions apply.  The pData and
710:                   size parameters have slightly different meanings, since multiple buffers
711:                   are required.  Once started, an isochronous transfer will continue with
712:                   no upper layer intervention until USBHostTerminateTransfer() is called.
713:                   The ISOCHRONOUS_DATA_BUFFERS structure should not be manipulated until
714:                   the transfer is terminated.
715:               
716:                   To clarify parameter usage and to simplify casting, use the macro
717:                   USBHostReadIsochronous() when reading from an isochronous endpoint.
718:               
719:                 Precondition:
720:                   None
721:               
722:                 Parameters:
723:                   uint8_t deviceAddress  - Device address
724:                   uint8_t endpoint       - Endpoint number
725:                   uint8_t *pData         - Pointer to where to store the data. If the endpoint
726:                                           is isochronous, this points to an
727:                                           ISOCHRONOUS_DATA_BUFFERS structure, with multiple
728:                                           data buffer pointers.
729:                   uint32_t size          - Number of data bytes to read. If the endpoint is
730:                                           isochronous, this is the number of data buffer
731:                                           pointers pointed to by pData.
732:               
733:                 Return Values:
734:                   USB_SUCCESS                     - Read started successfully.
735:                   USB_UNKNOWN_DEVICE              - Device with the specified address not found.
736:                   USB_INVALID_STATE               - We are not in a normal running state.
737:                   USB_ENDPOINT_ILLEGAL_TYPE       - Must use USBHostControlRead to read
738:                                                       from a control endpoint.
739:                   USB_ENDPOINT_ILLEGAL_DIRECTION  - Must read from an IN endpoint.
740:                   USB_ENDPOINT_STALLED            - Endpoint is stalled.  Must be cleared
741:                                                       by the application.
742:                   USB_ENDPOINT_ERROR              - Endpoint has too many errors.  Must be
743:                                                       cleared by the application.
744:                   USB_ENDPOINT_BUSY               - A Read is already in progress.
745:                   USB_ENDPOINT_NOT_FOUND          - Invalid endpoint.
746:               
747:                 Remarks:
748:                   None
749:                 ***************************************************************************/
750:               
751:               uint8_t USBHostRead( uint8_t deviceAddress, uint8_t endpoint, uint8_t *pData, uint32_t size )
752:               {
004A3A  BE9F88     MOV.D W8, [W15++]
004A3C  781F8A     MOV W10, [W15++]
004A3E  780502     MOV W2, W10
004A40  BE0404     MOV.D W4, W8
753:                   USB_ENDPOINT_INFO *ep;
754:               
755:                   // Find the required device
756:                   if (deviceAddress != usbDeviceInfo.deviceAddress)
004A44  209613     MOV #0x961, W3
004A46  104F93     SUBR.B W0, [W3], [W15]
004A48  3A0026     BRA NZ, .L130
757:                   {
758:                       return USB_UNKNOWN_DEVICE;
004A42  B3C062     MOV.B #0x6, W2
759:                   }
760:               
761:                   // If we are not in a normal user running state, we cannot do this.
762:                   if ((usbHostState & STATE_MASK) != STATE_RUNNING)
004A4A  20F003     MOV #0xF00, W3
004A4C  807D60     MOV usbHostState, W0
004A4E  618180     AND W3, W0, W3
004A52  204000     MOV #0x400, W0
004A54  518F80     SUB W3, W0, [W15]
004A56  3A001F     BRA NZ, .L130
763:                   {
764:                       return USB_INVALID_STATE;
004A50  B3C012     MOV.B #0x1, W2
765:                   }
766:               
767:                   ep = _USB_FindEndpoint( endpoint );
004A58  784001     MOV.B W1, W0
004A5A  07FE1F     RCALL _USB_FindEndpoint
004A5C  780180     MOV W0, W3
768:                   if (ep)
004A60  E00003     CP0 W3
004A62  320019     BRA Z, .L130
769:                   {
770:                       if (ep->bmAttributes.bfTransferType == USB_TRANSFER_TYPE_CONTROL)
004A64  900853     MOV [W3+26], W0
004A66  B23000     AND #0x300, W0
004A6A  320015     BRA Z, .L130
771:                       {
772:                           // Must not be a control endpoint.
773:                           return USB_ENDPOINT_ILLEGAL_TYPE;
004A68  B3C182     MOV.B #0x18, W2
774:                       }
775:               
776:                       if (!(ep->bEndpointAddress & 0x80))
004A6C  905823     MOV.B [W3+26], W0
004A70  E00400     CP0.B W0
004A72  3D0011     BRA GE, .L130
777:                       {
778:                           // Trying to do an IN with an OUT endpoint.
779:                           return USB_ENDPOINT_ILLEGAL_DIRECTION;
004A6E  B3C152     MOV.B #0x15, W2
780:                       }
781:               
782:                       if (ep->status.bfStalled)
004A74  900013     MOV [W3+2], W0
004A78  A35800     BTST.Z W0, #5
004A7A  3A000D     BRA NZ, .L130
783:                       {
784:                           // The endpoint is stalled.  It must be restarted before a write
785:                           // can be performed.
786:                           return USB_ENDPOINT_STALLED;
004A76  B3C112     MOV.B #0x11, W2
787:                       }
788:               
789:                       if (ep->status.bfError)
004A7C  900013     MOV [W3+2], W0
004A80  A36800     BTST.Z W0, #6
004A82  3A0009     BRA NZ, .L130
790:                       {
791:                           // The endpoint has errored.  The error must be cleared before a
792:                           // write can be performed.
793:                           return USB_ENDPOINT_ERROR;
004A7E  B3C122     MOV.B #0x12, W2
794:                       }
795:               
796:                       if (!ep->status.bfTransferComplete)
004A84  900013     MOV [W3+2], W0
004A88  A39800     BTST.Z W0, #9
004A8A  320005     BRA Z, .L130
797:                       {
798:                           // We are already processing a request for this endpoint.
799:                           return USB_ENDPOINT_BUSY;
004A86  B3C102     MOV.B #0x10, W2
800:                       }
801:               
802:                       _USB_InitRead( ep, pData, size );
004A8C  780108     MOV W8, W2
004A8E  78008A     MOV W10, W1
004A90  780003     MOV W3, W0
004A92  07FFA7     RCALL _USB_InitRead
803:               
804:                       return USB_SUCCESS;
004A94  EB4100     CLR.B W2
805:                   }
806:                   return USB_ENDPOINT_NOT_FOUND;   // Endpoint not found
004A5E  B3C142     MOV.B #0x14, W2
807:               }
004A96  784002     MOV.B W2, W0
004A98  78054F     MOV [--W15], W10
004A9A  BE044F     MOV.D [--W15], W8
004A9C  060000     RETURN
808:               
809:               /****************************************************************************
810:                 Function:
811:                   uint8_t USBHostResetDevice( uint8_t deviceAddress )
812:               
813:                 Summary:
814:                   This function resets an attached device.
815:               
816:                 Description:
817:                   This function places the device back in the RESET state, to issue RESET
818:                   signaling.  It can be called only if the state machine is not in the
819:                   DETACHED state.
820:               
821:                 Precondition:
822:                   None
823:               
824:                 Parameters:
825:                   uint8_t deviceAddress  - Device address
826:               
827:                 Return Values:
828:                   USB_SUCCESS         - Success
829:                   USB_UNKNOWN_DEVICE  - Device not found
830:                   USB_ILLEGAL_REQUEST - Device cannot RESUME unless it is suspended
831:               
832:                 Remarks:
833:                   In order to do a full clean-up, the state is set back to STATE_DETACHED
834:                   rather than a reset state.  The ATTACH interrupt will automatically be
835:                   triggered when the module is re-enabled, and the proper reset will be
836:                   performed.
837:                 ***************************************************************************/
838:               
839:               uint8_t USBHostResetDevice( uint8_t deviceAddress )
840:               {
0044BC  784080     MOV.B W0, W1
841:                   // Find the required device
842:                   if (deviceAddress != usbDeviceInfo.deviceAddress)
0044C0  209612     MOV #0x961, W2
0044C2  10CF92     SUBR.B W1, [W2], [W15]
0044C4  3A0007     BRA NZ, .L10
843:                   {
844:                       return USB_UNKNOWN_DEVICE;
0044BE  B3C060     MOV.B #0x6, W0
845:                   }
846:               
847:                   if ((usbHostState & STATE_MASK) == STATE_DETACHED)
0044C6  20F001     MOV #0xF00, W1
0044C8  807D60     MOV usbHostState, W0
0044CA  608080     AND W1, W0, W1
0044CE  320002     BRA Z, .L10
848:                   {
849:                       return USB_ILLEGAL_REQUEST;
0044CC  B3C030     MOV.B #0x3, W0
850:                   }
851:               
852:                   usbHostState = STATE_DETACHED;
0044D0  EF2FAC     CLR usbHostState
853:               
854:                   return USB_SUCCESS;
0044D2  EB4000     CLR.B W0
855:               }
0044D4  060000     RETURN
856:               
857:               /****************************************************************************
858:                 Function:
859:                   uint8_t USBHostResumeDevice( uint8_t deviceAddress )
860:               
861:                 Summary:
862:                   This function issues a RESUME to the attached device.
863:               
864:                 Description:
865:                   This function issues a RESUME to the attached device.  It can called only
866:                   if the state machine is in the suspend state.
867:               
868:                 Precondition:
869:                   None
870:               
871:                 Parameters:
872:                   uint8_t deviceAddress  - Device address
873:               
874:                 Return Values:
875:                   USB_SUCCESS         - Success
876:                   USB_UNKNOWN_DEVICE  - Device not found
877:                   USB_ILLEGAL_REQUEST - Device cannot RESUME unless it is suspended
878:               
879:                 Remarks:
880:                   None
881:                 ***************************************************************************/
882:               
883:               uint8_t USBHostResumeDevice( uint8_t deviceAddress )
884:               {
0044D6  784080     MOV.B W0, W1
885:                   // Find the required device
886:                   if (deviceAddress != usbDeviceInfo.deviceAddress)
0044DA  209612     MOV #0x961, W2
0044DC  10CF92     SUBR.B W1, [W2], [W15]
0044DE  3A0007     BRA NZ, .L14
887:                   {
888:                       return USB_UNKNOWN_DEVICE;
0044D8  B3C060     MOV.B #0x6, W0
889:                   }
890:               
891:                   if (usbHostState != (STATE_RUNNING | SUBSTATE_SUSPEND_AND_RESUME | SUBSUBSTATE_SUSPEND))
0044E2  204101     MOV #0x410, W1
0044E4  807D62     MOV usbHostState, W2
0044E6  510F81     SUB W2, W1, [W15]
0044E8  3A0002     BRA NZ, .L14
892:                   {
893:                       return USB_ILLEGAL_REQUEST;
0044E0  B3C030     MOV.B #0x3, W0
894:                   }
895:               
896:                   // Advance the state machine to issue resume signalling.
897:                   _USB_SetNextSubSubState();
0044EA  EC2FAC     INC usbHostState
898:               
899:                   return USB_SUCCESS;
0044EC  EB4000     CLR.B W0
900:               }
0044EE  060000     RETURN
901:               
902:               /****************************************************************************
903:                 Function:
904:                   uint8_t USBHostSetDeviceConfiguration( uint8_t deviceAddress, uint8_t configuration )
905:               
906:                 Summary:
907:                   This function changes the device's configuration.
908:               
909:                 Description:
910:                   This function is used by the application to change the device's
911:                   Configuration.  This function must be used instead of
912:                   USBHostIssueDeviceRequest(), because the endpoint definitions may change.
913:               
914:                   To see when the reconfiguration is complete, use the USBHostDeviceStatus()
915:                   function.  If configuration is still in progress, this function will
916:                   return USB_DEVICE_ENUMERATING.
917:               
918:                 Precondition:
919:                   The host state machine should be in the running state, and no reads or
920:                   writes should be in progress.
921:               
922:                 Parameters:
923:                   uint8_t deviceAddress  - Device address
924:                   uint8_t configuration  - Index of the new configuration
925:               
926:                 Return Values:
927:                   USB_SUCCESS         - Process of changing the configuration was started
928:                                           successfully.
929:                   USB_UNKNOWN_DEVICE  - Device not found
930:                   USB_INVALID_STATE   - This function cannot be called during enumeration
931:                                           or while performing a device request.
932:                   USB_BUSY            - No IN or OUT transfers may be in progress.
933:               
934:                 Example:
935:                   <code>
936:                   rc = USBHostSetDeviceConfiguration( attachedDevice, configuration );
937:                   if (rc)
938:                   {
939:                       // Error - cannot set configuration.
940:                   }
941:                   else
942:                   {
943:                       while (USBHostDeviceStatus( attachedDevice ) == USB_DEVICE_ENUMERATING)
944:                       {
945:                           USBHostTasks();
946:                       }
947:                   }
948:                   if (USBHostDeviceStatus( attachedDevice ) != USB_DEVICE_ATTACHED)
949:                   {
950:                       // Error - cannot set configuration.
951:                   }
952:                   </code>
953:               
954:                 Remarks:
955:                   If an invalid configuration is specified, this function cannot return
956:                   an error.  Instead, the event USB_UNSUPPORTED_DEVICE will the sent to the
957:                   application layer and the device will be placed in a holding state with a
958:                   USB_HOLDING_UNSUPPORTED_DEVICE error returned by USBHostDeviceStatus().
959:                 ***************************************************************************/
960:               
961:               uint8_t USBHostSetDeviceConfiguration( uint8_t deviceAddress, uint8_t configuration )
962:               {
00623E  781F88     MOV W8, [W15++]
006240  784401     MOV.B W1, W8
963:                   // Find the required device
964:                   if (deviceAddress != usbDeviceInfo.deviceAddress)
006244  209612     MOV #0x961, W2
006246  104F92     SUBR.B W0, [W2], [W15]
006248  3A0013     BRA NZ, .L579
965:                   {
966:                       return USB_UNKNOWN_DEVICE;
006242  B3C061     MOV.B #0x6, W1
967:                   }
968:               
969:                   // If we are not in a normal user running state, we cannot do this.
970:                   if ((usbHostState & STATE_MASK) != STATE_RUNNING)
00624A  20F002     MOV #0xF00, W2
00624C  807D60     MOV usbHostState, W0
00624E  610100     AND W2, W0, W2
006252  204000     MOV #0x400, W0
006254  510F80     SUB W2, W0, [W15]
006256  3A000C     BRA NZ, .L579
971:                   {
972:                       return USB_INVALID_STATE;
006250  B3C011     MOV.B #0x1, W1
973:                   }
974:               
975:                   // Make sure no other reads or writes are in progress.
976:                   if (_USB_TransferInProgress())
006258  07FFCD     RCALL _USB_TransferInProgress
00625C  E00400     CP0.B W0
00625E  3A0008     BRA NZ, .L579
977:                   {
978:                       return USB_BUSY;
00625A  B3C021     MOV.B #0x2, W1
979:                   }
980:               
981:                   // Set the new device configuration.
982:                   usbDeviceInfo.currentConfiguration = configuration;
006260  2095E0     MOV #0x95E, W0
006262  784808     MOV.B W8, [W0]
983:               
984:                   // We're going to be sending Endpoint 0 commands, so be sure the
985:                   // client driver indicates the host driver, so we do not send events up
986:                   // to a client driver.
987:                   usbDeviceInfo.pEndpoint0->clientDriver = CLIENT_DRIVER_HOST;
006264  EBC080     SETM.B W1
006266  804B60     MOV 0x96C, W0
006268  985811     MOV.B W1, [W0+25]
988:               
989:                   // Set the state back to configure the device.  This will destroy the
990:                   // endpoint list and terminate any current transactions.  We already have
991:                   // the configuration, so we can jump into the Select Configuration state.
992:                   // If the configuration value is invalid, the state machine will error and
993:                   // put the device into a holding state.
994:                   usbHostState = STATE_CONFIGURING | SUBSTATE_SELECT_CONFIGURATION;
00626A  203300     MOV #0x330, W0
00626C  887D60     MOV W0, usbHostState
995:               
996:                   return USB_SUCCESS;
00626E  EB4080     CLR.B W1
997:               }
006270  784001     MOV.B W1, W0
006272  78044F     MOV [--W15], W8
006274  060000     RETURN
998:               
999:               
1000:              /****************************************************************************
1001:                Function:
1002:                  uint8_t USBHostSetNAKTimeout( uint8_t deviceAddress, uint8_t endpoint, uint16_t flags,
1003:                              uint16_t timeoutCount )
1004:              
1005:                Summary:
1006:                  This function specifies NAK timeout capability.
1007:              
1008:                Description:
1009:                  This function is used to set whether or not an endpoint on a device
1010:                  should time out a transaction based on the number of NAKs received, and
1011:                  if so, how many NAKs are allowed before the timeout.
1012:              
1013:                Precondition:
1014:                  None
1015:              
1016:                Parameters:
1017:                  uint8_t deviceAddress  - Device address
1018:                  uint8_t endpoint       - Endpoint number to configure
1019:                  uint16_t flags          - Bit 0:
1020:                                          * 0 = disable NAK timeout
1021:                                          * 1 = enable NAK timeout
1022:                  uint16_t timeoutCount   - Number of NAKs allowed before a timeout
1023:              
1024:                Return Values:
1025:                  USB_SUCCESS             - NAK timeout was configured successfully.
1026:                  USB_UNKNOWN_DEVICE      - Device not found.
1027:                  USB_ENDPOINT_NOT_FOUND  - The specified endpoint was not found.
1028:              
1029:                Remarks:
1030:                  None
1031:                ***************************************************************************/
1032:              
1033:              uint8_t USBHostSetNAKTimeout( uint8_t deviceAddress, uint8_t endpoint, uint16_t flags, uint16_t timeoutCount )
1034:              {
004752  BE9F88     MOV.D W8, [W15++]
004754  780482     MOV W2, W9
004756  780403     MOV W3, W8
1035:                  USB_ENDPOINT_INFO *ep;
1036:              
1037:                  // Find the required device
1038:                  if (deviceAddress != usbDeviceInfo.deviceAddress)
00475A  209613     MOV #0x961, W3
00475C  104F93     SUBR.B W0, [W3], [W15]
00475E  3A000D     BRA NZ, .L66
1039:                  {
1040:                      return USB_UNKNOWN_DEVICE;
004758  B3C062     MOV.B #0x6, W2
1041:                  }
1042:              
1043:                  ep = _USB_FindEndpoint( endpoint );
004760  784001     MOV.B W1, W0
004762  07FF9B     RCALL _USB_FindEndpoint
1044:                  if (ep)
004766  E00000     CP0 W0
004768  320008     BRA Z, .L66
1045:                  {
1046:                      ep->status.bfNAKTimeoutEnabled  = flags & 0x01;
00476A  6484E1     AND W9, #0x1, W9
00476C  DD48CD     SL W9, #13, W1
00476E  900490     MOV [W0+2], W9
004770  A1D009     BCLR W9, #13
004772  708489     IOR W1, W9, W9
004774  980019     MOV W9, [W0+2]
1047:                      ep->timeoutNAKs                 = timeoutCount;
004776  981008     MOV W8, [W0+32]
1048:              
1049:                      return USB_SUCCESS;
004778  EB4100     CLR.B W2
1050:                  }
1051:                  return USB_ENDPOINT_NOT_FOUND;
004764  B3C142     MOV.B #0x14, W2
1052:              }
00477A  784002     MOV.B W2, W0
00477C  BE044F     MOV.D [--W15], W8
00477E  060000     RETURN
1053:              
1054:              
1055:              /****************************************************************************
1056:                Function:
1057:                  void USBHostShutdown( void )
1058:              
1059:                Description:
1060:                  This function turns off the USB module and frees all unnecessary memory.
1061:                  This routine can be called by the application layer to shut down all
1062:                  USB activity, which effectively detaches all devices.  The event
1063:                  EVENT_DETACH will be sent to the client drivers for the attached device,
1064:                  and the event EVENT_VBUS_RELEASE_POWER will be sent to the application
1065:                  layer.
1066:              
1067:                Precondition:
1068:                  None
1069:              
1070:                Parameters:
1071:                  None - None
1072:              
1073:                Returns:
1074:                  None
1075:              
1076:                Remarks:
1077:                  None
1078:                ***************************************************************************/
1079:              
1080:              void USBHostShutdown( void )
1081:              {
004BE2  FA0002     LNK #0x2
1082:                  // Shut off the power to the module first, in case we are in an
1083:                  // overcurrent situation.
1084:              
1085:                  #ifdef  USB_SUPPORT_OTG
1086:                      if (!USBOTGHnpIsActive())
1087:                      {
1088:                          // If we currently have an attached device, notify the higher layers that
1089:                          // the device is being removed.
1090:                          if (usbDeviceInfo.deviceAddress)
1091:                          {
1092:                              USB_VBUS_POWER_EVENT_DATA   powerRequest;
1093:              
1094:                              powerRequest.port = 0;  // Currently was have only one port.
1095:              
1096:                              USB_HOST_APP_EVENT_HANDLER( usbDeviceInfo.deviceAddress, EVENT_VBUS_RELEASE_POWER,
1097:                                  &powerRequest, sizeof(USB_VBUS_POWER_EVENT_DATA) );
1098:                              _USB_NotifyClients(usbDeviceInfo.deviceAddress, EVENT_DETACH,
1099:                                  &usbDeviceInfo.deviceAddress, sizeof(uint8_t) );
1100:              
1101:              
1102:                          }
1103:                      }
1104:                  #else
1105:                      U1PWRC = USB_NORMAL_OPERATION | USB_DISABLED;  //MR - Turning off Module will cause unwanted Suspends in OTG
004BE4  EF2488     CLR U1PWRC
1106:              
1107:                      // If we currently have an attached device, notify the higher layers that
1108:                      // the device is being removed.
1109:                      if (usbDeviceInfo.deviceAddress)
004BE6  209610     MOV #0x961, W0
004BE8  784010     MOV.B [W0], W0
004BEA  E00400     CP0.B W0
004BEC  32000F     BRA Z, .L163, .LBE3
1110:                      {
1111:                          USB_VBUS_POWER_EVENT_DATA   powerRequest;
1112:              
1113:                          powerRequest.port = 0;  // Currently was have only one port.
004BEE  EB4080     CLR.B W1
004BF0  9FFFE1     MOV.B W1, [W15-2]
1114:                          powerRequest.current = usbDeviceInfo.currentConfigurationPower;
004BF2  804B31     MOV 0x966, W1
004BF4  9FFFF1     MOV.B W1, [W15-1]
1115:              
1116:                          USB_HOST_APP_EVENT_HANDLER( usbDeviceInfo.deviceAddress,
004BF6  200024     MOV #0x2, W4
004BF8  200005     MOV #0x0, W5
004BFA  E9810F     DEC2 W15, W2
004BFC  2006A1     MOV #0x6A, W1
004BFE  072F5A     RCALL USB_Host_ApplicationEventHandler
1117:                                                      EVENT_VBUS_RELEASE_POWER,
1118:                                                      &powerRequest,
1119:                                                      sizeof(USB_VBUS_POWER_EVENT_DATA)
1120:                                                    );
1121:              
1122:                          _USB_NotifyClients( usbDeviceInfo.deviceAddress,
004C00  209610     MOV #0x961, W0
004C02  200013     MOV #0x1, W3
004C04  780100     MOV W0, W2
004C06  200711     MOV #0x71, W1
004C08  784010     MOV.B [W0], W0
004C0A  07FFA7     RCALL _USB_NotifyClients
1123:                                              EVENT_DETACH,
1124:                                              &usbDeviceInfo.deviceAddress,
1125:                                              sizeof(uint8_t)
1126:                                            );
1127:              
1128:              
1129:                      }
1130:                  #endif
1131:              
1132:                  // Free all extra allocated memory, initialize variables, and reset the
1133:                  // state machine.
1134:                  USBHostInit( 0 );
004C0C  B80060     MUL.UU W0, #0, W0
004C0E  07FE7E     RCALL USBHostInit
1135:              }
004C10  FA8000     ULNK
004C12  060000     RETURN
1136:              
1137:              
1138:              /****************************************************************************
1139:                Function:
1140:                  uint8_t USBHostSuspendDevice( uint8_t deviceAddress )
1141:              
1142:                Summary:
1143:                  This function suspends a device.
1144:              
1145:                Description:
1146:                  This function put a device into an IDLE state.  It can only be called
1147:                  while the state machine is in normal running mode.  After 3ms, the
1148:                  attached device should go into SUSPEND mode.
1149:              
1150:                Precondition:
1151:                  None
1152:              
1153:                Parameters:
1154:                  uint8_t deviceAddress  - Device to suspend
1155:              
1156:                Return Values:
1157:                  USB_SUCCESS         - Success
1158:                  USB_UNKNOWN_DEVICE  - Device not found
1159:                  USB_ILLEGAL_REQUEST - Cannot suspend unless device is in normal run mode
1160:              
1161:                Remarks:
1162:                  None
1163:                ***************************************************************************/
1164:              
1165:              uint8_t USBHostSuspendDevice( uint8_t deviceAddress )
1166:              {
0044F0  784080     MOV.B W0, W1
1167:                  // Find the required device
1168:                  if (deviceAddress != usbDeviceInfo.deviceAddress)
0044F4  209612     MOV #0x961, W2
0044F6  10CF92     SUBR.B W1, [W2], [W15]
0044F8  3A0009     BRA NZ, .L18
1169:                  {
1170:                      return USB_UNKNOWN_DEVICE;
0044F2  B3C060     MOV.B #0x6, W0
1171:                  }
1172:              
1173:                  if (usbHostState != (STATE_RUNNING | SUBSTATE_NORMAL_RUN))
0044FC  204001     MOV #0x400, W1
0044FE  807D62     MOV usbHostState, W2
004500  510F81     SUB W2, W1, [W15]
004502  3A0004     BRA NZ, .L18
1174:                  {
1175:                      return USB_ILLEGAL_REQUEST;
0044FA  B3C030     MOV.B #0x3, W0
1176:                  }
1177:              
1178:                  // Turn off SOF's, so the bus is idle.
1179:                  U1CONbits.SOFEN = 0;
004504  A90494     BCLR U1CON, #0
1180:              
1181:                  // Put the state machine in suspend mode.
1182:                  usbHostState = STATE_RUNNING | SUBSTATE_SUSPEND_AND_RESUME | SUBSUBSTATE_SUSPEND;
004506  204100     MOV #0x410, W0
004508  887D60     MOV W0, usbHostState
1183:              
1184:                  return USB_SUCCESS;
00450A  EB4000     CLR.B W0
1185:              }
00450C  060000     RETURN
1186:              
1187:              /****************************************************************************
1188:                Function:
1189:                  void USBHostTasks( void )
1190:              
1191:                Summary:
1192:                  This function executes the host tasks for USB host operation.
1193:              
1194:                Description:
1195:                  This function executes the host tasks for USB host operation.  It must be
1196:                  executed on a regular basis to keep everything functioning.
1197:              
1198:                  The primary purpose of this function is to handle device attach/detach
1199:                  and enumeration.  It does not handle USB packet transmission or
1200:                  reception; that must be done in the USB interrupt handler to ensure
1201:                  timely operation.
1202:              
1203:                  This routine should be called on a regular basis, but there is no
1204:                  specific time requirement.  Devices will still be able to attach,
1205:                  enumerate, and detach, but the operations will occur more slowly as the
1206:                  calling interval increases.
1207:              
1208:                Precondition:
1209:                  USBHostInit() has been called.
1210:              
1211:                Parameters:
1212:                  None
1213:              
1214:                Returns:
1215:                  None
1216:              
1217:                Remarks:
1218:                  None
1219:                ***************************************************************************/
1220:              
1221:              void USBHostTasks( void )
1222:              {
004F02  FA0002     LNK #0x2
004F04  BE9F88     MOV.D W8, [W15++]
004F06  BE9F8A     MOV.D W10, [W15++]
004F08  BE9F8C     MOV.D W12, [W15++]
1223:                  static USB_CONFIGURATION    *pCurrentConfigurationNode;  //MR - made static for OTG
1224:                  USB_INTERFACE_INFO          *pCurrentInterface;
1225:                  uint8_t                        *pTemp;
1226:                  uint8_t                        temp;
1227:                  USB_VBUS_POWER_EVENT_DATA   powerRequest;
1228:              
1229:                  // The PIC32MX detach interrupt is not reliable.  If we are not in one of
1230:                  // the detached states, we'll do a check here to see if we've detached.
1231:                  // If the ATTACH bit is 0, we have detached.
1232:                  #ifdef __PIC32__
1233:                      #ifdef USE_MANUAL_DETACH_DETECT
1234:                          if (((usbHostState & STATE_MASK) != STATE_DETACHED) && !U1IRbits.ATTACHIF)
1235:                          {
1236:              #if defined (DEBUG_ENABLE)
1237:                              DEBUG_PutChar( '>' );
1238:                              DEBUG_PutChar( ']' );
1239:              #endif
1240:              
1241:                              usbHostState = STATE_DETACHED;
1242:                          }
1243:                      #endif
1244:                  #endif
1245:              
1246:                  // Send any queued events to the client and application layers.
1247:                  #if defined ( USB_ENABLE_TRANSFER_EVENT )
1248:                  {
1249:                      USB_EVENT_DATA *item;
1250:                      #if defined( __C30__ ) || defined __XC16__
1251:                          uint16_t        interrupt_mask;
1252:                      #elif defined( __PIC32__ )
1253:                          uint32_t      interrupt_mask;
1254:                      #else
1255:                          #error Cannot save interrupt status
1256:                      #endif
1257:              
1258:                      while (StructQueueIsNotEmpty(&usbEventQueue, USB_EVENT_QUEUE_DEPTH))
004F0A  804BA0     MOV 0x974, W0
004F0C  E00000     CP0 W0
004F0E  320025     BRA Z, .L233, .LBE4
004F56  E00000     CP0 W0
004F58  3AFFE0     BRA NZ, .L349
1259:                      {
1260:                          item = StructQueuePeekTail(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
004F10  209728     MOV #0x972, W8
004F12  4404E4     ADD W8, #0x4, W9
004F14  E98588     DEC2 W8, W11
004F1A  780018     MOV [W8], W0
004F1C  780109     MOV W9, W2
004F1E  500FE2     SUB W0, #0x2, [W15]
004F20  3C0004     BRA GT, .L234
004F22  E80100     INC W0, W2
004F24  B9116C     MUL.SU W2, #12, W2
004F26  410166     ADD W2, #0x6, W2
004F28  41010B     ADD W2, W11, W2
1261:              
1262:                          switch(item->event)
004F18  27FFFA     MOV #0x7FFF, W10
004F2A  780092     MOV [W2], W1
004F2C  200720     MOV #0x72, W0
004F2E  508F80     SUB W1, W0, [W15]
004F30  320002     BRA Z, .L236
004F32  508F8A     SUB W1, W10, [W15]
004F34  3A0004     BRA NZ, .L235
1263:                          {
1264:                              case EVENT_TRANSFER:
1265:                              case EVENT_BUS_ERROR:
1266:                                  _USB_NotifyClients( usbDeviceInfo.deviceAddress, item->event, &item->TransferData, sizeof(HOST_TRANSFER_DATA) );
004F16  20961C     MOV #0x961, W12
004F36  E88102     INC2 W2, W2
004F38  2000A3     MOV #0xA, W3
004F3A  78401C     MOV.B [W12], W0
004F3C  07FE0E     RCALL _USB_NotifyClients
1267:                                  break;
1268:                              default:
1269:                                  break;
1270:                          }
1271:              
1272:                          // Guard against USB interrupts
1273:                          interrupt_mask = U1IE;
004F3E  802462     MOV U1IE, W2
1274:                          U1IE = 0;
004F40  EF248C     CLR U1IE
1275:              
1276:                          item = StructQueueRemove(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
004F42  209741     MOV #0x974, W1
004F44  E90011     DEC [W1], W0
004F46  780880     MOV W0, [W1]
004F48  780098     MOV [W8], W1
004F4A  508FE2     SUB W1, #0x2, [W15]
004F4C  3C0002     BRA GT, .L237
004F4E  E80C01     INC W1, [W8]
004F50  370001     BRA .L238
004F52  EB0C00     CLR [W8]
1277:              
1278:                          // Re-enable USB interrupts
1279:                          U1IE = interrupt_mask;
004F54  882462     MOV W2, U1IE
1280:                      }
1281:                  }
1282:                  #endif
1283:              
1284:                  // See if we got an interrupt to change our state.
1285:                  if (usbOverrideHostState != NO_STATE)
004F5A  807D40     MOV usbOverrideHostState, W0
004F5C  400FE1     ADD W0, #0x1, [W15]
004F5E  320003     BRA Z, .L240
1286:                  {
1287:              #if defined (DEBUG_ENABLE)
1288:                      DEBUG_PutChar('>');
1289:              #endif
1290:              
1291:                      usbHostState = usbOverrideHostState;
004F60  F80FA8     PUSH usbOverrideHostState
004F62  F90FAC     POP usbHostState
1292:                      usbOverrideHostState = NO_STATE;
004F64  EFAFA8     SETM usbOverrideHostState
1293:                  }
1294:              
1295:                  //-------------------------------------------------------------------------
1296:                  // Main State Machine
1297:              
1298:                  switch (usbHostState & STATE_MASK)
004F66  20F000     MOV #0xF00, W0
004F68  B60FAC     AND usbHostState, WREG
004F6A  202001     MOV #0x200, W1
004F6C  500F81     SUB W0, W1, [W15]
004F6E  3201A8     BRA Z, .L244
004F70  3E0006     BRA GTU, .L248
004F72  E00000     CP0 W0
004F74  32000E     BRA Z, .L242
004F76  201001     MOV #0x100, W1
004F78  500F81     SUB W0, W1, [W15]
004F7A  3A040C     BRA NZ, .L232
004F7C  37008B     BRA .L356
004F7E  204001     MOV #0x400, W1
004F80  500F81     SUB W0, W1, [W15]
004F82  3203B5     BRA Z, .L246
004F84  B01001     ADD #0x100, W1
004F86  500F81     SUB W0, W1, [W15]
004F88  3203D2     BRA Z, .L247
004F8A  203001     MOV #0x300, W1
004F8C  500F81     SUB W0, W1, [W15]
004F8E  3A0402     BRA NZ, .L232
004F90  3701D0     BRA .L357
1299:                  {
1300:                      case STATE_DETACHED:
1301:                          switch (usbHostState & SUBSTATE_MASK)
004F92  200F00     MOV #0xF0, W0
004F94  B60FAC     AND usbHostState, WREG
004F96  500FF0     SUB W0, #0x10, [W15]
004F98  320056     BRA Z, .L250
004F9A  200201     MOV #0x20, W1
004F9C  500F81     SUB W0, W1, [W15]
004F9E  32005A     BRA Z, .L251
004FA0  E00000     CP0 W0
004FA2  3A03F8     BRA NZ, .L232
1302:                          {
1303:                              case SUBSTATE_INITIALIZE:
1304:                                  // We got here either from initialization or from the user
1305:                                  // unplugging the device at any point in time.
1306:              
1307:                                  // Turn off the module and free up memory.
1308:                                  USBHostShutdown();
004FA4  07FE1E     RCALL USBHostShutdown
1309:              
1310:              #if defined (DEBUG_ENABLE)
1311:                                  DEBUG_PutString( "HOST: Initializing DETACHED state.\r\n" );
1312:              #endif
1313:              
1314:                                  // Initialize Endpoint 0 attributes.
1315:                                  usbDeviceInfo.pEndpoint0->next                         = NULL;
004FA6  EB0080     CLR W1
004FA8  804B60     MOV 0x96C, W0
004FAA  780801     MOV W1, [W0]
1316:                                  usbDeviceInfo.pEndpoint0->status.val                   = 0x00;
004FAC  2096C0     MOV #0x96C, W0
004FAE  780110     MOV [W0], W2
004FB0  980111     MOV W1, [W2+2]
1317:                                  usbDeviceInfo.pEndpoint0->status.bfUseDTS              = 1;
004FB2  780110     MOV [W0], W2
004FB4  900192     MOV [W2+2], W3
004FB6  A0A003     BSET W3, #10
004FB8  980113     MOV W3, [W2+2]
1318:                                  usbDeviceInfo.pEndpoint0->status.bfTransferComplete    = 1;    // Initialize to success to allow preprocessing loops.
004FBA  780110     MOV [W0], W2
004FBC  900192     MOV [W2+2], W3
004FBE  A09003     BSET W3, #9
004FC0  980113     MOV W3, [W2+2]
1319:                                  usbDeviceInfo.pEndpoint0->status.bfNAKTimeoutEnabled   = 1;    // So we can catch devices that NAK forever during enumeration
004FC2  780110     MOV [W0], W2
004FC4  900192     MOV [W2+2], W3
004FC6  A0D003     BSET W3, #13
004FC8  980113     MOV W3, [W2+2]
1320:                                  usbDeviceInfo.pEndpoint0->timeoutNAKs                  = USB_NUM_CONTROL_NAKS;
004FCA  780110     MOV [W0], W2
004FCC  200143     MOV #0x14, W3
004FCE  981103     MOV W3, [W2+32]
1321:                                  usbDeviceInfo.pEndpoint0->wMaxPacketSize               = 64;
004FD0  200403     MOV #0x40, W3
004FD2  980143     MOV W3, [W2+8]
1322:                                  usbDeviceInfo.pEndpoint0->dataCount                    = 0;    // Initialize to 0 since we set bfTransferComplete.
004FD4  780110     MOV [W0], W2
004FD6  B82260     MUL.UU W4, #0, W4
004FD8  980904     MOV W4, [W2+16]
004FDA  980915     MOV W5, [W2+18]
1323:                                  usbDeviceInfo.pEndpoint0->bEndpointAddress             = 0;
004FDC  780010     MOV [W0], W0
004FDE  EB4100     CLR.B W2
004FE0  985821     MOV.B W1, [W0+26]
1324:                                  usbDeviceInfo.pEndpoint0->transferState                = TSTATE_IDLE;
004FE2  985802     MOV.B W2, [W0+24]
1325:                                  usbDeviceInfo.pEndpoint0->bmAttributes.bfTransferType  = USB_TRANSFER_TYPE_CONTROL;
004FE4  900A50     MOV [W0+26], W4
004FE6  2FCFF3     MOV #0xFCFF, W3
004FE8  620183     AND W4, W3, W3
004FEA  980853     MOV W3, [W0+26]
1326:                                  usbDeviceInfo.pEndpoint0->clientDriver                 = CLIENT_DRIVER_HOST;
004FEC  EBC180     SETM.B W3
004FEE  985813     MOV.B W3, [W0+25]
1327:              
1328:                                  // Initialize any device specific information.
1329:                                  numEnumerationTries                 = USB_NUM_ENUMERATION_TRIES;
004FF0  B3C030     MOV.B #0x3, W0
004FF2  B7EFB7     MOV.B WREG, numEnumerationTries
1330:                                  usbDeviceInfo.currentConfiguration  = 0; // Will be overwritten by config process or the user later
004FF4  2095E0     MOV #0x95E, W0
004FF6  784802     MOV.B W2, [W0]
1331:                                  usbDeviceInfo.attributesOTG         = 0;
004FF8  E80000     INC W0, W0
004FFA  784802     MOV.B W2, [W0]
1332:                                  usbDeviceInfo.deviceAddressAndSpeed = 0;
004FFC  E80000     INC W0, W0
004FFE  784802     MOV.B W2, [W0]
1333:                                  usbDeviceInfo.flags.val             = 0;
005000  884B71     MOV W1, 0x96E
1334:                                  usbDeviceInfo.pInterfaceList        = NULL;
005002  884B51     MOV W1, 0x96A
1335:                                  usbBusInfo.flags.val                = 0;
005004  EF2FB0     CLR usbBusInfo
1336:              
1337:                                  // Set up the hardware.
1338:                                  U1IE                = 0;        // Clear and turn off interrupts.
005006  EF248C     CLR U1IE
1339:                                  U1IR                = 0xFF;
005008  200FF0     MOV #0xFF, W0
00500A  882450     MOV W0, U1IR
1340:                                  U1OTGIE             &= 0x8C;
00500C  2008C1     MOV #0x8C, W1
00500E  204825     MOV #0x482, W5
005010  608A95     AND W1, [W5], [W5]
1341:                                  U1OTGIR             = 0x7D;
005012  5080EF     SUB W1, #0xF, W1
005014  882401     MOV W1, U1OTGIR
1342:                                  U1EIE               = 0;
005016  EF2490     CLR U1EIE
1343:                                  U1EIR               = 0xFF;
005018  882470     MOV W0, U1EIR
1344:              
1345:                                  // Initialize the Buffer Descriptor Table pointer.
1346:                                  #if defined(__C30__) || defined __XC16__
1347:                                     U1BDTP1 = (uint16_t)(&BDT) >> 8;
00501A  20A000     MOV #0xA00, W0
00501C  DE0048     LSR W0, #8, W0
00501E  8824C0     MOV W0, U1BDTP1
1348:                                  #elif defined(__PIC32__)
1349:                                     U1BDTP1 = ((uint32_t)KVA_TO_PA(&BDT) & 0x0000FF00) >> 8;
1350:                                     U1BDTP2 = ((uint32_t)KVA_TO_PA(&BDT) & 0x00FF0000) >> 16;
1351:                                     U1BDTP3 = ((uint32_t)KVA_TO_PA(&BDT) & 0xFF000000) >> 24;
1352:                                  #else
1353:                                      #error Cannot set up the Buffer Descriptor Table pointer.
1354:                                  #endif
1355:              
1356:                                  // Configure the module
1357:                                  U1CON               = USB_HOST_MODE_ENABLE | USB_SOF_DISABLE;                       // Turn of SOF's to cut down noise
005020  200080     MOV #0x8, W0
005022  8824A0     MOV W0, U1CON
1358:                                  U1CON               = USB_HOST_MODE_ENABLE | USB_PINGPONG_RESET | USB_SOF_DISABLE;  // Reset the ping-pong buffers
005024  2000A1     MOV #0xA, W1
005026  8824A1     MOV W1, U1CON
1359:                                  U1CON               = USB_HOST_MODE_ENABLE | USB_SOF_DISABLE;                       // Release the ping-pong buffers
005028  8824A0     MOV W0, U1CON
1360:                                  #ifdef  USB_SUPPORT_OTG
1361:                                      U1OTGCON            |= USB_DPLUS_PULLDOWN_ENABLE | USB_DMINUS_PULLDOWN_ENABLE | USB_OTG_ENABLE; // Pull down D+ and D-
1362:                                  #else
1363:                                      U1OTGCON            = USB_DPLUS_PULLDOWN_ENABLE | USB_DMINUS_PULLDOWN_ENABLE; // Pull down D+ and D-
00502A  200300     MOV #0x30, W0
00502C  882430     MOV W0, U1OTGCON
1364:                                  #endif
1365:              
1366:                                  #if defined(__PIC32__)
1367:                                      U1OTGCON |= USB_VBUS_ON;
1368:                                  #endif
1369:              
1370:                                  U1CNFG1             = USB_PING_PONG_MODE;
00502E  200020     MOV #0x2, W0
005030  882530     MOV W0, U1CNFG1
1371:                                  #if defined(__C30__) || defined __XC16__
1372:                                      U1CNFG2         = USB_VBUS_BOOST_ENABLE | USB_VBUS_COMPARE_ENABLE | USB_ONCHIP_ENABLE;
005032  EF24A8     CLR U1CNFG2
1373:                                  #endif
1374:                                  U1ADDR              = 0;                        // Set default address and LSPDEN to 0
005034  EF2496     CLR U1ADDR
1375:                                  U1EP0bits.LSPD      = 0;
005036  A9E4AA     BCLR U1EP0, #7
1376:                                  U1SOF               = USB_SOF_THRESHOLD_64;     // Maximum EP0 packet size
005038  2004A0     MOV #0x4A, W0
00503A  882500     MOV W0, U1SOF
1377:              
1378:                                  // Set the next substate.  We do this before we enable
1379:                                  // interrupts in case the interrupt changes states.
1380:                                  _USB_SetNextSubState();
00503C  20FF00     MOV #0xFF0, W0
00503E  B60FAC     AND usbHostState, WREG
005040  400070     ADD W0, #0x10, W0
005042  887D60     MOV W0, usbHostState
1381:                                  break;
005044  3703A7     BRA .L232
1382:              
1383:                              case SUBSTATE_WAIT_FOR_POWER:
1384:                                  // We will wait here until the application tells us we can
1385:                                  // turn on power.
1386:                                  if (usbRootHubInfo.flags.bPowerGoodPort0)
005046  AB0FB8     BTST usbRootHubInfo, #0
005048  3203A5     BRA Z, .L232
1387:                                  {
1388:                                      _USB_SetNextSubState();
00504A  20FF00     MOV #0xFF0, W0
00504C  B60FAC     AND usbHostState, WREG
00504E  400070     ADD W0, #0x10, W0
005050  887D60     MOV W0, usbHostState
005052  3703A0     BRA .L232
1389:                                  }
1390:                                  break;
1391:              
1392:                              case SUBSTATE_TURN_ON_POWER:
1393:                                  powerRequest.port       = 0;
005054  EB4000     CLR.B W0
005056  9FF7A0     MOV.B W0, [W15-14]
1394:                                  powerRequest.current    = USB_INITIAL_VBUS_CURRENT;
005058  B3C320     MOV.B #0x32, W0
00505A  9FF7B0     MOV.B W0, [W15-13]
1395:                                  if (USB_HOST_APP_EVENT_HANDLER( USB_ROOT_HUB, EVENT_VBUS_REQUEST_POWER,
00505C  200024     MOV #0x2, W4
00505E  200005     MOV #0x0, W5
005060  57816E     SUB W15, #0xE, W2
005062  200691     MOV #0x69, W1
005064  EBC000     SETM.B W0
005066  072D26     RCALL USB_Host_ApplicationEventHandler
005068  E00400     CP0.B W0
00506A  320010     BRA Z, .L252
1396:                                          &powerRequest, sizeof(USB_VBUS_POWER_EVENT_DATA) ))
1397:                                  {
1398:                                      // Power on the module
1399:                                      U1PWRC                = USB_NORMAL_OPERATION | USB_ENABLED;
00506C  200010     MOV #0x1, W0
00506E  882440     MOV W0, U1PWRC
1400:              
1401:                                      #if defined( __C30__ ) || defined __XC16__
1402:                                          _USB1IF = 0;
005070  A9C08E     BCLR IFS5, #6
1403:                                          _USB1IP = 6;
005072  2F8FF1     MOV #0xF8FF, W1
005074  800672     MOV IPC21, W2
005076  608082     AND W1, W2, W1
005078  206000     MOV #0x600, W0
00507A  700001     IOR W0, W1, W0
00507C  880670     MOV W0, IPC21
1404:                                          _USB1IE = 1;
00507E  A8C09E     BSET IEC5, #6
1405:                                      #elif defined( __PIC32__ )
1406:                                          // Enable the USB interrupt.
1407:                                          _ClearUSBIF();
1408:                                          #if defined(_IPC11_USBIP_MASK)
1409:                                              IPC11CLR        = _IPC11_USBIP_MASK | _IPC11_USBIS_MASK;
1410:                                              IPC11SET        = _IPC11_USBIP_MASK & (0x00000004 << _IPC11_USBIP_POSITION);
1411:                                          #elif defined(_IPC7_USBIP_MASK)
1412:                                              IPC7CLR        = _IPC7_USBIP_MASK | _IPC7_USBIS_MASK;
1413:                                              IPC7SET        = _IPC7_USBIP_MASK & (0x00000004 << _IPC7_USBIP_POSITION);
1414:                                          #else
1415:                                              #error "The selected PIC32 device is not currently supported by usb_host.c."
1416:                                          #endif
1417:                                          _SetUSBIE();
1418:                                      #else
1419:                                          #error Cannot enable USB interrupt.
1420:                                      #endif
1421:              
1422:                                      // Set the next substate.  We do this before we enable
1423:                                      // interrupts in case the interrupt changes states.
1424:                                      _USB_SetNextSubState();
005080  20FF00     MOV #0xFF0, W0
005082  B60FAC     AND usbHostState, WREG
005084  400070     ADD W0, #0x10, W0
005086  887D60     MOV W0, usbHostState
1425:              
1426:                                      // Enable the ATTACH interrupt.
1427:                                      U1IEbits.ATTACHIE = 1;
005088  A8C48C     BSET U1IE, #6
00508A  370384     BRA .L232
1428:              
1429:                                      #if defined(USB_ENABLE_1MS_EVENT)
1430:                                          U1OTGIR                 = USB_INTERRUPT_T1MSECIF; // The interrupt is cleared by writing a '1' to the flag.
1431:                                          U1OTGIEbits.T1MSECIE    = 1;
1432:                                      #endif
1433:                                  }
1434:                                  else
1435:                                  {
1436:                                      usbRootHubInfo.flags.bPowerGoodPort0 = 0;
00508C  A90FB8     BCLR usbRootHubInfo, #0
1437:                                      usbHostState = STATE_DETACHED | SUBSTATE_WAIT_FOR_POWER;
00508E  200100     MOV #0x10, W0
005090  887D60     MOV W0, usbHostState
005092  370380     BRA .L232
1438:                                  }
1439:                                  break;
1440:              
1441:                              case SUBSTATE_WAIT_FOR_DEVICE:
1442:                                  // Wait here for the ATTACH interrupt.
1443:                                  #ifdef  USB_SUPPORT_OTG
1444:                                      U1IEbits.ATTACHIE = 1;
1445:                                  #endif
1446:                              break;
1447:                          }
1448:                          break;
1449:              
1450:                      case STATE_ATTACHED:
1451:                          switch (usbHostState & SUBSTATE_MASK)
005094  200F00     MOV #0xF0, W0
005096  B60FAC     AND usbHostState, WREG
005098  200201     MOV #0x20, W1
00509A  500F81     SUB W0, W1, [W15]
00509C  32007C     BRA Z, .L255
00509E  3E0005     BRA GTU, .L258
0050A0  E00000     CP0 W0
0050A2  32000A     BRA Z, .L253
0050A4  500FF0     SUB W0, #0x10, [W15]
0050A6  3A0376     BRA NZ, .L232
0050A8  37001C     BRA .L358
0050AA  200301     MOV #0x30, W1
0050AC  500F81     SUB W0, W1, [W15]
0050AE  3200D0     BRA Z, .L256
0050B0  4080F0     ADD W1, #0x10, W1
0050B2  500F81     SUB W0, W1, [W15]
0050B4  3A036F     BRA NZ, .L232
0050B6  3700FE     BRA .L359
1452:                          {
1453:                              case SUBSTATE_SETTLE:
1454:                                  // Wait 100ms for the insertion process to complete and power
1455:                                  // at the device to be stable.
1456:                                  switch (usbHostState & SUBSUBSTATE_MASK)
0050B8  807D60     MOV usbHostState, W0
0050BA  60006F     AND W0, #0xF, W0
0050BC  320003     BRA Z, .L259
0050BE  500FE2     SUB W0, #0x2, [W15]
0050C0  3A0369     BRA NZ, .L232
0050C2  37000A     BRA .L360
1457:                                  {
1458:                                      case SUBSUBSTATE_START_SETTLING_DELAY:
1459:              #if defined (DEBUG_ENABLE)
1460:                                          DEBUG_PutString( "HOST: Starting settling delay.\r\n" );
1461:              #endif
1462:              
1463:                                          // Clear and turn on the DETACH interrupt.
1464:                                          U1IR                    = USB_INTERRUPT_DETACH;   // The interrupt is cleared by writing a '1' to the flag.
0050C4  200010     MOV #0x1, W0
0050C6  882450     MOV W0, U1IR
1465:                                          U1IEbits.DETACHIE       = 1;
0050C8  A8048C     BSET U1IE, #0
1466:              
1467:                                          // Configure and turn on the settling timer - 100ms.
1468:                                          numTimerInterrupts      = USB_INSERT_TIME;
0050CA  200FB0     MOV #0xFB, W0
0050CC  887D50     MOV W0, numTimerInterrupts
1469:                                          U1OTGIR                 = USB_INTERRUPT_T1MSECIF; // The interrupt is cleared by writing a '1' to the flag.
0050CE  200400     MOV #0x40, W0
0050D0  882400     MOV W0, U1OTGIR
1470:                                          U1OTGIEbits.T1MSECIE    = 1;
0050D2  A8C482     BSET U1OTGIE, #6
1471:                                          _USB_SetNextSubSubState();
0050D4  EC2FAC     INC usbHostState
1472:                                          break;
0050D6  37035E     BRA .L232
1473:              
1474:                                      case SUBSUBSTATE_WAIT_FOR_SETTLING:
1475:                                          // Wait for the timer to finish in the background.
1476:                                          break;
1477:              
1478:                                      case SUBSUBSTATE_SETTLING_DONE:
1479:                                          _USB_SetNextSubState();
0050D8  20FF00     MOV #0xFF0, W0
0050DA  B60FAC     AND usbHostState, WREG
0050DC  400070     ADD W0, #0x10, W0
0050DE  887D60     MOV W0, usbHostState
1480:                                          break;
0050E0  370359     BRA .L232
1481:              
1482:                                      default:
1483:                                          // We shouldn't get here.
1484:                                          break;
1485:                                  }
1486:                                  break;
1487:              
1488:                              case SUBSTATE_RESET_DEVICE:
1489:                                  // Reset the device.  We have to do the reset timing ourselves.
1490:                                  switch (usbHostState & SUBSUBSTATE_MASK)
0050E2  807D60     MOV usbHostState, W0
0050E4  60006F     AND W0, #0xF, W0
0050E6  500FE2     SUB W0, #0x2, [W15]
0050E8  320044     BRA Z, .L262
0050EA  500FE4     SUB W0, #0x4, [W15]
0050EC  32004B     BRA Z, .L263
0050EE  E00000     CP0 W0
0050F0  3A0351     BRA NZ, .L232
1491:                                  {
1492:                                      case SUBSUBSTATE_SET_RESET:
1493:              #if defined (DEBUG_ENABLE)
1494:                                          DEBUG_PutString( "HOST: Resetting the device.\r\n" );
1495:              #endif
1496:              
1497:                                          // Prepare a data buffer for us to use.  We'll make it 8 bytes for now,
1498:                                          // which is the minimum wMaxPacketSize for EP0.
1499:                                          if (pEP0Data != NULL)
0050F2  807DA0     MOV pEP0Data, W0
0050F4  E00000     CP0 W0
0050F6  320001     BRA Z, .L264
1500:                                          {
1501:                                              USB_FREE_AND_CLEAR( pEP0Data );
0050F8  07D947     RCALL 0x388
1502:                                          }
1503:              
1504:                                          if ((pEP0Data = (uint8_t *)USB_MALLOC( 8 )) == NULL)
0050FA  200080     MOV #0x8, W0
0050FC  07D9AA     RCALL 0x452
0050FE  887DA0     MOV W0, pEP0Data
005100  E00000     CP0 W0
005102  3A0006     BRA NZ, .L265
1505:                                          {
1506:              #if defined (DEBUG_ENABLE)
1507:                                              DEBUG_PutString( "HOST: Error alloc-ing pEP0Data\r\n" );
1508:              #endif
1509:              
1510:                                              _USB_SetErrorCode( USB_HOLDING_OUT_OF_MEMORY );
005104  B3C331     MOV.B #0x33, W1
005106  209620     MOV #0x962, W0
005108  784801     MOV.B W1, [W0]
1511:                                              _USB_SetHoldState();
00510A  205000     MOV #0x500, W0
00510C  887D60     MOV W0, usbHostState
1512:                                              break;
00510E  370342     BRA .L232
1513:                                          }
1514:              
1515:                                          // Initialize the USB Device information
1516:                                          usbDeviceInfo.currentConfiguration      = 0;
005110  EB4000     CLR.B W0
005112  2095E1     MOV #0x95E, W1
005114  784880     MOV.B W0, [W1]
1517:                                          usbDeviceInfo.attributesOTG             = 0;
005116  E80081     INC W1, W1
005118  784880     MOV.B W0, [W1]
1518:                                          usbDeviceInfo.flags.val                 = 0;
00511A  40806F     ADD W1, #0xF, W0
00511C  EB0800     CLR [W0]
1519:              
1520:                                          _USB_InitErrorCounters();
00511E  B3C030     MOV.B #0x3, W0
005120  B7EFB6     MOV.B WREG, numCommandTries
1521:              
1522:                                          // Disable all EP's except EP0.
1523:                                          U1EP0  = USB_ENDPOINT_CONTROL_SETUP;
005122  2000D0     MOV #0xD, W0
005124  882550     MOV W0, U1EP0
1524:                                          U1EP1  = USB_DISABLE_ENDPOINT;
005126  EF24AC     CLR U1EP1
1525:                                          U1EP2  = USB_DISABLE_ENDPOINT;
005128  EF24AE     CLR U1EP2
1526:                                          U1EP3  = USB_DISABLE_ENDPOINT;
00512A  EF24B0     CLR U1EP3
1527:                                          U1EP4  = USB_DISABLE_ENDPOINT;
00512C  EF24B2     CLR U1EP4
1528:                                          U1EP5  = USB_DISABLE_ENDPOINT;
00512E  EF24B4     CLR U1EP5
1529:                                          U1EP6  = USB_DISABLE_ENDPOINT;
005130  EF24B6     CLR U1EP6
1530:                                          U1EP7  = USB_DISABLE_ENDPOINT;
005132  EF24B8     CLR U1EP7
1531:                                          U1EP8  = USB_DISABLE_ENDPOINT;
005134  EF24BA     CLR U1EP8
1532:                                          U1EP9  = USB_DISABLE_ENDPOINT;
005136  EF24BC     CLR U1EP9
1533:                                          U1EP10 = USB_DISABLE_ENDPOINT;
005138  EF24BE     CLR U1EP10
1534:                                          U1EP11 = USB_DISABLE_ENDPOINT;
00513A  EF24C0     CLR U1EP11
1535:                                          U1EP12 = USB_DISABLE_ENDPOINT;
00513C  EF24C2     CLR U1EP12
1536:                                          U1EP13 = USB_DISABLE_ENDPOINT;
00513E  EF24C4     CLR U1EP13
1537:                                          U1EP14 = USB_DISABLE_ENDPOINT;
005140  EF24C6     CLR U1EP14
1538:                                          U1EP15 = USB_DISABLE_ENDPOINT;
005142  EF24C8     CLR U1EP15
1539:              
1540:                                          // See if the device is low speed.
1541:                                          if (!U1CONbits.JSTATE)
005144  ABE494     BTST U1CON, #7
005146  3A0008     BRA NZ, .L266
1542:                                          {
1543:              #if defined (DEBUG_ENABLE)
1544:                                              DEBUG_PutString( "HOST: Low Speed!\r\n" );
1545:              #endif
1546:              
1547:                                              usbDeviceInfo.flags.bfIsLowSpeed    = 1;
005148  40806F     ADD W1, #0xF, W0
00514A  A00010     BSET [W0], #0
1548:                                              usbDeviceInfo.deviceAddressAndSpeed = 0x80;
00514C  B3C801     MOV.B #0x80, W1
00514E  50006E     SUB W0, #0xE, W0
005150  784801     MOV.B W1, [W0]
1549:                                              U1ADDR                              = 0x80;
005152  200800     MOV #0x80, W0
005154  8824B0     MOV W0, U1ADDR
1550:                                              U1EP0bits.LSPD                      = 1;
005156  A8E4AA     BSET U1EP0, #7
1551:                                          }
1552:              
1553:                                          // Reset all ping-pong buffers if they are being used.
1554:                                          U1CONbits.PPBRST                    = 1;
005158  A82494     BSET U1CON, #1
1555:                                          U1CONbits.PPBRST                    = 0;
00515A  A92494     BCLR U1CON, #1
1556:                                          usbDeviceInfo.flags.bfPingPongIn    = 0;
00515C  2096E0     MOV #0x96E, W0
00515E  A14010     BCLR [W0], #4
1557:                                          usbDeviceInfo.flags.bfPingPongOut   = 0;
005160  A15010     BCLR [W0], #5
1558:              
1559:                                          #ifdef  USB_SUPPORT_OTG
1560:                                              //Disable HNP
1561:                                              USBOTGDisableHnp();
1562:                                              USBOTGDeactivateHnp();
1563:                                          #endif
1564:              
1565:                                          // Assert reset for 10ms.  Start a timer countdown.
1566:                                          U1CONbits.USBRST                    = 1;
005162  A88494     BSET U1CON, #4
1567:                                          numTimerInterrupts                  = USB_RESET_TIME;
005164  200330     MOV #0x33, W0
005166  887D50     MOV W0, numTimerInterrupts
1568:                                          //U1OTGIRbits.T1MSECIF                = 1;       // The interrupt is cleared by writing a '1' to the flag.
1569:                                          U1OTGIR                             = USB_INTERRUPT_T1MSECIF; // The interrupt is cleared by writing a '1' to the flag.
005168  40006D     ADD W0, #0xD, W0
00516A  882400     MOV W0, U1OTGIR
1570:                                          U1OTGIEbits.T1MSECIE                = 1;
00516C  A8C482     BSET U1OTGIE, #6
1571:              
1572:                                          _USB_SetNextSubSubState();
00516E  EC2FAC     INC usbHostState
1573:                                          break;
005170  370311     BRA .L232
1574:              
1575:                                      case SUBSUBSTATE_RESET_WAIT:
1576:                                          // Wait for the timer to finish in the background.
1577:                                          break;
1578:              
1579:                                      case SUBSUBSTATE_RESET_RECOVERY:
1580:              #if defined (DEBUG_ENABLE)
1581:                                          DEBUG_PutString( "HOST: Reset complete.\r\n" );
1582:              #endif
1583:              
1584:                                          // Deassert reset.
1585:                                          U1CONbits.USBRST        = 0;
005172  A98494     BCLR U1CON, #4
1586:              
1587:                                          // Start sending SOF's.
1588:                                          U1CONbits.SOFEN         = 1;
005174  A80494     BSET U1CON, #0
1589:              
1590:                                          // Wait for the reset recovery time.
1591:                                          numTimerInterrupts      = USB_RESET_RECOVERY_TIME;
005176  2000B0     MOV #0xB, W0
005178  887D50     MOV W0, numTimerInterrupts
1592:                                          U1OTGIR                 = USB_INTERRUPT_T1MSECIF; // The interrupt is cleared by writing a '1' to the flag.
00517A  200400     MOV #0x40, W0
00517C  882400     MOV W0, U1OTGIR
1593:                                          U1OTGIEbits.T1MSECIE    = 1;
00517E  A8C482     BSET U1OTGIE, #6
1594:              
1595:                                          _USB_SetNextSubSubState();
005180  EC2FAC     INC usbHostState
1596:                                          break;
005182  370308     BRA .L232
1597:              
1598:                                      case SUBSUBSTATE_RECOVERY_WAIT:
1599:                                          // Wait for the timer to finish in the background.
1600:                                          break;
1601:              
1602:                                      case SUBSUBSTATE_RESET_COMPLETE:
1603:              #if defined (DEBUG_ENABLE)
1604:                                          DEBUG_PutString( "HOST: Reset complete.\r\n" );
1605:              #endif
1606:              
1607:                                          // Enable USB interrupts
1608:                                          U1IE                    = USB_INTERRUPT_TRANSFER | USB_INTERRUPT_SOF | USB_INTERRUPT_ERROR | USB_INTERRUPT_DETACH;
005184  2000F0     MOV #0xF, W0
005186  882460     MOV W0, U1IE
1609:                                          U1EIE                   = 0xFF;
005188  200FF0     MOV #0xFF, W0
00518A  882480     MOV W0, U1EIE
1610:              
1611:                                          _USB_SetNextSubState();
00518C  20FF00     MOV #0xFF0, W0
00518E  B60FAC     AND usbHostState, WREG
005190  400070     ADD W0, #0x10, W0
005192  887D60     MOV W0, usbHostState
1612:                                          break;
005194  3702FF     BRA .L232
1613:              
1614:                                      default:
1615:                                          // We shouldn't get here.
1616:                                          break;
1617:                                  }
1618:                                  break;
1619:              
1620:                              case SUBSTATE_GET_DEVICE_DESCRIPTOR_SIZE:
1621:                                  // Send the GET DEVICE DESCRIPTOR command to get just the size
1622:                                  // of the descriptor and the max packet size, so we can allocate
1623:                                  // a large enough buffer for getting the whole thing and enough
1624:                                  // buffer space for each piece.
1625:                                  switch (usbHostState & SUBSUBSTATE_MASK)
005196  807D60     MOV usbHostState, W0
005198  60006F     AND W0, #0xF, W0
00519A  500FE1     SUB W0, #0x1, [W15]
00519C  32001E     BRA Z, .L268
00519E  390003     BRA NC, .L267
0051A0  500FE2     SUB W0, #0x2, [W15]
0051A2  3A02F8     BRA NZ, .L232
0051A4  37002F     BRA .L361
1626:                                  {
1627:                                      case SUBSUBSTATE_SEND_GET_DEVICE_DESCRIPTOR_SIZE:
1628:              #if defined (DEBUG_ENABLE)
1629:                                          DEBUG_PutString( "HOST: Getting Device Descriptor size.\r\n" );
1630:              #endif
1631:              
1632:                                          // Set up and send GET DEVICE DESCRIPTOR
1633:                                          if (pDeviceDescriptor != NULL)
0051A6  807D30     MOV pDeviceDescriptor, W0
0051A8  E00000     CP0 W0
0051AA  320002     BRA Z, .L270
1634:                                          {
1635:                                              USB_FREE_AND_CLEAR( pDeviceDescriptor );
0051AC  07D8ED     RCALL 0x388
0051AE  EF2FA6     CLR pDeviceDescriptor
1636:                                          }
1637:              
1638:                                          pEP0Data[0] = USB_SETUP_DEVICE_TO_HOST | USB_SETUP_TYPE_STANDARD | USB_SETUP_RECIPIENT_DEVICE;
0051B0  807DA1     MOV pEP0Data, W1
0051B2  B3C800     MOV.B #0x80, W0
0051B4  784880     MOV.B W0, [W1]
1639:                                          pEP0Data[1] = USB_REQUEST_GET_DESCRIPTOR;
0051B6  B3C060     MOV.B #0x6, W0
0051B8  984090     MOV.B W0, [W1+1]
1640:                                          pEP0Data[2] = 0; // Index
0051BA  EB4000     CLR.B W0
0051BC  9840A0     MOV.B W0, [W1+2]
1641:                                          pEP0Data[3] = USB_DESCRIPTOR_DEVICE; // Type
0051BE  B3C012     MOV.B #0x1, W2
0051C0  9840B2     MOV.B W2, [W1+3]
1642:                                          pEP0Data[4] = 0;
0051C2  9840C0     MOV.B W0, [W1+4]
1643:                                          pEP0Data[5] = 0;
0051C4  9840D0     MOV.B W0, [W1+5]
1644:                                          pEP0Data[6] = 8;
0051C6  B3C082     MOV.B #0x8, W2
0051C8  9840E2     MOV.B W2, [W1+6]
1645:                                          pEP0Data[7] = 0;
0051CA  9840F0     MOV.B W0, [W1+7]
1646:              
1647:                                          _USB_InitControlRead( usbDeviceInfo.pEndpoint0, pEP0Data, 8, pEP0Data, 8 );
0051CC  200084     MOV #0x8, W4
0051CE  780181     MOV W1, W3
0051D0  780104     MOV W4, W2
0051D2  804B60     MOV 0x96C, W0
0051D4  07FBB9     RCALL _USB_InitControlRead
1648:                                          _USB_SetNextSubSubState();
0051D6  EC2FAC     INC usbHostState
1649:                                          break;
0051D8  3702DD     BRA .L232
1650:              
1651:                                      case SUBSUBSTATE_WAIT_FOR_GET_DEVICE_DESCRIPTOR_SIZE:
1652:                                          if (usbDeviceInfo.pEndpoint0->status.bfTransferComplete)
0051DA  804B60     MOV 0x96C, W0
0051DC  900090     MOV [W0+2], W1
0051DE  A39801     BTST.Z W1, #9
0051E0  3202D9     BRA Z, .L232
1653:                                          {
1654:                                              if (usbDeviceInfo.pEndpoint0->status.bfTransferSuccessful)
0051E2  900010     MOV [W0+2], W0
0051E4  A38800     BTST.Z W0, #8
0051E6  32000C     BRA Z, .L271
1655:                                              {
1656:                                                  #ifndef USB_HUB_SUPPORT_INCLUDED
1657:                                                      // See if a hub is attached.  Hubs are not supported.
1658:                                                      if (pEP0Data[4] == USB_HUB_CLASSCODE)   // bDeviceClass
0051E8  807DA0     MOV pEP0Data, W0
0051EA  904040     MOV.B [W0+4], W0
0051EC  504FE9     SUB.B W0, #0x9, [W15]
0051EE  3A0006     BRA NZ, .L272
1659:                                                      {
1660:                                                          _USB_SetErrorCode( USB_HOLDING_UNSUPPORTED_HUB );
0051F0  B3C351     MOV.B #0x35, W1
0051F2  209620     MOV #0x962, W0
0051F4  784801     MOV.B W1, [W0]
1661:                                                          _USB_SetHoldState();
0051F6  205000     MOV #0x500, W0
0051F8  887D60     MOV W0, usbHostState
0051FA  3702CC     BRA .L232
1662:                                                      }
1663:                                                      else
1664:                                                      {
1665:                                                          _USB_SetNextSubSubState();
0051FC  EC2FAC     INC usbHostState
0051FE  3702CA     BRA .L232
1666:                                                      }
1667:                                                  #else
1668:                                                      _USB_SetNextSubSubState();
1669:                                                  #endif
1670:                                              }
1671:                                              else
1672:                                              {
1673:                                                  // We are here because of either a STALL or a NAK.  See if
1674:                                                  // we have retries left to try the command again or try to
1675:                                                  // enumerate again.
1676:                                                  _USB_CheckCommandAndEnumerationAttempts();
005200  07F986     RCALL _USB_CheckCommandAndEnumerationAttempts
005202  3702C8     BRA .L232
1677:                                              }
1678:                                          }
1679:                                          break;
1680:              
1681:                                      case SUBSUBSTATE_GET_DEVICE_DESCRIPTOR_SIZE_COMPLETE:
1682:                                          // Allocate a buffer for the entire Device Descriptor
1683:                                          if ((pDeviceDescriptor = (uint8_t *)USB_MALLOC( *pEP0Data )) == NULL)
005204  807DA8     MOV pEP0Data, W8
005206  FB8018     ZE [W8], W0
005208  07D924     RCALL 0x452
00520A  887D30     MOV W0, pDeviceDescriptor
00520C  E00000     CP0 W0
00520E  3A0006     BRA NZ, .L273
1684:                                          {
1685:                                              // We cannot continue.  Freeze until the device is removed.
1686:                                              _USB_SetErrorCode( USB_HOLDING_OUT_OF_MEMORY );
005210  B3C331     MOV.B #0x33, W1
005212  209620     MOV #0x962, W0
005214  784801     MOV.B W1, [W0]
1687:                                              _USB_SetHoldState();
005216  205000     MOV #0x500, W0
005218  887D60     MOV W0, usbHostState
1688:                                              break;
00521A  3702BC     BRA .L232
1689:                                          }
1690:                                          // Save the descriptor size in the descriptor (bLength)
1691:                                          *pDeviceDescriptor = *pEP0Data;
00521C  784818     MOV.B [W8], [W0]
1692:              
1693:                                          // Set the EP0 packet size.
1694:                                          usbDeviceInfo.pEndpoint0->wMaxPacketSize = ((USB_DEVICE_DESCRIPTOR *)pEP0Data)->bMaxPacketSize0;
00521E  9040F8     MOV.B [W8+7], W1
005220  FB8081     ZE W1, W1
005222  804B60     MOV 0x96C, W0
005224  980041     MOV W1, [W0+8]
1695:              
1696:                                          // Make our pEP0Data buffer the size of the max packet.
1697:                                          USB_FREE_AND_CLEAR( pEP0Data );
005226  780008     MOV W8, W0
005228  07D8AF     RCALL 0x388
1698:                                          if ((pEP0Data = (uint8_t *)USB_MALLOC( usbDeviceInfo.pEndpoint0->wMaxPacketSize )) == NULL)
00522A  804B60     MOV 0x96C, W0
00522C  900040     MOV [W0+8], W0
00522E  07D911     RCALL 0x452
005230  887DA0     MOV W0, pEP0Data
005232  E00000     CP0 W0
005234  3A0006     BRA NZ, .L274
1699:                                          {
1700:                                              // We cannot continue.  Freeze until the device is removed.
1701:              #if defined (DEBUG_ENABLE)
1702:                                              DEBUG_PutString( "HOST: Error re-alloc-ing pEP0Data\r\n" );
1703:              #endif
1704:              
1705:                                              _USB_SetErrorCode( USB_HOLDING_OUT_OF_MEMORY );
005236  B3C331     MOV.B #0x33, W1
005238  209620     MOV #0x962, W0
00523A  784801     MOV.B W1, [W0]
1706:                                              _USB_SetHoldState();
00523C  205000     MOV #0x500, W0
00523E  887D60     MOV W0, usbHostState
1707:                                              break;
005240  3702A9     BRA .L232
1708:                                          }
1709:              
1710:                                          // Clean up and advance to the next substate.
1711:                                          _USB_InitErrorCounters();
005242  B3C030     MOV.B #0x3, W0
005244  B7EFB6     MOV.B WREG, numCommandTries
1712:                                          _USB_SetNextSubState();
005246  20FF00     MOV #0xFF0, W0
005248  B60FAC     AND usbHostState, WREG
00524A  400070     ADD W0, #0x10, W0
00524C  887D60     MOV W0, usbHostState
1713:                                          break;
00524E  3702A2     BRA .L232
1714:              
1715:                                      default:
1716:                                          break;
1717:                                  }
1718:                                  break;
1719:              
1720:                              case SUBSTATE_GET_DEVICE_DESCRIPTOR:
1721:                                  // Send the GET DEVICE DESCRIPTOR command and receive the response
1722:                                  switch (usbHostState & SUBSUBSTATE_MASK)
005250  807D60     MOV usbHostState, W0
005252  60006F     AND W0, #0xF, W0
005254  500FE1     SUB W0, #0x1, [W15]
005256  32001C     BRA Z, .L276
005258  390003     BRA NC, .L275
00525A  500FE2     SUB W0, #0x2, [W15]
00525C  3A029B     BRA NZ, .L232
00525E  370023     BRA .L362
1723:                                  {
1724:                                      case SUBSUBSTATE_SEND_GET_DEVICE_DESCRIPTOR:
1725:              #if defined (DEBUG_ENABLE)
1726:                                          DEBUG_PutString( "HOST: Getting device descriptor.\r\n" );
1727:              #endif
1728:              
1729:                                          // If we are currently sending a token, we cannot do anything.
1730:                                          if (usbBusInfo.flags.bfTokenAlreadyWritten)   //(U1CONbits.TOKBUSY)
005260  AB8FB0     BTST usbBusInfo, #4
005262  3A0298     BRA NZ, .L232
1731:                                              break;
1732:              
1733:                                          // Set up and send GET DEVICE DESCRIPTOR
1734:                                          pEP0Data[0] = USB_SETUP_DEVICE_TO_HOST | USB_SETUP_TYPE_STANDARD | USB_SETUP_RECIPIENT_DEVICE;
005264  807DA1     MOV pEP0Data, W1
005266  B3C800     MOV.B #0x80, W0
005268  784880     MOV.B W0, [W1]
1735:                                          pEP0Data[1] = USB_REQUEST_GET_DESCRIPTOR;
00526A  B3C060     MOV.B #0x6, W0
00526C  984090     MOV.B W0, [W1+1]
1736:                                          pEP0Data[2] = 0; // Index
00526E  EB4000     CLR.B W0
005270  9840A0     MOV.B W0, [W1+2]
1737:                                          pEP0Data[3] = USB_DESCRIPTOR_DEVICE; // Type
005272  B3C012     MOV.B #0x1, W2
005274  9840B2     MOV.B W2, [W1+3]
1738:                                          pEP0Data[4] = 0;
005276  9840C0     MOV.B W0, [W1+4]
1739:                                          pEP0Data[5] = 0;
005278  9840D0     MOV.B W0, [W1+5]
1740:                                          pEP0Data[6] = *pDeviceDescriptor;
00527A  807D32     MOV pDeviceDescriptor, W2
00527C  784112     MOV.B [W2], W2
00527E  9840E2     MOV.B W2, [W1+6]
1741:                                          pEP0Data[7] = 0;
005280  9840F0     MOV.B W0, [W1+7]
1742:                                          _USB_InitControlRead( usbDeviceInfo.pEndpoint0, pEP0Data, 8, pDeviceDescriptor, *pDeviceDescriptor  );
005282  807D33     MOV pDeviceDescriptor, W3
005284  FB8213     ZE [W3], W4
005286  200082     MOV #0x8, W2
005288  804B60     MOV 0x96C, W0
00528A  07FB5E     RCALL _USB_InitControlRead
1743:                                          _USB_SetNextSubSubState();
00528C  EC2FAC     INC usbHostState
1744:                                          break;
00528E  370282     BRA .L232
1745:              
1746:                                      case SUBSUBSTATE_WAIT_FOR_GET_DEVICE_DESCRIPTOR:
1747:                                          if (usbDeviceInfo.pEndpoint0->status.bfTransferComplete)
005290  804B60     MOV 0x96C, W0
005292  900090     MOV [W0+2], W1
005294  A39801     BTST.Z W1, #9
005296  32027E     BRA Z, .L232
1748:                                          {
1749:                                              if (usbDeviceInfo.pEndpoint0->status.bfTransferSuccessful)
005298  900010     MOV [W0+2], W0
00529A  A38800     BTST.Z W0, #8
00529C  320002     BRA Z, .L278
1750:                                              {
1751:                                                  _USB_SetNextSubSubState();
00529E  EC2FAC     INC usbHostState
0052A0  370279     BRA .L232
1752:                                              }
1753:                                              else
1754:                                              {
1755:                                                  // We are here because of either a STALL or a NAK.  See if
1756:                                                  // we have retries left to try the command again or try to
1757:                                                  // enumerate again.
1758:                                                  _USB_CheckCommandAndEnumerationAttempts();
0052A2  07F935     RCALL _USB_CheckCommandAndEnumerationAttempts
0052A4  370277     BRA .L232
1759:                                              }
1760:                                          }
1761:                                          break;
1762:              
1763:                                      case SUBSUBSTATE_GET_DEVICE_DESCRIPTOR_COMPLETE:
1764:                                          // Clean up and advance to the next substate.
1765:                                          _USB_InitErrorCounters();
0052A6  B3C030     MOV.B #0x3, W0
0052A8  B7EFB6     MOV.B WREG, numCommandTries
1766:                                          _USB_SetNextSubState();
0052AA  20FF00     MOV #0xFF0, W0
0052AC  B60FAC     AND usbHostState, WREG
0052AE  400070     ADD W0, #0x10, W0
0052B0  887D60     MOV W0, usbHostState
1767:                                          break;
0052B2  370270     BRA .L232
1768:              
1769:                                      default:
1770:                                          break;
1771:                                  }
1772:                                  break;
1773:              
1774:                              case SUBSTATE_VALIDATE_VID_PID:
1775:              #if defined (DEBUG_ENABLE)
1776:                                  DEBUG_PutString( "HOST: Validating VID and PID.\r\n" );
1777:              #endif
1778:              
1779:                                  // Search the TPL for the device's VID & PID.  If a client driver is
1780:                                  // available for the over-all device, use it.  Otherwise, we'll search
1781:                                  // again later for an appropriate class driver.
1782:                                  _USB_FindDeviceLevelClientDriver();
0052B4  07F983     RCALL _USB_FindDeviceLevelClientDriver
1783:              
1784:                                  // Advance to the next state to assign an address to the device.
1785:                                  //
1786:                                  // Note: We assign an address to all devices and hold later if
1787:                                  // we can't find a supported configuration.
1788:                                  _USB_SetNextState();
0052B6  20F000     MOV #0xF00, W0
0052B8  B60FAC     AND usbHostState, WREG
0052BA  B01000     ADD #0x100, W0
0052BC  887D60     MOV W0, usbHostState
1789:                                  break;
0052BE  37026A     BRA .L232
1790:                          }
1791:                          break;
1792:              
1793:                      case STATE_ADDRESSING:
1794:                          switch (usbHostState & SUBSTATE_MASK)
0052C0  200F00     MOV #0xF0, W0
0052C2  B60FAC     AND usbHostState, WREG
0052C4  3A0267     BRA NZ, .L232
1795:                          {
1796:                              case SUBSTATE_SET_DEVICE_ADDRESS:
1797:                                  // Send the SET ADDRESS command.  We can't set the device address
1798:                                  // in hardware until the entire transaction is complete.
1799:                                  switch (usbHostState & SUBSUBSTATE_MASK)
0052C6  807D60     MOV usbHostState, W0
0052C8  60006F     AND W0, #0xF, W0
0052CA  500FE1     SUB W0, #0x1, [W15]
0052CC  32001A     BRA Z, .L281
0052CE  390003     BRA NC, .L280
0052D0  500FE2     SUB W0, #0x2, [W15]
0052D2  3A0260     BRA NZ, .L232
0052D4  370021     BRA .L363
1800:                                  {
1801:                                      case SUBSUBSTATE_SEND_SET_DEVICE_ADDRESS:
1802:              #if defined (DEBUG_ENABLE)
1803:                                          DEBUG_PutString( "HOST: Setting device address.\r\n" );
1804:              #endif
1805:              
1806:                                          // Select an address for the device.  Store it so we can access it again
1807:                                          // easily.  We'll put the low speed indicator on later.
1808:                                          // This has been broken out so when we allow multiple devices, we have
1809:                                          // a single interface point to allocate a new address.
1810:                                          usbDeviceInfo.deviceAddress = USB_SINGLE_DEVICE_ADDRESS;
0052D6  209612     MOV #0x961, W2
0052D8  B3C010     MOV.B #0x1, W0
0052DA  784900     MOV.B W0, [W2]
1811:              
1812:                                          // Set up and send SET ADDRESS
1813:                                          pEP0Data[0] = USB_SETUP_HOST_TO_DEVICE | USB_SETUP_TYPE_STANDARD | USB_SETUP_RECIPIENT_DEVICE;
0052DC  807DA1     MOV pEP0Data, W1
0052DE  EB4000     CLR.B W0
0052E0  784880     MOV.B W0, [W1]
1814:                                          pEP0Data[1] = USB_REQUEST_SET_ADDRESS;
0052E2  B3C053     MOV.B #0x5, W3
0052E4  984093     MOV.B W3, [W1+1]
1815:                                          pEP0Data[2] = usbDeviceInfo.deviceAddress;
0052E6  784112     MOV.B [W2], W2
0052E8  9840A2     MOV.B W2, [W1+2]
1816:                                          pEP0Data[3] = 0;
0052EA  9840B0     MOV.B W0, [W1+3]
1817:                                          pEP0Data[4] = 0;
0052EC  9840C0     MOV.B W0, [W1+4]
1818:                                          pEP0Data[5] = 0;
0052EE  9840D0     MOV.B W0, [W1+5]
1819:                                          pEP0Data[6] = 0;
0052F0  9840E0     MOV.B W0, [W1+6]
1820:                                          pEP0Data[7] = 0;
0052F2  9840F0     MOV.B W0, [W1+7]
1821:                                          _USB_InitControlWrite( usbDeviceInfo.pEndpoint0, pEP0Data, 8, NULL, 0 );
0052F4  EB0200     CLR W4
0052F6  EB0180     CLR W3
0052F8  200082     MOV #0x8, W2
0052FA  804B60     MOV 0x96C, W0
0052FC  07FB49     RCALL _USB_InitControlWrite
1822:                                          _USB_SetNextSubSubState();
0052FE  EC2FAC     INC usbHostState
1823:                                          break;
005300  370249     BRA .L232
1824:              
1825:                                      case SUBSUBSTATE_WAIT_FOR_SET_DEVICE_ADDRESS:
1826:                                          if (usbDeviceInfo.pEndpoint0->status.bfTransferComplete)
005302  804B60     MOV 0x96C, W0
005304  900090     MOV [W0+2], W1
005306  A39801     BTST.Z W1, #9
005308  320245     BRA Z, .L232
1827:                                          {
1828:                                              if (usbDeviceInfo.pEndpoint0->status.bfTransferSuccessful)
00530A  900010     MOV [W0+2], W0
00530C  A38800     BTST.Z W0, #8
00530E  320002     BRA Z, .L283
1829:                                              {
1830:                                                  _USB_SetNextSubSubState();
005310  EC2FAC     INC usbHostState
005312  370240     BRA .L232
1831:                                              }
1832:                                              else
1833:                                              {
1834:                                                  // We are here because of either a STALL or a NAK.  See if
1835:                                                  // we have retries left to try the command again or try to
1836:                                                  // enumerate again.
1837:                                                  _USB_CheckCommandAndEnumerationAttempts();
005314  07F8FC     RCALL _USB_CheckCommandAndEnumerationAttempts
005316  37023E     BRA .L232
1838:                                              }
1839:                                          }
1840:                                          break;
1841:              
1842:                                      case SUBSUBSTATE_SET_DEVICE_ADDRESS_COMPLETE:
1843:                                          // Set the device's address here.
1844:                                          usbDeviceInfo.deviceAddressAndSpeed = (usbDeviceInfo.flags.bfIsLowSpeed << 7) | usbDeviceInfo.deviceAddress;
005318  804B71     MOV 0x96E, W1
00531A  6080E1     AND W1, #0x1, W1
00531C  DD08C7     SL W1, #7, W1
00531E  209612     MOV #0x961, W2
005320  E90002     DEC W2, W0
005322  70C812     IOR.B W1, [W2], [W0]
1845:              
1846:                                          // Clean up and advance to the next state.
1847:                                          _USB_InitErrorCounters();
005324  B3C030     MOV.B #0x3, W0
005326  B7EFB6     MOV.B WREG, numCommandTries
1848:                                          _USB_SetNextState();
005328  20F000     MOV #0xF00, W0
00532A  B60FAC     AND usbHostState, WREG
00532C  B01000     ADD #0x100, W0
00532E  887D60     MOV W0, usbHostState
1849:                                          break;
005330  370231     BRA .L232
1850:              
1851:                                      default:
1852:                                          break;
1853:                                  }
1854:                                  break;
1855:                          }
1856:                          break;
1857:              
1858:                      case STATE_CONFIGURING:
1859:                          switch (usbHostState & SUBSTATE_MASK)
005332  200F00     MOV #0xF0, W0
005334  B60FAC     AND usbHostState, WREG
005336  200201     MOV #0x20, W1
005338  500F81     SUB W0, W1, [W15]
00533A  320090     BRA Z, .L286
00533C  3E0005     BRA GTU, .L290
00533E  E00000     CP0 W0
005340  32000D     BRA Z, .L284
005342  500FF0     SUB W0, #0x10, [W15]
005344  3A0227     BRA NZ, .L232
005346  37002D     BRA .L364
005348  200401     MOV #0x40, W1
00534A  500F81     SUB W0, W1, [W15]
00534C  320148     BRA Z, .L288
00534E  4080F0     ADD W1, #0x10, W1
005350  500F81     SUB W0, W1, [W15]
005352  320153     BRA Z, .L289
005354  200301     MOV #0x30, W1
005356  500F81     SUB W0, W1, [W15]
005358  3A021D     BRA NZ, .L232
00535A  3700C0     BRA .L365
1860:                          {
1861:                              case SUBSTATE_INIT_CONFIGURATION:
1862:                                  // Delete the old list of configuration descriptors and
1863:                                  // initialize the counter.  We will request the descriptors
1864:                                  // from highest to lowest so the lowest will be first in
1865:                                  // the list.
1866:                                  countConfigurations = ((USB_DEVICE_DESCRIPTOR *)pDeviceDescriptor)->bNumConfigurations;
00535C  807D30     MOV pDeviceDescriptor, W0
00535E  905590     MOV.B [W0+17], W11
005360  20FB94     MOV #0xFB9, W4
005362  784A0B     MOV.B W11, [W4]
1867:                                  while (usbDeviceInfo.pConfigurationDescriptorList != NULL)
005364  804B40     MOV 0x968, W0
005366  E00000     CP0 W0
005368  3A0003     BRA NZ, .L354
00536A  37000E     BRA .L291
00536C  780008     MOV W8, W0
00536E  370002     BRA .L355
005384  E00008     CP0 W8
005386  3AFFF2     BRA NZ, .L344
1868:                                  {
1869:                                      pTemp = (uint8_t *)usbDeviceInfo.pConfigurationDescriptorList->next;
005374  900410     MOV [W0+2], W8
1870:                                      USB_FREE_AND_CLEAR( usbDeviceInfo.pConfigurationDescriptorList->descriptor );
005370  EB0500     CLR W10
005376  780010     MOV [W0], W0
005378  07D807     RCALL 0x388
00537A  804B40     MOV 0x968, W0
00537C  78080A     MOV W10, [W0]
1871:                                      USB_FREE_AND_CLEAR( usbDeviceInfo.pConfigurationDescriptorList );
005372  209689     MOV #0x968, W9
00537E  780019     MOV [W9], W0
005380  07D803     RCALL 0x388
1872:                                      usbDeviceInfo.pConfigurationDescriptorList = (USB_CONFIGURATION *)pTemp;
005382  780C88     MOV W8, [W9]
1873:                                  }
1874:              
1875:                                  if(countConfigurations == 0)
005388  E0040B     CP0.B W11
00538A  3A0006     BRA NZ, .L293
1876:                                  {
1877:                                      _USB_SetErrorCode( USB_HOLDING_CLIENT_INIT_ERROR );
00538C  B3C391     MOV.B #0x39, W1
00538E  209620     MOV #0x962, W0
005390  784801     MOV.B W1, [W0]
1878:                                      _USB_SetHoldState();
005392  205000     MOV #0x500, W0
005394  887D60     MOV W0, usbHostState
005396  3701FE     BRA .L232
1879:                                  }
1880:                                  else
1881:                                  {
1882:                                      _USB_SetNextSubState();
005398  20FF00     MOV #0xFF0, W0
00539A  B60FAC     AND usbHostState, WREG
00539C  400070     ADD W0, #0x10, W0
00539E  887D60     MOV W0, usbHostState
0053A0  3701F9     BRA .L232
1883:                                  }
1884:                                  break;
1885:              
1886:                              case SUBSTATE_GET_CONFIG_DESCRIPTOR_SIZE:
1887:                                  // Get the size of the Configuration Descriptor for the current configuration
1888:                                  switch (usbHostState & SUBSUBSTATE_MASK)
0053A2  807D60     MOV usbHostState, W0
0053A4  60006F     AND W0, #0xF, W0
0053A6  500FE1     SUB W0, #0x1, [W15]
0053A8  32001A     BRA Z, .L295
0053AA  390003     BRA NC, .L294
0053AC  500FE2     SUB W0, #0x2, [W15]
0053AE  3A01F2     BRA NZ, .L232
0053B0  370021     BRA .L366
1889:                                  {
1890:                                      case SUBSUBSTATE_SEND_GET_CONFIG_DESCRIPTOR_SIZE:
1891:              #if defined (DEBUG_ENABLE)
1892:                                          DEBUG_PutString( "HOST: Getting Config Descriptor size.\r\n" );
1893:              #endif
1894:              
1895:                                          // Set up and send GET CONFIGURATION (n) DESCRIPTOR with a length of 8
1896:                                          pEP0Data[0] = USB_SETUP_DEVICE_TO_HOST | USB_SETUP_TYPE_STANDARD | USB_SETUP_RECIPIENT_DEVICE;
0053B2  807DA1     MOV pEP0Data, W1
0053B4  B3C800     MOV.B #0x80, W0
0053B6  784880     MOV.B W0, [W1]
1897:                                          pEP0Data[1] = USB_REQUEST_GET_DESCRIPTOR;
0053B8  B3C060     MOV.B #0x6, W0
0053BA  984090     MOV.B W0, [W1+1]
1898:                                          pEP0Data[2] = countConfigurations-1;    // USB 2.0 - range is 0 - count-1
0053BC  ED4FB9     DEC.B countConfigurations, WREG
0053BE  9840A0     MOV.B W0, [W1+2]
1899:                                          pEP0Data[3] = USB_DESCRIPTOR_CONFIGURATION;
0053C0  B3C020     MOV.B #0x2, W0
0053C2  9840B0     MOV.B W0, [W1+3]
1900:                                          pEP0Data[4] = 0;
0053C4  EB4000     CLR.B W0
0053C6  9840C0     MOV.B W0, [W1+4]
1901:                                          pEP0Data[5] = 0;
0053C8  9840D0     MOV.B W0, [W1+5]
1902:                                          pEP0Data[6] = 8;
0053CA  B3C082     MOV.B #0x8, W2
0053CC  9840E2     MOV.B W2, [W1+6]
1903:                                          pEP0Data[7] = 0;
0053CE  9840F0     MOV.B W0, [W1+7]
1904:                                          _USB_InitControlRead( usbDeviceInfo.pEndpoint0, pEP0Data, 8, pEP0Data, 8 );
0053D0  200084     MOV #0x8, W4
0053D2  780181     MOV W1, W3
0053D4  780104     MOV W4, W2
0053D6  804B60     MOV 0x96C, W0
0053D8  07FAB7     RCALL _USB_InitControlRead
1905:                                          _USB_SetNextSubSubState();
0053DA  EC2FAC     INC usbHostState
1906:                                          break;
0053DC  3701DB     BRA .L232
1907:              
1908:                                      case SUBSUBSTATE_WAIT_FOR_GET_CONFIG_DESCRIPTOR_SIZE:
1909:                                          if (usbDeviceInfo.pEndpoint0->status.bfTransferComplete)
0053DE  804B60     MOV 0x96C, W0
0053E0  900090     MOV [W0+2], W1
0053E2  A39801     BTST.Z W1, #9
0053E4  3201D7     BRA Z, .L232
1910:                                          {
1911:                                              if (usbDeviceInfo.pEndpoint0->status.bfTransferSuccessful)
0053E6  900010     MOV [W0+2], W0
0053E8  A38800     BTST.Z W0, #8
0053EA  320002     BRA Z, .L297
1912:                                              {
1913:                                                  _USB_SetNextSubSubState();
0053EC  EC2FAC     INC usbHostState
0053EE  3701D2     BRA .L232
1914:                                              }
1915:                                              else
1916:                                              {
1917:                                                  // We are here because of either a STALL or a NAK.  See if
1918:                                                  // we have retries left to try the command again or try to
1919:                                                  // enumerate again.
1920:                                                  _USB_CheckCommandAndEnumerationAttempts();
0053F0  07F88E     RCALL _USB_CheckCommandAndEnumerationAttempts
0053F2  3701D0     BRA .L232
1921:                                              }
1922:                                          }
1923:                                          break;
1924:              
1925:                                      case SUBSUBSTATE_GET_CONFIG_DESCRIPTOR_SIZECOMPLETE:
1926:                                          // Allocate a buffer for an entry in the configuration descriptor list.
1927:                                          if ((pTemp = (uint8_t *)USB_MALLOC( sizeof (USB_CONFIGURATION) )) == NULL)
0053F4  200060     MOV #0x6, W0
0053F6  07D82D     RCALL 0x452
0053F8  780400     MOV W0, W8
0053FA  E00008     CP0 W8
0053FC  3A0006     BRA NZ, .L298
1928:                                          {
1929:                                              // We cannot continue.  Freeze until the device is removed.
1930:                                              _USB_SetErrorCode( USB_HOLDING_OUT_OF_MEMORY );
0053FE  B3C331     MOV.B #0x33, W1
005400  209620     MOV #0x962, W0
005402  784801     MOV.B W1, [W0]
1931:                                              _USB_SetHoldState();
005404  205000     MOV #0x500, W0
005406  887D60     MOV W0, usbHostState
1932:                                              break;
005408  3701C5     BRA .L232
1933:                                          }
1934:              
1935:                                          // Allocate a buffer for the entire Configuration Descriptor
1936:                                          if ((((USB_CONFIGURATION *)pTemp)->descriptor = (uint8_t *)USB_MALLOC( ((uint16_t)pEP0Data[3] << 8) + (uint16_t)pEP0Data[2] )) == NULL)
00540A  807DAB     MOV pEP0Data, W11
00540C  458563     ADD W11, #0x3, W10
00540E  E8858B     INC2 W11, W11
005410  FB809A     ZE [W10], W1
005412  DD08C8     SL W1, #8, W1
005414  FB801B     ZE [W11], W0
005416  408000     ADD W1, W0, W0
005418  07D81C     RCALL 0x452
00541A  780C00     MOV W0, [W8]
00541C  E00000     CP0 W0
00541E  3A0008     BRA NZ, .L299
1937:                                          {
1938:                                              // Not enough memory for the descriptor!
1939:                                              USB_FREE_AND_CLEAR( pTemp );
005420  780008     MOV W8, W0
005422  07D7B2     RCALL 0x388
1940:              
1941:                                              // We cannot continue.  Freeze until the device is removed.
1942:                                              _USB_SetErrorCode( USB_HOLDING_OUT_OF_MEMORY );
005424  B3C331     MOV.B #0x33, W1
005426  209620     MOV #0x962, W0
005428  784801     MOV.B W1, [W0]
1943:                                              _USB_SetHoldState();
00542A  205000     MOV #0x500, W0
00542C  887D60     MOV W0, usbHostState
1944:                                              break;
00542E  3701B2     BRA .L232
1945:                                          }
1946:              
1947:                                          // Save wTotalLength
1948:                                          ((USB_CONFIGURATION_DESCRIPTOR *)((USB_CONFIGURATION *)pTemp)->descriptor)->wTotalLength =
005438  984021     MOV.B W1, [W0+2]
00543A  DE08C8     LSR W1, #8, W1
00543C  984031     MOV.B W1, [W0+3]
1949:                                                  ((uint16_t)pEP0Data[3] << 8) + (uint16_t)pEP0Data[2];
005430  FB811A     ZE [W10], W2
005432  DD1148     SL W2, #8, W2
005434  FB809B     ZE [W11], W1
005436  410081     ADD W2, W1, W1
1950:              
1951:                                          // Put the new node at the front of the list.
1952:                                          ((USB_CONFIGURATION *)pTemp)->next = usbDeviceInfo.pConfigurationDescriptorList;
00543E  209681     MOV #0x968, W1
005440  780111     MOV [W1], W2
005442  980412     MOV W2, [W8+2]
1953:                                          usbDeviceInfo.pConfigurationDescriptorList = (USB_CONFIGURATION *)pTemp;
005444  780888     MOV W8, [W1]
1954:              
1955:                                          // Save the configuration descriptor pointer and number
1956:                                          pCurrentConfigurationDescriptor            = ((USB_CONFIGURATION *)pTemp)->descriptor;
005446  887D20     MOV W0, pCurrentConfigurationDescriptor
1957:                                          ((USB_CONFIGURATION *)pTemp)->configNumber = countConfigurations;
005448  20FB94     MOV #0xFB9, W4
00544A  784214     MOV.B [W4], W4
00544C  984444     MOV.B W4, [W8+4]
1958:              
1959:                                          // Clean up and advance to the next state.
1960:                                          _USB_InitErrorCounters();
00544E  B3C030     MOV.B #0x3, W0
005450  B7EFB6     MOV.B WREG, numCommandTries
1961:                                          _USB_SetNextSubState();
005452  20FF00     MOV #0xFF0, W0
005454  B60FAC     AND usbHostState, WREG
005456  400070     ADD W0, #0x10, W0
005458  887D60     MOV W0, usbHostState
1962:                                          break;
00545A  37019C     BRA .L232
1963:              
1964:                                      default:
1965:                                          break;
1966:                                  }
1967:                                  break;
1968:              
1969:                              case SUBSTATE_GET_CONFIG_DESCRIPTOR:
1970:                                  // Get the entire Configuration Descriptor for this configuration
1971:                                  switch (usbHostState & SUBSUBSTATE_MASK)
00545C  807D60     MOV usbHostState, W0
00545E  60006F     AND W0, #0xF, W0
005460  500FE1     SUB W0, #0x1, [W15]
005462  320024     BRA Z, .L301
005464  390003     BRA NC, .L300
005466  500FE2     SUB W0, #0x2, [W15]
005468  3A0195     BRA NZ, .L232
00546A  37002B     BRA .L367
1972:                                  {
1973:                                      case SUBSUBSTATE_SEND_GET_CONFIG_DESCRIPTOR:
1974:              #if defined (DEBUG_ENABLE)
1975:                                          DEBUG_PutString( "HOST: Getting Config Descriptor.\r\n" );
1976:              #endif
1977:              
1978:                                          // Set up and send GET CONFIGURATION (n) DESCRIPTOR.
1979:                                          pEP0Data[0] = USB_SETUP_DEVICE_TO_HOST | USB_SETUP_TYPE_STANDARD | USB_SETUP_RECIPIENT_DEVICE;
00546C  807DA1     MOV pEP0Data, W1
00546E  B3C800     MOV.B #0x80, W0
005470  784880     MOV.B W0, [W1]
1980:                                          pEP0Data[1] = USB_REQUEST_GET_DESCRIPTOR;
005472  B3C060     MOV.B #0x6, W0
005474  984090     MOV.B W0, [W1+1]
1981:                                          pEP0Data[2] = countConfigurations-1;
005476  ED4FB9     DEC.B countConfigurations, WREG
005478  9840A0     MOV.B W0, [W1+2]
1982:                                          pEP0Data[3] = USB_DESCRIPTOR_CONFIGURATION;
00547A  B3C020     MOV.B #0x2, W0
00547C  9840B0     MOV.B W0, [W1+3]
1983:                                          pEP0Data[4] = 0;
00547E  EB4000     CLR.B W0
005480  9840C0     MOV.B W0, [W1+4]
1984:                                          pEP0Data[5] = 0;
005482  9840D0     MOV.B W0, [W1+5]
1985:                                          pEP0Data[6] = usbDeviceInfo.pConfigurationDescriptorList->descriptor[2];    // wTotalLength
005484  804B40     MOV 0x968, W0
005486  780010     MOV [W0], W0
005488  904020     MOV.B [W0+2], W0
00548A  9840E0     MOV.B W0, [W1+6]
1986:                                          pEP0Data[7] = usbDeviceInfo.pConfigurationDescriptorList->descriptor[3];
00548C  804B40     MOV 0x968, W0
00548E  780010     MOV [W0], W0
005490  904030     MOV.B [W0+3], W0
005492  9840F0     MOV.B W0, [W1+7]
1987:                                          _USB_InitControlRead( usbDeviceInfo.pEndpoint0, pEP0Data, 8, usbDeviceInfo.pConfigurationDescriptorList->descriptor,
005498  904023     MOV.B [W3+2], W0
00549A  FB8000     ZE W0, W0
00549C  904233     MOV.B [W3+3], W4
00549E  DD2248     SL W4, #8, W4
0054A0  700204     IOR W0, W4, W4
0054A2  200082     MOV #0x8, W2
0054A4  804B60     MOV 0x96C, W0
0054A6  07FA50     RCALL _USB_InitControlRead
1988:                                                  ((USB_CONFIGURATION_DESCRIPTOR *)usbDeviceInfo.pConfigurationDescriptorList->descriptor)->wTotalLength );
005494  804B40     MOV 0x968, W0
005496  780190     MOV [W0], W3
1989:                                          _USB_SetNextSubSubState();
0054A8  EC2FAC     INC usbHostState
1990:                                          break;
0054AA  370174     BRA .L232
1991:              
1992:                                      case SUBSUBSTATE_WAIT_FOR_GET_CONFIG_DESCRIPTOR:
1993:                                          if (usbDeviceInfo.pEndpoint0->status.bfTransferComplete)
0054AC  804B60     MOV 0x96C, W0
0054AE  900090     MOV [W0+2], W1
0054B0  A39801     BTST.Z W1, #9
0054B2  320170     BRA Z, .L232
1994:                                          {
1995:                                              if (usbDeviceInfo.pEndpoint0->status.bfTransferSuccessful)
0054B4  900010     MOV [W0+2], W0
0054B6  A38800     BTST.Z W0, #8
0054B8  320002     BRA Z, .L303
1996:                                              {
1997:                                                  _USB_SetNextSubSubState();
0054BA  EC2FAC     INC usbHostState
0054BC  37016B     BRA .L232
1998:                                              }
1999:                                              else
2000:                                              {
2001:                                                  // We are here because of either a STALL or a NAK.  See if
2002:                                                  // we have retries left to try the command again or try to
2003:                                                  // enumerate again.
2004:                                                  _USB_CheckCommandAndEnumerationAttempts();
0054BE  07F827     RCALL _USB_CheckCommandAndEnumerationAttempts
0054C0  370169     BRA .L232
2005:                                              }
2006:                                          }
2007:                                          break;
2008:              
2009:                                      case SUBSUBSTATE_GET_CONFIG_DESCRIPTOR_COMPLETE:
2010:                                          // Clean up and advance to the next state.  Keep the data for later use.
2011:                                          _USB_InitErrorCounters();
0054C2  B3C030     MOV.B #0x3, W0
0054C4  B7EFB6     MOV.B WREG, numCommandTries
2012:                                          countConfigurations --;
0054C6  ED4FB9     DEC.B countConfigurations, WREG
0054C8  B7EFB9     MOV.B WREG, countConfigurations
2013:                                          if (countConfigurations)
0054CA  320003     BRA Z, .L304
2014:                                          {
2015:                                              // There are more descriptors that we need to get.
2016:                                              usbHostState = STATE_CONFIGURING | SUBSTATE_GET_CONFIG_DESCRIPTOR_SIZE;
0054CC  203100     MOV #0x310, W0
0054CE  887D60     MOV W0, usbHostState
0054D0  370161     BRA .L232
2017:                                          }
2018:                                          else
2019:                                          {
2020:                                              // Start configuring the device.
2021:                                              _USB_SetNextSubState();
0054D2  20FF00     MOV #0xFF0, W0
0054D4  B60FAC     AND usbHostState, WREG
0054D6  400070     ADD W0, #0x10, W0
0054D8  887D60     MOV W0, usbHostState
0054DA  37015C     BRA .L232
2022:                                            }
2023:                                          break;
2024:              
2025:                                      default:
2026:                                          break;
2027:                                  }
2028:                                  break;
2029:              
2030:                              case SUBSTATE_SELECT_CONFIGURATION:
2031:                                  // Set the OTG configuration of the device
2032:                                  switch (usbHostState & SUBSUBSTATE_MASK)
0054DC  807D60     MOV usbHostState, W0
0054DE  60006F     AND W0, #0xF, W0
0054E0  500FE1     SUB W0, #0x1, [W15]
0054E2  320041     BRA Z, .L306
0054E4  390005     BRA NC, .L305
0054E6  500FE2     SUB W0, #0x2, [W15]
0054E8  320060     BRA Z, .L307
0054EA  500FE3     SUB W0, #0x3, [W15]
0054EC  3A0153     BRA NZ, .L232
0054EE  370068     BRA .L368
2033:                                  {
2034:                                      case SUBSUBSTATE_SELECT_CONFIGURATION:
2035:                                          // Free the old configuration (if any)
2036:                                          _USB_FreeConfigMemory();
0054F0  07F9B7     RCALL _USB_FreeConfigMemory
2037:              
2038:                                          // If the configuration wasn't selected based on the VID & PID
2039:                                          if (usbDeviceInfo.currentConfiguration == 0)
0054F2  2095E0     MOV #0x95E, W0
0054F4  784090     MOV.B [W0], W1
0054F6  E00401     CP0.B W1
0054F8  3A0010     BRA NZ, .L309
2040:                                          {
2041:                                              // Search for a supported class-specific configuration.
2042:                                              pCurrentConfigurationNode = usbDeviceInfo.pConfigurationDescriptorList;
0054FA  804B40     MOV 0x968, W0
0054FC  887DD0     MOV W0, pCurrentConfigurationNode
2043:                                              while (pCurrentConfigurationNode)
0054FE  E00000     CP0 W0
005500  320023     BRA Z, .L310
005514  E00000     CP0 W0
005516  3AFFF5     BRA NZ, .L347
005518  370017     BRA .L310
2044:                                              {
2045:                                                  pCurrentConfigurationDescriptor = pCurrentConfigurationNode->descriptor;
005502  780010     MOV [W0], W0
005504  887D20     MOV W0, pCurrentConfigurationDescriptor
2046:                                                  if (_USB_ParseConfigurationDescriptor())
005506  07FBBD     RCALL _USB_ParseConfigurationDescriptor
005508  E00400     CP0.B W0
00550A  3A001E     BRA NZ, .L310
2047:                                                  {
2048:                                                      break;
2049:                                                  }
2050:                                                  else
2051:                                                  {
2052:                                                      // Free the memory allocated and
2053:                                                      // advance to  next configuration
2054:                                                      _USB_FreeConfigMemory();
00550C  07F9A9     RCALL _USB_FreeConfigMemory
2055:                                                      pCurrentConfigurationNode = pCurrentConfigurationNode->next;
00550E  807DD0     MOV pCurrentConfigurationNode, W0
005510  900010     MOV [W0+2], W0
005512  887DD0     MOV W0, pCurrentConfigurationNode
2056:                                                  }
2057:                                              }
2058:                                          }
2059:                                          else
2060:                                          {
2061:                                              // Configuration selected by VID & PID, initialize data structures
2062:                                              pCurrentConfigurationNode = usbDeviceInfo.pConfigurationDescriptorList;
00551A  804B40     MOV 0x968, W0
00551C  887DD0     MOV W0, pCurrentConfigurationNode
2063:                                              while (pCurrentConfigurationNode && pCurrentConfigurationNode->configNumber != usbDeviceInfo.currentConfiguration)
00551E  E00000     CP0 W0
005520  32000C     BRA Z, .L312
005522  904140     MOV.B [W0+4], W2
005524  50CF82     SUB.B W1, W2, [W15]
005526  320009     BRA Z, .L312
00552A  E00000     CP0 W0
00552C  3A0002     BRA NZ, .L313
00552E  887DD0     MOV W0, pCurrentConfigurationNode
005530  370004     BRA .L312
005532  904140     MOV.B [W0+4], W2
005534  50CF82     SUB.B W1, W2, [W15]
005536  3AFFF8     BRA NZ, .L348
005538  887DD0     MOV W0, pCurrentConfigurationNode
2064:                                              {
2065:                                                  pCurrentConfigurationNode = pCurrentConfigurationNode->next;
005528  900010     MOV [W0+2], W0
2066:                                              }
2067:                                              pCurrentConfigurationDescriptor = pCurrentConfigurationNode->descriptor;
00553A  780010     MOV [W0], W0
00553C  887D20     MOV W0, pCurrentConfigurationDescriptor
2068:                                              if (!_USB_ParseConfigurationDescriptor())
00553E  07FBA1     RCALL _USB_ParseConfigurationDescriptor
005540  E00400     CP0.B W0
005542  3A0002     BRA NZ, .L310
2069:                                              {
2070:                                                  // Free the memory allocated, config attempt failed.
2071:                                                  _USB_FreeConfigMemory();
005544  07F98D     RCALL _USB_FreeConfigMemory
2072:                                                  pCurrentConfigurationNode = NULL;
005546  EF2FBA     CLR pCurrentConfigurationNode
2073:                                              }
2074:                                          }
2075:              
2076:                                          //If No OTG Then
2077:                                          if (usbDeviceInfo.flags.bfConfiguredOTG)
005548  804B70     MOV 0x96E, W0
00554A  A32800     BTST.Z W0, #2
00554C  32000A     BRA Z, .L315
2078:                                          {
2079:                                              // Did we fail to configure?
2080:                                              if (pCurrentConfigurationNode == NULL)
00554E  E20FBA     CP0 pCurrentConfigurationNode
005550  3A0006     BRA NZ, .L316
2081:                                              {
2082:                                                  // Failed to find a supported configuration.
2083:                                                  _USB_SetErrorCode( USB_HOLDING_UNSUPPORTED_DEVICE );
005552  B3C341     MOV.B #0x34, W1
005554  209620     MOV #0x962, W0
005556  784801     MOV.B W1, [W0]
2084:                                                  _USB_SetHoldState();
005558  205000     MOV #0x500, W0
00555A  887D60     MOV W0, usbHostState
00555C  37011B     BRA .L232
2085:                                              }
2086:                                              else
2087:                                              {
2088:                                                  _USB_SetNextSubSubState();
00555E  EC2FAC     INC usbHostState
005560  370119     BRA .L232
2089:                                              }
2090:                                          }
2091:                                          else
2092:                                          {
2093:                                              _USB_SetNextSubSubState();
005562  EC2FAC     INC usbHostState
005564  370117     BRA .L232
2094:                                          }
2095:                                          break;
2096:              
2097:                                      case SUBSUBSTATE_SEND_SET_OTG:
2098:              #if defined (DEBUG_ENABLE)
2099:                                          DEBUG_PutString( "HOST: Determine OTG capability.\r\n" );
2100:              #endif
2101:              
2102:                                          // If the device does not support OTG, or
2103:                                          // if the device has already been configured, bail.
2104:                                          // Otherwise, send SET FEATURE to configure it.
2105:                                          if (!usbDeviceInfo.flags.bfConfiguredOTG)
005566  804B70     MOV 0x96E, W0
005568  A32800     BTST.Z W0, #2
00556A  3A001A     BRA NZ, .L317
2106:                                          {
2107:              #if defined (DEBUG_ENABLE)
2108:                                              DEBUG_PutString( "HOST: ...OTG needs configuring.\r\n" );
2109:              #endif
2110:              
2111:                                              usbDeviceInfo.flags.bfConfiguredOTG = 1;
00556C  2096E0     MOV #0x96E, W0
00556E  A02010     BSET [W0], #2
2112:              
2113:                                              // Send SET FEATURE
2114:                                              pEP0Data[0] = USB_SETUP_HOST_TO_DEVICE | USB_SETUP_TYPE_STANDARD | USB_SETUP_RECIPIENT_DEVICE;
005570  807DA1     MOV pEP0Data, W1
005572  EB4880     CLR.B [W1]
2115:                                              pEP0Data[1] = USB_REQUEST_SET_FEATURE;
005574  B3C032     MOV.B #0x3, W2
005576  984092     MOV.B W2, [W1+1]
2116:                                              if (usbDeviceInfo.flags.bfAllowHNP) // Needs to be set by the user
005578  A33810     BTST.Z [W0], #3
00557A  320003     BRA Z, .L318
2117:                                              {
2118:                                                  pEP0Data[2] = OTG_FEATURE_B_HNP_ENABLE;
00557C  784002     MOV.B W2, W0
00557E  9840A0     MOV.B W0, [W1+2]
005580  370002     BRA .L319
2119:                                              }
2120:                                              else
2121:                                              {
2122:                                                  pEP0Data[2] = OTG_FEATURE_A_HNP_SUPPORT;
005582  B3C040     MOV.B #0x4, W0
005584  9840A0     MOV.B W0, [W1+2]
2123:                                              }
2124:                                              pEP0Data[3] = 0;
005586  EB4000     CLR.B W0
005588  9840B0     MOV.B W0, [W1+3]
2125:                                              pEP0Data[4] = 0;
00558A  9840C0     MOV.B W0, [W1+4]
2126:                                              pEP0Data[5] = 0;
00558C  9840D0     MOV.B W0, [W1+5]
2127:                                              pEP0Data[6] = 0;
00558E  9840E0     MOV.B W0, [W1+6]
2128:                                              pEP0Data[7] = 0;
005590  9840F0     MOV.B W0, [W1+7]
2129:                                              _USB_InitControlWrite( usbDeviceInfo.pEndpoint0, pEP0Data, 8, NULL, 0 );
005592  EB0200     CLR W4
005594  EB0180     CLR W3
005596  200082     MOV #0x8, W2
005598  804B60     MOV 0x96C, W0
00559A  07F9FA     RCALL _USB_InitControlWrite
2130:                                              _USB_SetNextSubSubState();
00559C  EC2FAC     INC usbHostState
00559E  3700FA     BRA .L232
2131:                                          }
2132:                                          else
2133:                                          {
2134:              #if defined (DEBUG_ENABLE)
2135:                                              DEBUG_PutString( "HOST: ...No OTG.\r\n" );
2136:              #endif
2137:              
2138:                                              _USB_SetNextSubState();
0055A0  20FF00     MOV #0xFF0, W0
0055A2  B60FAC     AND usbHostState, WREG
0055A4  400070     ADD W0, #0x10, W0
0055A6  887D60     MOV W0, usbHostState
0055A8  3700F5     BRA .L232
2139:                                          }
2140:                                          break;
2141:              
2142:                                      case SUBSUBSTATE_WAIT_FOR_SET_OTG_DONE:
2143:                                          if (usbDeviceInfo.pEndpoint0->status.bfTransferComplete)
0055AA  804B60     MOV 0x96C, W0
0055AC  900090     MOV [W0+2], W1
0055AE  A39801     BTST.Z W1, #9
0055B0  3200F1     BRA Z, .L232
2144:                                          {
2145:                                              if (usbDeviceInfo.pEndpoint0->status.bfTransferSuccessful)
0055B2  900010     MOV [W0+2], W0
0055B4  A38800     BTST.Z W0, #8
0055B6  320002     BRA Z, .L320
2146:                                              {
2147:                                                  #ifdef  USB_SUPPORT_OTG
2148:                                                      if (usbDeviceInfo.flags.bfAllowHNP)
2149:                                                      {
2150:                                                          USBOTGEnableHnp();
2151:                                                      }
2152:                                                   #endif
2153:                                                  _USB_SetNextSubSubState();
0055B8  EC2FAC     INC usbHostState
0055BA  3700EC     BRA .L232
2154:                                              }
2155:                                              else
2156:                                              {
2157:                                                  #ifdef  USB_SUPPORT_OTG
2158:                                                      USBOTGDisableHnp();
2159:                                                  #endif
2160:                                                  // We are here because of either a STALL or a NAK.  See if
2161:                                                  // we have retries left to try the command again or try to
2162:                                                  // enumerate again.
2163:                                                  _USB_CheckCommandAndEnumerationAttempts();
0055BC  07F7A8     RCALL _USB_CheckCommandAndEnumerationAttempts
0055BE  3700EA     BRA .L232
2164:              
2165:                                                  #if defined(USB_SUPPORT_OTG)
2166:              #if defined (DEBUG_ENABLE)
2167:                                                      DEBUG_PutString( "\r\n***** USB OTG Error - Set Feature B_HNP_ENABLE Stalled - Device Not Responding *****\r\n" );
2168:              #endif
2169:                                                  #endif
2170:              
2171:                                              }
2172:                                          }
2173:                                          break;
2174:              
2175:                                      case SUBSUBSTATE_SET_OTG_COMPLETE:
2176:                                           // Clean up and advance to the next state.
2177:                                         _USB_InitErrorCounters();
0055C0  B3C030     MOV.B #0x3, W0
0055C2  B7EFB6     MOV.B WREG, numCommandTries
2178:              
2179:                                          //MR - Moved For OTG Set Feature Support For Unsupported Devices
2180:                                          // Did we fail to configure?
2181:                                          if (pCurrentConfigurationNode == NULL)
0055C4  E20FBA     CP0 pCurrentConfigurationNode
0055C6  3A0006     BRA NZ, .L321
2182:                                          {
2183:                                              // Failed to find a supported configuration.
2184:                                              _USB_SetErrorCode( USB_HOLDING_UNSUPPORTED_DEVICE );
0055C8  B3C341     MOV.B #0x34, W1
0055CA  209620     MOV #0x962, W0
0055CC  784801     MOV.B W1, [W0]
2185:                                              _USB_SetHoldState();
0055CE  205000     MOV #0x500, W0
0055D0  887D60     MOV W0, usbHostState
0055D2  3700E0     BRA .L232
2186:                                          }
2187:                                          else
2188:                                          {
2189:                                              //_USB_SetNextSubSubState();
2190:                                              _USB_InitErrorCounters();
2191:                                              _USB_SetNextSubState();
0055D4  20FF00     MOV #0xFF0, W0
0055D6  B60FAC     AND usbHostState, WREG
0055D8  400070     ADD W0, #0x10, W0
0055DA  887D60     MOV W0, usbHostState
0055DC  3700DB     BRA .L232
2192:                                          }
2193:                                          break;
2194:              
2195:                                      default:
2196:                                          break;
2197:                                  }
2198:                                  break;
2199:              
2200:                              case SUBSTATE_APPLICATION_CONFIGURATION:
2201:                                  if ( USB_HOST_APP_EVENT_HANDLER( USB_ROOT_HUB, EVENT_HOLD_BEFORE_CONFIGURATION,
0055DE  209610     MOV #0x961, W0
0055E0  FB8210     ZE [W0], W4
0055E2  EB0280     CLR W5
0055E4  EB0100     CLR W2
0055E6  2007C1     MOV #0x7C, W1
0055E8  EBC000     SETM.B W0
0055EA  072A64     RCALL USB_Host_ApplicationEventHandler
0055EC  E00400     CP0.B W0
0055EE  3A00D2     BRA NZ, .L232
2202:                                          NULL, usbDeviceInfo.deviceAddress ) == false )
2203:                                  {
2204:                                      _USB_SetNextSubState();
0055F0  20FF00     MOV #0xFF0, W0
0055F2  B60FAC     AND usbHostState, WREG
0055F4  400070     ADD W0, #0x10, W0
0055F6  887D60     MOV W0, usbHostState
0055F8  3700CD     BRA .L232
2205:                                  }
2206:                                  break;
2207:              
2208:                              case SUBSTATE_SET_CONFIGURATION:
2209:                                  // Set the configuration to the one specified for this device
2210:                                  switch (usbHostState & SUBSUBSTATE_MASK)
0055FA  807D60     MOV usbHostState, W0
0055FC  60006F     AND W0, #0xF, W0
0055FE  500FE1     SUB W0, #0x1, [W15]
005600  32001A     BRA Z, .L323
005602  390005     BRA NC, .L322
005604  500FE2     SUB W0, #0x2, [W15]
005606  320022     BRA Z, .L324
005608  500FE3     SUB W0, #0x3, [W15]
00560A  3A00C4     BRA NZ, .L232
00560C  370023     BRA .L369
2211:                                  {
2212:                                      case SUBSUBSTATE_SEND_SET_CONFIGURATION:
2213:              #if defined (DEBUG_ENABLE)
2214:                                          DEBUG_PutString( "HOST: Set configuration.\r\n" );
2215:              #endif
2216:              
2217:                                          // Set up and send SET CONFIGURATION.
2218:                                          pEP0Data[0] = USB_SETUP_HOST_TO_DEVICE | USB_SETUP_TYPE_STANDARD | USB_SETUP_RECIPIENT_DEVICE;
00560E  807DA1     MOV pEP0Data, W1
005610  EB4000     CLR.B W0
005612  784880     MOV.B W0, [W1]
2219:                                          pEP0Data[1] = USB_REQUEST_SET_CONFIGURATION;
005614  B3C092     MOV.B #0x9, W2
005616  984092     MOV.B W2, [W1+1]
2220:                                          pEP0Data[2] = usbDeviceInfo.currentConfiguration;
005618  2095E2     MOV #0x95E, W2
00561A  784112     MOV.B [W2], W2
00561C  9840A2     MOV.B W2, [W1+2]
2221:                                          pEP0Data[3] = 0;
00561E  9840B0     MOV.B W0, [W1+3]
2222:                                          pEP0Data[4] = 0;
005620  9840C0     MOV.B W0, [W1+4]
2223:                                          pEP0Data[5] = 0;
005622  9840D0     MOV.B W0, [W1+5]
2224:                                          pEP0Data[6] = 0;
005624  9840E0     MOV.B W0, [W1+6]
2225:                                          pEP0Data[7] = 0;
005626  9840F0     MOV.B W0, [W1+7]
2226:                                          _USB_InitControlWrite( usbDeviceInfo.pEndpoint0, pEP0Data, 8, NULL, 0 );
005628  EB0200     CLR W4
00562A  EB0180     CLR W3
00562C  200082     MOV #0x8, W2
00562E  804B60     MOV 0x96C, W0
005630  07F9AF     RCALL _USB_InitControlWrite
2227:                                          _USB_SetNextSubSubState();
005632  EC2FAC     INC usbHostState
2228:                                          break;
005634  3700AF     BRA .L232
2229:              
2230:                                      case SUBSUBSTATE_WAIT_FOR_SET_CONFIGURATION:
2231:                                          if (usbDeviceInfo.pEndpoint0->status.bfTransferComplete)
005636  804B60     MOV 0x96C, W0
005638  900090     MOV [W0+2], W1
00563A  A39801     BTST.Z W1, #9
00563C  3200AB     BRA Z, .L232
2232:                                          {
2233:                                              if (usbDeviceInfo.pEndpoint0->status.bfTransferSuccessful)
00563E  900010     MOV [W0+2], W0
005640  A38800     BTST.Z W0, #8
005642  320002     BRA Z, .L326
2234:                                              {
2235:                                                  _USB_SetNextSubSubState();
005644  EC2FAC     INC usbHostState
005646  3700A6     BRA .L232
2236:                                              }
2237:                                              else
2238:                                              {
2239:                                                  // We are here because of either a STALL or a NAK.  See if
2240:                                                  // we have retries left to try the command again or try to
2241:                                                  // enumerate again.
2242:                                                  _USB_CheckCommandAndEnumerationAttempts();
005648  07F762     RCALL _USB_CheckCommandAndEnumerationAttempts
00564A  3700A4     BRA .L232
2243:                                              }
2244:                                          }
2245:                                          break;
2246:              
2247:                                      case SUBSUBSTATE_SET_CONFIGURATION_COMPLETE:
2248:                                          // Clean up and advance to the next state.
2249:                                          _USB_InitErrorCounters();
00564C  B3C030     MOV.B #0x3, W0
00564E  B7EFB6     MOV.B WREG, numCommandTries
2250:                                          _USB_SetNextSubSubState();
005650  EC2FAC     INC usbHostState
2251:                                          break;
005652  3700A0     BRA .L232
2252:              
2253:                                      case SUBSUBSTATE_INIT_CLIENT_DRIVERS:
2254:              #if defined (DEBUG_ENABLE)
2255:                                          DEBUG_PutString( "HOST: Initializing client drivers...\r\n" );
2256:              #endif
2257:              
2258:                                          _USB_SetNextState();
005654  20F000     MOV #0xF00, W0
005656  B60FAC     AND usbHostState, WREG
005658  B01000     ADD #0x100, W0
00565A  887D60     MOV W0, usbHostState
2259:                                          // Initialize client driver(s) for this configuration.
2260:                                          if (usbDeviceInfo.flags.bfUseDeviceClientDriver)
00565C  804B70     MOV 0x96E, W0
00565E  A36800     BTST.Z W0, #6
005660  320015     BRA Z, .L327
2261:                                          {
2262:                                              // We have a device that requires only one client driver.  Make sure
2263:                                              // that client driver can initialize this device.  If the client
2264:                                              // driver initialization fails, we cannot enumerate this device.
2265:              #if defined (DEBUG_ENABLE)
2266:                                              DEBUG_PutString( "HOST: Using device client driver.\r\n" );
2267:              #endif
2268:              
2269:                                              temp = usbDeviceInfo.deviceClientDriver;
005662  209630     MOV #0x963, W0
005664  784090     MOV.B [W0], W1
2270:                                              if (!usbClientDrvTable[temp].Initialize(usbDeviceInfo.deviceAddress, usbClientDrvTable[temp].flags, temp))
005666  784001     MOV.B W1, W0
005668  B3C0A2     MOV.B #0xA, W2
00566A  BC4004     MUL.B WREG2
00566C  209A63     MOV #0x9A6, W3
00566E  418002     ADD W3, W2, W0
005670  790263     MOV [W3+W2], W4
005672  900130     MOV [W0+6], W2
005674  9001C0     MOV [W0+8], W3
005676  209610     MOV #0x961, W0
005678  784010     MOV.B [W0], W0
00567A  010004     CALL W4
00567C  E00400     CP0.B W0
00567E  3A001F     BRA NZ, .L328
2271:                                              {
2272:                                                  _USB_SetErrorCode( USB_HOLDING_CLIENT_INIT_ERROR );
005680  B3C391     MOV.B #0x39, W1
005682  209620     MOV #0x962, W0
005684  784801     MOV.B W1, [W0]
2273:                                                  _USB_SetHoldState();
005686  205000     MOV #0x500, W0
005688  887D60     MOV W0, usbHostState
00568A  370019     BRA .L328
2274:                                              }
2275:                                          }
2276:                                          else
2277:                                          {
2278:                                              // We have a device that requires multiple client drivers.  Make sure
2279:                                              // every required client driver can initialize this device.  If any
2280:                                              // client driver initialization fails, we cannot enumerate the device.
2281:              #if defined (DEBUG_ENABLE)
2282:                                              DEBUG_PutString( "HOST: Scanning interfaces.\r\n" );
2283:              #endif
2284:              
2285:                                              pCurrentInterface = usbDeviceInfo.pInterfaceList;
00568C  804B58     MOV 0x96A, W8
2286:                                              while (pCurrentInterface)
00568E  E00008     CP0 W8
005690  320016     BRA Z, .L328
0056BA  E00008     CP0 W8
0056BC  3AFFEF     BRA NZ, .L346
2287:                                              {
2288:                                                  temp = pCurrentInterface->clientDriver;
00569C  9040F8     MOV.B [W8+7], W1
2289:                                                  if (!usbClientDrvTable[temp].Initialize(usbDeviceInfo.deviceAddress, usbClientDrvTable[temp].flags, temp))
005692  209A69     MOV #0x9A6, W9
005694  20961A     MOV #0x961, W10
00569E  784001     MOV.B W1, W0
0056A0  B3C0A2     MOV.B #0xA, W2
0056A2  BC4004     MUL.B WREG2
0056A4  448002     ADD W9, W2, W0
0056A6  790269     MOV [W9+W2], W4
0056A8  900130     MOV [W0+6], W2
0056AA  9001C0     MOV [W0+8], W3
0056AC  78401A     MOV.B [W10], W0
0056AE  010004     CALL W4
0056B0  E00400     CP0.B W0
0056B2  3A0002     BRA NZ, .L329
2290:                                                  {
2291:                                                      _USB_SetErrorCode( USB_HOLDING_CLIENT_INIT_ERROR );
005696  E8058A     INC W10, W11
005698  B3C39C     MOV.B #0x39, W12
0056B4  784D8C     MOV.B W12, [W11]
2292:                                                      _USB_SetHoldState();
00569A  20500D     MOV #0x500, W13
0056B6  887D6D     MOV W13, usbHostState
2293:                                                  }
2294:                                                  pCurrentInterface = pCurrentInterface->next;
0056B8  780418     MOV [W8], W8
2295:                                              }
2296:                                          }
2297:              
2298:                                          //Load the EP0 driver, if there was any
2299:                                          if(usbDeviceInfo.flags.bfUseEP0Driver == 1)
0056BE  804B70     MOV 0x96E, W0
0056C0  A37800     BTST.Z W0, #7
0056C2  320068     BRA Z, .L232
2300:                                          {
2301:                                              temp = usbDeviceInfo.deviceEP0Driver;
0056C4  209640     MOV #0x964, W0
0056C6  784090     MOV.B [W0], W1
2302:                                              if (!usbClientDrvTable[temp].Initialize(usbDeviceInfo.deviceAddress, usbClientDrvTable[temp].flags, temp))
0056C8  784001     MOV.B W1, W0
0056CA  B3C0A2     MOV.B #0xA, W2
0056CC  BC4004     MUL.B WREG2
0056CE  209A63     MOV #0x9A6, W3
0056D0  418002     ADD W3, W2, W0
0056D2  790263     MOV [W3+W2], W4
0056D4  900130     MOV [W0+6], W2
0056D6  9001C0     MOV [W0+8], W3
0056D8  209610     MOV #0x961, W0
0056DA  784010     MOV.B [W0], W0
0056DC  010004     CALL W4
0056DE  E00400     CP0.B W0
0056E0  3A0059     BRA NZ, .L232
2303:                                              {
2304:                                                  _USB_SetErrorCode( USB_HOLDING_CLIENT_INIT_ERROR );
0056E2  B3C391     MOV.B #0x39, W1
0056E4  209620     MOV #0x962, W0
0056E6  784801     MOV.B W1, [W0]
2305:                                                  _USB_SetHoldState();
0056E8  205000     MOV #0x500, W0
0056EA  887D60     MOV W0, usbHostState
0056EC  370053     BRA .L232
2306:                                              }
2307:                                          }
2308:              
2309:                                          break;
2310:              
2311:                                      default:
2312:                                          break;
2313:                                  }
2314:                                  break;
2315:                          }
2316:                          break;
2317:              
2318:                      case STATE_RUNNING:
2319:                          switch (usbHostState & SUBSTATE_MASK)
0056EE  200F00     MOV #0xF0, W0
0056F0  B60FAC     AND usbHostState, WREG
0056F2  500FF0     SUB W0, #0x10, [W15]
0056F4  3A004F     BRA NZ, .L232
2320:                          {
2321:                              case SUBSTATE_NORMAL_RUN:
2322:                                  break;
2323:              
2324:                              case SUBSTATE_SUSPEND_AND_RESUME:
2325:                                  switch (usbHostState & SUBSUBSTATE_MASK)
0056F6  807D60     MOV usbHostState, W0
0056F8  60006F     AND W0, #0xF, W0
0056FA  500FE3     SUB W0, #0x3, [W15]
0056FC  32000C     BRA Z, .L333
0056FE  500FE5     SUB W0, #0x5, [W15]
005700  320013     BRA Z, .L334
005702  500FE1     SUB W0, #0x1, [W15]
005704  3A0047     BRA NZ, .L232
2326:                                  {
2327:                                      case SUBSUBSTATE_SUSPEND:
2328:                                          // The IDLE state has already been set.  We need to wait here
2329:                                          // until the application decides to RESUME.
2330:                                          break;
2331:              
2332:                                      case SUBSUBSTATE_RESUME:
2333:                                          // Issue a RESUME.
2334:                                          U1CONbits.RESUME = 1;
005706  A84494     BSET U1CON, #2
2335:              
2336:                                          // Wait for the RESUME time.
2337:                                          numTimerInterrupts      = USB_RESUME_TIME;
005708  200150     MOV #0x15, W0
00570A  887D50     MOV W0, numTimerInterrupts
2338:                                          U1OTGIR                 = USB_INTERRUPT_T1MSECIF; // The interrupt is cleared by writing a '1' to the flag.
00570C  200400     MOV #0x40, W0
00570E  882400     MOV W0, U1OTGIR
2339:                                          U1OTGIEbits.T1MSECIE    = 1;
005710  A8C482     BSET U1OTGIE, #6
2340:              
2341:                                          _USB_SetNextSubSubState();
005712  EC2FAC     INC usbHostState
2342:                                          break;
005714  37003F     BRA .L232
2343:              
2344:                                      case SUBSUBSTATE_RESUME_WAIT:
2345:                                          // Wait here until the timer expires.
2346:                                          break;
2347:              
2348:                                      case SUBSUBSTATE_RESUME_RECOVERY:
2349:                                          // Turn off RESUME.
2350:                                          U1CONbits.RESUME        = 0;
005716  A94494     BCLR U1CON, #2
2351:              
2352:                                          // Start sending SOF's, so the device doesn't go back into the SUSPEND state.
2353:                                          U1CONbits.SOFEN         = 1;
005718  A80494     BSET U1CON, #0
2354:              
2355:                                          // Wait for the RESUME recovery time.
2356:                                          numTimerInterrupts      = USB_RESUME_RECOVERY_TIME;
00571A  2000B0     MOV #0xB, W0
00571C  887D50     MOV W0, numTimerInterrupts
2357:                                          U1OTGIR                 = USB_INTERRUPT_T1MSECIF; // The interrupt is cleared by writing a '1' to the flag.
00571E  200400     MOV #0x40, W0
005720  882400     MOV W0, U1OTGIR
2358:                                          U1OTGIEbits.T1MSECIE    = 1;
005722  A8C482     BSET U1OTGIE, #6
2359:              
2360:                                          _USB_SetNextSubSubState();
005724  EC2FAC     INC usbHostState
2361:                                          break;
005726  370036     BRA .L232
2362:              
2363:                                      case SUBSUBSTATE_RESUME_RECOVERY_WAIT:
2364:                                          // Wait here until the timer expires.
2365:                                          break;
2366:              
2367:                                      case SUBSUBSTATE_RESUME_COMPLETE:
2368:                                          // Go back to normal running.
2369:                                          usbHostState = STATE_RUNNING | SUBSTATE_NORMAL_RUN;
005728  204000     MOV #0x400, W0
00572A  887D60     MOV W0, usbHostState
2370:                                          break;
00572C  370033     BRA .L232
2371:                                  }
2372:                          }
2373:                          break;
2374:              
2375:                      case STATE_HOLDING:
2376:                          switch (usbHostState & SUBSTATE_MASK)
00572E  200F00     MOV #0xF0, W0
005730  B60FAC     AND usbHostState, WREG
005732  3A0030     BRA NZ, .L232
2377:                          {
2378:                              case SUBSTATE_HOLD_INIT:
2379:                                  // We're here because we cannot communicate with the current device
2380:                                  // that is plugged in.  Turn off SOF's and all interrupts except
2381:                                  // the DETACH interrupt.
2382:              #if defined (DEBUG_ENABLE)
2383:                                  DEBUG_PutString( "HOST: Holding.\r\n" );
2384:              #endif
2385:              
2386:                                  U1CON               = USB_HOST_MODE_ENABLE | USB_SOF_DISABLE;                       // Turn of SOF's to cut down noise
005734  200080     MOV #0x8, W0
005736  8824A0     MOV W0, U1CON
2387:                                  U1IE                = 0;
005738  EF248C     CLR U1IE
2388:                                  U1IR                = 0xFF;
00573A  200FF0     MOV #0xFF, W0
00573C  882450     MOV W0, U1IR
2389:                                  U1OTGIE             &= 0x8C;
00573E  2008C1     MOV #0x8C, W1
005740  204822     MOV #0x482, W2
005742  608912     AND W1, [W2], [W2]
2390:                                  U1OTGIR             = 0x7D;
005744  5080EF     SUB W1, #0xF, W1
005746  882401     MOV W1, U1OTGIR
2391:                                  U1EIE               = 0;
005748  EF2490     CLR U1EIE
2392:                                  U1EIR               = 0xFF;
00574A  882470     MOV W0, U1EIR
2393:                                  U1IEbits.DETACHIE   = 1;
00574C  A8048C     BSET U1IE, #0
2394:              
2395:                                  #if defined(USB_ENABLE_1MS_EVENT)
2396:                                      U1OTGIR                 = USB_INTERRUPT_T1MSECIF; // The interrupt is cleared by writing a '1' to the flag.
2397:                                      U1OTGIEbits.T1MSECIE    = 1;
2398:                                  #endif
2399:              
2400:                                  switch (usbDeviceInfo.errorCode )
00574E  209620     MOV #0x962, W0
005750  784010     MOV.B [W0], W0
005754  B3C342     MOV.B #0x34, W2
005756  504F82     SUB.B W0, W2, [W15]
005758  320012     BRA Z, .L339
00575A  3E0008     BRA GTU, .L342
00575E  504FE7     SUB.B W0, #0x7, [W15]
005760  32000E     BRA Z, .L339
005764  E94102     DEC.B W2, W2
005766  504F82     SUB.B W0, W2, [W15]
005768  3A0009     BRA NZ, .L336
00576A  370009     BRA .L339
00576E  B3C352     MOV.B #0x35, W2
005770  504F82     SUB.B W0, W2, [W15]
005772  320005     BRA Z, .L339
005776  414164     ADD.B W2, #0x4, W2
005778  504F82     SUB.B W0, W2, [W15]
00577A  320001     BRA Z, .L339
2401:                                  {
2402:                                      case USB_HOLDING_UNSUPPORTED_HUB:
2403:                                          temp = EVENT_HUB_ATTACH;
00576C  B3C651     MOV.B #0x65, W1
2404:                                          break;
2405:              
2406:                                      case USB_HOLDING_UNSUPPORTED_DEVICE:
2407:                                          temp = EVENT_UNSUPPORTED_DEVICE;
005752  50C0F1     SUB.B W1, #0x11, W1
2408:              
2409:                                          #ifdef  USB_SUPPORT_OTG
2410:                                          //Abort HNP
2411:                                          USB_OTGEventHandler (0, OTG_EVENT_HNP_ABORT , 0, 0 );
2412:                                          #endif
2413:              
2414:                                          break;
2415:              
2416:                                      case USB_CANNOT_ENUMERATE:
2417:                                          temp = EVENT_CANNOT_ENUMERATE;
00575C  B3C6D1     MOV.B #0x6D, W1
2418:                                          break;
2419:              
2420:                                      case USB_HOLDING_CLIENT_INIT_ERROR:
2421:                                          temp = EVENT_CLIENT_INIT_ERROR;
005774  40C0E9     ADD.B W1, #0x9, W1
2422:                                          break;
2423:              
2424:                                      case USB_HOLDING_OUT_OF_MEMORY:
2425:                                          temp = EVENT_OUT_OF_MEMORY;
005762  E8C081     INC2.B W1, W1
2426:                                          break;
2427:              
2428:                                      default:
2429:                                          temp = EVENT_UNSPECIFIED_ERROR; // This should never occur
00577C  B3C701     MOV.B #0x70, W1
2430:                                          break;
2431:                                  }
2432:              
2433:                                  // Report the problem to the application.
2434:                                  USB_HOST_APP_EVENT_HANDLER( usbDeviceInfo.deviceAddress, temp, &usbDeviceInfo.currentConfigurationPower , 1 );
00577E  FB8081     ZE W1, W1
005780  200014     MOV #0x1, W4
005782  200005     MOV #0x0, W5
005784  209662     MOV #0x966, W2
005786  510065     SUB W2, #0x5, W0
005788  784010     MOV.B [W0], W0
00578A  072994     RCALL USB_Host_ApplicationEventHandler
2435:              
2436:                                  _USB_SetNextSubState();
00578C  20FF00     MOV #0xFF0, W0
00578E  B60FAC     AND usbHostState, WREG
005790  400070     ADD W0, #0x10, W0
005792  887D60     MOV W0, usbHostState
2437:                                  break;
2438:              
2439:                              case SUBSTATE_HOLD:
2440:                                  // Hold here until a DETACH interrupt frees us.
2441:                                  break;
2442:              
2443:                              default:
2444:                                  break;
2445:                          }
2446:                          break;
2447:                  }
2448:              
2449:              }
005794  BE064F     MOV.D [--W15], W12
005796  BE054F     MOV.D [--W15], W10
005798  BE044F     MOV.D [--W15], W8
00579A  FA8000     ULNK
00579C  060000     RETURN
2450:              
2451:              /****************************************************************************
2452:                Function:
2453:                  void USBHostTerminateTransfer( uint8_t deviceAddress, uint8_t endpoint )
2454:              
2455:              
2456:                Summary:
2457:                  This function terminates the current transfer for the given endpoint.
2458:              
2459:                Description:
2460:                  This function terminates the current transfer for the given endpoint.  It
2461:                  can be used to terminate reads or writes that the device is not
2462:                  responding to.  It is also the only way to terminate an isochronous
2463:                  transfer.
2464:              
2465:                Precondition:
2466:                  None
2467:              
2468:                Parameters:
2469:                  uint8_t deviceAddress  - Device address
2470:                  uint8_t endpoint       - Endpoint number
2471:              
2472:                Returns:
2473:                  None
2474:              
2475:                Remarks:
2476:                  None
2477:                ***************************************************************************/
2478:              
2479:              void USBHostTerminateTransfer( uint8_t deviceAddress, uint8_t endpoint )
2480:              {
2481:                  USB_ENDPOINT_INFO *ep;
2482:              
2483:                  // Find the required device
2484:                  if (deviceAddress != usbDeviceInfo.deviceAddress)
004736  209612     MOV #0x961, W2
004738  104F92     SUBR.B W0, [W2], [W15]
00473A  3A000A     BRA NZ, .L63
2485:                  {
2486:                      return; // USB_UNKNOWN_DEVICE;
2487:                  }
2488:              
2489:                  ep = _USB_FindEndpoint( endpoint );
00473C  784001     MOV.B W1, W0
00473E  07FFAD     RCALL _USB_FindEndpoint
2490:                  if (ep != NULL)
004740  E00000     CP0 W0
004742  320006     BRA Z, .L63
2491:                  {
2492:                      ep->status.bfUserAbort          = 1;
004744  900090     MOV [W0+2], W1
004746  A07001     BSET W1, #7
004748  980011     MOV W1, [W0+2]
2493:                      ep->status.bfTransferComplete   = 1;
00474A  900090     MOV [W0+2], W1
00474C  A09001     BSET W1, #9
00474E  980011     MOV W1, [W0+2]
2494:                  }
2495:              }
004750  060000     RETURN
2496:              
2497:              /****************************************************************************
2498:                Function:
2499:                  bool USBHostTransferIsComplete( uint8_t deviceAddress, uint8_t endpoint,
2500:                                      uint8_t *errorCode, uint32_t *byteCount )
2501:              
2502:                Summary:
2503:                  This function initiates whether or not the last endpoint transaction is
2504:                  complete.
2505:              
2506:                Description:
2507:                  This function initiates whether or not the last endpoint transaction is
2508:                  complete.  If it is complete, an error code and the number of bytes
2509:                  transferred are returned.
2510:              
2511:                  For isochronous transfers, byteCount is not valid.  Instead, use the
2512:                  returned byte counts for each EVENT_TRANSFER event that was generated
2513:                  during the transfer.
2514:              
2515:                Precondition:
2516:                  None
2517:              
2518:                Parameters:
2519:                  uint8_t deviceAddress  - Device address
2520:                  uint8_t endpoint       - Endpoint number
2521:                  uint8_t *errorCode     - Error code indicating the status of the transfer.
2522:                                          Only valid if the transfer is complete.
2523:                  uint32_t *byteCount    - The number of bytes sent or received.  Invalid
2524:                                          for isochronous transfers.
2525:              
2526:                Return Values:
2527:                  true    - Transfer is complete.
2528:                  false   - Transfer is not complete.
2529:              
2530:                Remarks:
2531:                  Possible values for errorCode are:
2532:                      * USB_SUCCESS                     - Transfer successful
2533:                      * USB_UNKNOWN_DEVICE              - Device not attached
2534:                      * USB_ENDPOINT_STALLED            - Endpoint STALL'd
2535:                      * USB_ENDPOINT_ERROR_ILLEGAL_PID  - Illegal PID returned
2536:                      * USB_ENDPOINT_ERROR_BIT_STUFF
2537:                      * USB_ENDPOINT_ERROR_DMA
2538:                      * USB_ENDPOINT_ERROR_TIMEOUT
2539:                      * USB_ENDPOINT_ERROR_DATA_FIELD
2540:                      * USB_ENDPOINT_ERROR_CRC16
2541:                      * USB_ENDPOINT_ERROR_END_OF_FRAME
2542:                      * USB_ENDPOINT_ERROR_PID_CHECK
2543:                      * USB_ENDPOINT_ERROR              - Other error
2544:                ***************************************************************************/
2545:              
2546:              bool USBHostTransferIsComplete( uint8_t deviceAddress, uint8_t endpoint, uint8_t *errorCode,
2547:                          uint32_t *byteCount )
2548:              {
0046D6  BE9F88     MOV.D W8, [W15++]
0046D8  780482     MOV W2, W9
0046DA  780403     MOV W3, W8
2549:                  USB_ENDPOINT_INFO   *ep;
2550:                  uint8_t                transferComplete;
2551:              
2552:                  // Find the required device
2553:                  if (deviceAddress != usbDeviceInfo.deviceAddress)
0046DC  209612     MOV #0x961, W2
0046DE  104F92     SUBR.B W0, [W2], [W15]
0046E0  320006     BRA Z, .L56
2554:                  {
2555:                      *errorCode = USB_UNKNOWN_DEVICE;
0046E2  B3C060     MOV.B #0x6, W0
0046E4  784C80     MOV.B W0, [W9]
2556:                      *byteCount = 0;
0046E6  EB0C00     CLR [W8]
0046E8  781438     MOV [W8++], [W8--]
2557:                      return true;
0046EA  B3C010     MOV.B #0x1, W0
0046EC  370022     BRA .L57
2558:                  }
2559:              
2560:                  ep = _USB_FindEndpoint( endpoint );
0046EE  784001     MOV.B W1, W0
0046F0  07FFD4     RCALL _USB_FindEndpoint
2561:                  if (ep != NULL)
0046F2  E00000     CP0 W0
0046F4  32001B     BRA Z, .L58
2562:                  {
2563:                      // bfTransferComplete, the status flags, and byte count can be
2564:                      // changed in an interrupt service routine.  Therefore, we'll
2565:                      // grab it first, save it locally, and then determine the rest of
2566:                      // the information.  It is better to say that the transfer is not
2567:                      // yet complete, since the caller will simply try again.
2568:              
2569:                      // Save off the Transfer Complete status.  That way, we won't
2570:                      // load up bad values and then say the transfer is complete.
2571:                      transferComplete = ep->status.bfTransferComplete;
0046F6  900090     MOV [W0+2], W1
0046F8  DE08C9     LSR W1, #9, W1
0046FA  60C0E1     AND.B W1, #0x1, W1
2572:              
2573:                      // Set up error code.  This is only valid if the transfer is complete.
2574:                      if (ep->status.bfTransferSuccessful)
0046FC  900110     MOV [W0+2], W2
0046FE  A38802     BTST.Z W2, #8
004700  320005     BRA Z, .L59
2575:                      {
2576:                          *errorCode = USB_SUCCESS;
004702  EB4C80     CLR.B [W9]
2577:                          *byteCount = ep->dataCount;
004704  900900     MOV [W0+16], W2
004706  900990     MOV [W0+18], W3
004708  BE8C02     MOV.D W2, [W8]
00470A  37000E     BRA .L60
2578:                      }
2579:                      else if (ep->status.bfStalled)
00470C  900110     MOV [W0+2], W2
00470E  A35802     BTST.Z W2, #5
004710  320003     BRA Z, .L61
2580:                      {
2581:                          *errorCode = USB_ENDPOINT_STALLED;
004712  B3C110     MOV.B #0x11, W0
004714  784C80     MOV.B W0, [W9]
004716  370008     BRA .L60
2582:                      }
2583:                      else if (ep->status.bfError)
004718  900110     MOV [W0+2], W2
00471A  A36802     BTST.Z W2, #6
00471C  320003     BRA Z, .L62
2584:                      {
2585:                          *errorCode = ep->bErrorCode;
00471E  905840     MOV.B [W0+28], W0
004720  784C80     MOV.B W0, [W9]
004722  370002     BRA .L60
2586:                      }
2587:                      else
2588:                      {
2589:                          *errorCode = USB_ENDPOINT_UNRESOLVED_STATE;
004724  B3C190     MOV.B #0x19, W0
004726  784C80     MOV.B W0, [W9]
2590:                      }
2591:              
2592:                      return transferComplete;
004728  784001     MOV.B W1, W0
00472A  370003     BRA .L57
2593:                  }
2594:              
2595:                  // The endpoint was not found.  Return true so we can return a valid error code.
2596:                  *errorCode = USB_ENDPOINT_NOT_FOUND;
00472C  B3C140     MOV.B #0x14, W0
00472E  784C80     MOV.B W0, [W9]
2597:                  return true;
004730  B3C010     MOV.B #0x1, W0
2598:              }
004732  BE044F     MOV.D [--W15], W8
004734  060000     RETURN
2599:              
2600:              /****************************************************************************
2601:                Function:
2602:                  uint8_t  USBHostVbusEvent( USB_EVENT vbusEvent, uint8_t hubAddress,
2603:                                                      uint8_t portNumber)
2604:              
2605:                Summary:
2606:                  This function handles Vbus events that are detected by the application.
2607:              
2608:                Description:
2609:                  This function handles Vbus events that are detected by the application.
2610:                  Since Vbus management is application dependent, the application is
2611:                  responsible for monitoring Vbus and detecting overcurrent conditions
2612:                  and removal of the overcurrent condition.  If the application detects
2613:                  an overcurrent condition, it should call this function with the event
2614:                  EVENT_VBUS_OVERCURRENT with the address of the hub and port number that
2615:                  has the condition.  When a port returns to normal operation, the
2616:                  application should call this function with the event
2617:                  EVENT_VBUS_POWER_AVAILABLE so the stack knows that it can allow devices
2618:                  to attach to that port.
2619:              
2620:                Precondition:
2621:                  None
2622:              
2623:                Parameters:
2624:                  USB_EVENT vbusEvent     - Vbus event that occured.  Valid events:
2625:                                                  * EVENT_VBUS_OVERCURRENT
2626:                                                  * EVENT_VBUS_POWER_AVAILABLE
2627:                  uint8_t hubAddress         - Address of the hub device (USB_ROOT_HUB for the
2628:                                              root hub)
2629:                  uint8_t portNumber         - Number of the physical port on the hub (0 - based)
2630:              
2631:                Return Values:
2632:                  USB_SUCCESS             - Event handled
2633:                  USB_ILLEGAL_REQUEST     - Invalid event, hub, or port
2634:              
2635:                Remarks:
2636:                  None
2637:                ***************************************************************************/
2638:              
2639:              uint8_t  USBHostVbusEvent(USB_EVENT vbusEvent, uint8_t hubAddress, uint8_t portNumber)
2640:              {
2641:                  if ((hubAddress == USB_ROOT_HUB) &&
004C16  40CFE1     ADD.B W1, #0x1, [W15]
004C18  3A000F     BRA NZ, .L165
004C1A  E00402     CP0.B W2
004C1C  3A000D     BRA NZ, .L165
2642:                      (portNumber == 0 ))
2643:                  {
2644:                      if (vbusEvent == EVENT_VBUS_OVERCURRENT)
004C1E  200681     MOV #0x68, W1
004C20  500F81     SUB W0, W1, [W15]
004C22  3A0004     BRA NZ, .L166
2645:                      {
2646:                          USBHostShutdown();
004C24  07FFDE     RCALL USBHostShutdown
2647:                          usbRootHubInfo.flags.bPowerGoodPort0 = 0;
004C26  A90FB8     BCLR usbRootHubInfo, #0
2648:                          return USB_SUCCESS;
004C28  EB4180     CLR.B W3
004C2A  370006     BRA .L165
2649:                      }
2650:                      if (vbusEvent == EVENT_VBUS_POWER_AVAILABLE)
004C2E  2006B1     MOV #0x6B, W1
004C30  500F81     SUB W0, W1, [W15]
004C32  3A0002     BRA NZ, .L165
2651:                      {
2652:                          usbRootHubInfo.flags.bPowerGoodPort0 = 1;
004C34  A80FB8     BSET usbRootHubInfo, #0
2653:                          return USB_SUCCESS;
004C36  EB4180     CLR.B W3
2654:                      }
2655:                  }
2656:              
2657:                  return USB_ILLEGAL_REQUEST;
004C14  B3C033     MOV.B #0x3, W3
004C2C  B3C033     MOV.B #0x3, W3
2658:              }
004C38  784003     MOV.B W3, W0
004C3A  060000     RETURN
2659:              
2660:              
2661:              /****************************************************************************
2662:                Function:
2663:                  uint8_t USBHostWrite( uint8_t deviceAddress, uint8_t endpoint, uint8_t *data,
2664:                                      uint32_t size )
2665:              
2666:                Summary:
2667:                  This function initiates a write to the attached device.
2668:              
2669:                Description:
2670:                  This function initiates a write to the attached device.  The data buffer
2671:                  pointed to by *data must remain valid during the entire time that the
2672:                  write is taking place; the data is not buffered by the stack.
2673:              
2674:                  If the endpoint is isochronous, special conditions apply.  The pData and
2675:                  size parameters have slightly different meanings, since multiple buffers
2676:                  are required.  Once started, an isochronous transfer will continue with
2677:                  no upper layer intervention until USBHostTerminateTransfer() is called.
2678:                  The ISOCHRONOUS_DATA_BUFFERS structure should not be manipulated until
2679:                  the transfer is terminated.
2680:              
2681:                  To clarify parameter usage and to simplify casting, use the macro
2682:                  USBHostWriteIsochronous() when writing to an isochronous endpoint.
2683:              
2684:                Precondition:
2685:                  None
2686:              
2687:                Parameters:
2688:                  uint8_t deviceAddress  - Device address
2689:                  uint8_t endpoint       - Endpoint number
2690:                  uint8_t *data          - Pointer to where the data is stored. If the endpoint
2691:                                          is isochronous, this points to an
2692:                                          ISOCHRONOUS_DATA_BUFFERS structure, with multiple
2693:                                          data buffer pointers.
2694:                  uint32_t size          - Number of data bytes to send. If the endpoint is
2695:                                          isochronous, this is the number of data buffer
2696:                                          pointers pointed to by pData.
2697:              
2698:                Return Values:
2699:                  USB_SUCCESS                     - Write started successfully.
2700:                  USB_UNKNOWN_DEVICE              - Device with the specified address not found.
2701:                  USB_INVALID_STATE               - We are not in a normal running state.
2702:                  USB_ENDPOINT_ILLEGAL_TYPE       - Must use USBHostControlWrite to write
2703:                                                      to a control endpoint.
2704:                  USB_ENDPOINT_ILLEGAL_DIRECTION  - Must write to an OUT endpoint.
2705:                  USB_ENDPOINT_STALLED            - Endpoint is stalled.  Must be cleared
2706:                                                      by the application.
2707:                  USB_ENDPOINT_ERROR              - Endpoint has too many errors.  Must be
2708:                                                      cleared by the application.
2709:                  USB_ENDPOINT_BUSY               - A Write is already in progress.
2710:                  USB_ENDPOINT_NOT_FOUND          - Invalid endpoint.
2711:              
2712:                Remarks:
2713:                  None
2714:                ***************************************************************************/
2715:              
2716:              uint8_t USBHostWrite( uint8_t deviceAddress, uint8_t endpoint, uint8_t *data, uint32_t size )
2717:              {
004AF6  BE9F88     MOV.D W8, [W15++]
004AF8  781F8A     MOV W10, [W15++]
004AFA  780502     MOV W2, W10
004AFC  BE0404     MOV.D W4, W8
2718:                  USB_ENDPOINT_INFO *ep;
2719:              
2720:                  // Find the required device
2721:                  if (deviceAddress != usbDeviceInfo.deviceAddress)
004B00  209613     MOV #0x961, W3
004B02  104F93     SUBR.B W0, [W3], [W15]
004B04  3A0026     BRA NZ, .L144
2722:                  {
2723:                      return USB_UNKNOWN_DEVICE;
004AFE  B3C062     MOV.B #0x6, W2
2724:                  }
2725:              
2726:                  // If we are not in a normal user running state, we cannot do this.
2727:                  if ((usbHostState & STATE_MASK) != STATE_RUNNING)
004B06  20F003     MOV #0xF00, W3
004B08  807D60     MOV usbHostState, W0
004B0A  618180     AND W3, W0, W3
004B0E  204000     MOV #0x400, W0
004B10  518F80     SUB W3, W0, [W15]
004B12  3A001F     BRA NZ, .L144
2728:                  {
2729:                      return USB_INVALID_STATE;
004B0C  B3C012     MOV.B #0x1, W2
2730:                  }
2731:              
2732:                  ep = _USB_FindEndpoint( endpoint );
004B14  784001     MOV.B W1, W0
004B16  07FDC1     RCALL _USB_FindEndpoint
004B18  780180     MOV W0, W3
2733:                  if (ep != NULL)
004B1C  E00003     CP0 W3
004B1E  320019     BRA Z, .L144
2734:                  {
2735:                      if (ep->bmAttributes.bfTransferType == USB_TRANSFER_TYPE_CONTROL)
004B20  900853     MOV [W3+26], W0
004B22  B23000     AND #0x300, W0
004B26  320015     BRA Z, .L144
2736:                      {
2737:                          // Must not be a control endpoint.
2738:                          return USB_ENDPOINT_ILLEGAL_TYPE;
004B24  B3C182     MOV.B #0x18, W2
2739:                      }
2740:              
2741:                      if (ep->bEndpointAddress & 0x80)
004B28  905823     MOV.B [W3+26], W0
004B2C  E00400     CP0.B W0
004B2E  350011     BRA LT, .L144
2742:                      {
2743:                          // Trying to do an OUT with an IN endpoint.
2744:                          return USB_ENDPOINT_ILLEGAL_DIRECTION;
004B2A  B3C152     MOV.B #0x15, W2
2745:                      }
2746:              
2747:                      if (ep->status.bfStalled)
004B30  900013     MOV [W3+2], W0
004B34  A35800     BTST.Z W0, #5
004B36  3A000D     BRA NZ, .L144
2748:                      {
2749:                          // The endpoint is stalled.  It must be restarted before a write
2750:                          // can be performed.
2751:                          return USB_ENDPOINT_STALLED;
004B32  B3C112     MOV.B #0x11, W2
2752:                      }
2753:              
2754:                      if (ep->status.bfError)
004B38  900013     MOV [W3+2], W0
004B3C  A36800     BTST.Z W0, #6
004B3E  3A0009     BRA NZ, .L144
2755:                      {
2756:                          // The endpoint has errored.  The error must be cleared before a
2757:                          // write can be performed.
2758:                          return USB_ENDPOINT_ERROR;
004B3A  B3C122     MOV.B #0x12, W2
2759:                      }
2760:              
2761:                      if (!ep->status.bfTransferComplete)
004B40  900013     MOV [W3+2], W0
004B44  A39800     BTST.Z W0, #9
004B46  320005     BRA Z, .L144
2762:                      {
2763:                          // We are already processing a request for this endpoint.
2764:                          return USB_ENDPOINT_BUSY;
004B42  B3C102     MOV.B #0x10, W2
2765:                      }
2766:              
2767:                      _USB_InitWrite( ep, data, size );
004B48  780108     MOV W8, W2
004B4A  78008A     MOV W10, W1
004B4C  780003     MOV W3, W0
004B4E  07FFA7     RCALL _USB_InitWrite
2768:              
2769:                      return USB_SUCCESS;
004B50  EB4100     CLR.B W2
2770:                  }
2771:                  return USB_ENDPOINT_NOT_FOUND;   // Endpoint not found
004B1A  B3C142     MOV.B #0x14, W2
2772:              }
004B52  784002     MOV.B W2, W0
004B54  78054F     MOV [--W15], W10
004B56  BE044F     MOV.D [--W15], W8
004B58  060000     RETURN
2773:              
2774:              
2775:              // *****************************************************************************
2776:              // *****************************************************************************
2777:              // Section: Internal Functions
2778:              // *****************************************************************************
2779:              // *****************************************************************************
2780:              
2781:              /****************************************************************************
2782:                Function:
2783:                  void _USB_CheckCommandAndEnumerationAttempts( void )
2784:              
2785:                Summary:
2786:                  This function is called when we've received a STALL or a NAK when trying
2787:                  to enumerate.
2788:              
2789:                Description:
2790:                  This function is called when we've received a STALL or a NAK when trying
2791:                  to enumerate.  We allow so many attempts at each command, and so many
2792:                  attempts at enumeration.  If the command fails and there are more command
2793:                  attempts, we try the command again.  If the command fails and there are
2794:                  more enumeration attempts, we reset and try to enumerate again.
2795:                  Otherwise, we go to the holding state.
2796:              
2797:                Precondition:
2798:                  usbHostState != STATE_RUNNING
2799:              
2800:                Parameters:
2801:                  None - None
2802:              
2803:                Returns:
2804:                  None
2805:              
2806:                Remarks:
2807:                  None
2808:                ***************************************************************************/
2809:              
2810:              void _USB_CheckCommandAndEnumerationAttempts( void )
2811:              {
2812:              #if defined (DEBUG_ENABLE)
2813:                  DEBUG_PutChar( '=' );
2814:              #endif
2815:              
2816:                  // Clear the error and stall flags.  A stall here does not require
2817:                  // host intervention to clear.
2818:                  pCurrentEndpoint->status.bfError    = 0;
00450E  807D70     MOV pCurrentEndpoint, W0
004510  900090     MOV [W0+2], W1
004512  A16001     BCLR W1, #6
004514  980011     MOV W1, [W0+2]
2819:                  pCurrentEndpoint->status.bfStalled  = 0;
004516  807D70     MOV pCurrentEndpoint, W0
004518  900090     MOV [W0+2], W1
00451A  A15001     BCLR W1, #5
00451C  980011     MOV W1, [W0+2]
2820:              
2821:                  numCommandTries --;
00451E  ED4FB6     DEC.B numCommandTries, WREG
004520  B7EFB6     MOV.B WREG, numCommandTries
2822:                  if (numCommandTries != 0)
004522  320003     BRA Z, .L22
2823:                  {
2824:                      // We still have retries left on this command.  Try again.
2825:                      usbHostState &= ~SUBSUBSTATE_MASK;
004524  2FFF00     MOV #0xFFF0, W0
004526  B62FAC     AND usbHostState
004528  37000B     BRA .L21
2826:                  }
2827:                  else
2828:                  {
2829:                      // This command has timed out.
2830:                      // We are enumerating.  See if we can try to enumerate again.
2831:                      numEnumerationTries --;
00452A  ED4FB7     DEC.B numEnumerationTries, WREG
00452C  B7EFB7     MOV.B WREG, numEnumerationTries
2832:                      if (numEnumerationTries != 0)
00452E  320003     BRA Z, .L24
2833:                      {
2834:                          // We still have retries left to try to enumerate.  Reset and try again.
2835:                          usbHostState = STATE_ATTACHED | SUBSTATE_RESET_DEVICE;
004530  201100     MOV #0x110, W0
004532  887D60     MOV W0, usbHostState
004534  370005     BRA .L21
2836:                      }
2837:                      else
2838:                      {
2839:                          // Give up.  The device is not responding properly.
2840:                          _USB_SetErrorCode( USB_CANNOT_ENUMERATE );
004536  B3C071     MOV.B #0x7, W1
004538  209620     MOV #0x962, W0
00453A  784801     MOV.B W1, [W0]
2841:                          _USB_SetHoldState();
00453C  205000     MOV #0x500, W0
00453E  887D60     MOV W0, usbHostState
2842:                      }
2843:                  }
2844:              }
004540  060000     RETURN
2845:              
2846:              
2847:              /****************************************************************************
2848:                Function:
2849:                  bool _USB_FindClassDriver( uint8_t bClass, uint8_t bSubClass, uint8_t bProtocol, uint8_t *pbClientDrv )
2850:              
2851:                Summary:
2852:              
2853:              
2854:                Description:
2855:                  This routine scans the TPL table looking for the entry with
2856:                              the given class, subclass, and protocol values.
2857:              
2858:                Precondition:
2859:                  usbTPL must be define by the application.
2860:              
2861:                Parameters:
2862:                  bClass      - The class of the desired entry
2863:                  bSubClass   - The subclass of the desired entry
2864:                  bProtocol   - The protocol of the desired entry
2865:                  pbClientDrv - Returned index to the client driver in the client driver
2866:                                  table.
2867:              
2868:                Return Values:
2869:                  true    - A class driver was found.
2870:                  false   - A class driver was not found.
2871:              
2872:                Remarks:
2873:                  None
2874:                ***************************************************************************/
2875:              
2876:              bool _USB_FindClassDriver( uint8_t bClass, uint8_t bSubClass, uint8_t bProtocol, uint8_t *pbClientDrv )
2877:              {
004542  FA0008     LNK #0x8
004544  781F88     MOV W8, [W15++]
004546  780403     MOV W3, W8
2878:                  USB_OVERRIDE_CLIENT_DRIVER_EVENT_DATA   eventData;
2879:                  int                                     i;
2880:                  USB_DEVICE_DESCRIPTOR                   *pDesc = (USB_DEVICE_DESCRIPTOR *)pDeviceDescriptor;
004548  807D35     MOV pDeviceDescriptor, W5
2881:              
2882:                  i = 0;
2883:                  while (i < NUM_TPL_ENTRIES)
2884:                  {
2885:                      if ((usbTPL[i].flags.bfIsClassDriver == 1        ) &&
00454A  804DB4     MOV 0x9B6, W4
00454C  D10204     LSR W4, W4
004550  A30804     BTST.Z W4, #0
004552  320030     BRA Z, .L26
004554  804DB3     MOV 0x9B6, W3
004556  A35803     BTST.Z W3, #5
004558  3A0004     BRA NZ, .L27
00455C  209B04     MOV #0x9B0, W4
00455E  104F94     SUBR.B W0, [W4], [W15]
004560  3A0029     BRA NZ, .L26
2886:                          (((usbTPL[i].flags.bfIgnoreClass == 0) ? (usbTPL[i].device.bClass == bClass) : true)) &&
004562  804DB3     MOV 0x9B6, W3
004564  A34803     BTST.Z W3, #4
004566  3A0004     BRA NZ, .L28
00456A  209B14     MOV #0x9B1, W4
00456C  10CF94     SUBR.B W1, [W4], [W15]
00456E  3A0022     BRA NZ, .L26
2887:                          (((usbTPL[i].flags.bfIgnoreSubClass == 0) ? (usbTPL[i].device.bSubClass == bSubClass) : true)) &&
004570  804DB3     MOV 0x9B6, W3
004572  A33803     BTST.Z W3, #3
004574  3A0004     BRA NZ, .L29
004578  209B24     MOV #0x9B2, W4
00457A  114F94     SUBR.B W2, [W4], [W15]
00457C  3A001B     BRA NZ, .L26
2888:                          (((usbTPL[i].flags.bfIgnoreProtocol == 0) ? (usbTPL[i].device.bProtocol == bProtocol) : true))  )
2889:                      {
2890:                          // Make sure the application layer does not have a problem with the selection.
2891:                          // If the application layer returns false, which it should if the event is not
2892:                          // defined, then accept the selection.
2893:                          eventData.idVendor          = pDesc->idVendor;
00457E  904985     MOV.B [W5+8], W3
004580  FB8183     ZE W3, W3
004582  904A15     MOV.B [W5+9], W4
004584  DD2248     SL W4, #8, W4
004586  720203     IOR W4, W3, W4
004588  9FBFB4     MOV W4, [W15-10]
2894:                          eventData.idProduct         = pDesc->idProduct;
00458A  904A25     MOV.B [W5+10], W4
00458C  FB8204     ZE W4, W4
00458E  9049B5     MOV.B [W5+11], W3
004590  DD19C8     SL W3, #8, W3
004592  720183     IOR W4, W3, W3
004594  9FBFC3     MOV W3, [W15-8]
2895:                          eventData.bDeviceClass      = bClass;
004596  9FFFA0     MOV.B W0, [W15-6]
2896:                          eventData.bDeviceSubClass   = bSubClass;
004598  9FFFB1     MOV.B W1, [W15-5]
2897:                          eventData.bDeviceProtocol   = bProtocol;
00459A  9FFFC2     MOV.B W2, [W15-4]
2898:              
2899:                          if (!USB_HOST_APP_EVENT_HANDLER( USB_ROOT_HUB, EVENT_OVERRIDE_CLIENT_DRIVER_SELECTION,
00459C  200084     MOV #0x8, W4
00459E  200005     MOV #0x0, W5
0045A0  57816A     SUB W15, #0xA, W2
0045A2  200791     MOV #0x79, W1
0045A4  EBC000     SETM.B W0
0045A6  073286     RCALL USB_Host_ApplicationEventHandler
0045AA  E00400     CP0.B W0
0045AC  3A0003     BRA NZ, .L26
2900:                                          &eventData, sizeof(USB_OVERRIDE_CLIENT_DRIVER_EVENT_DATA) ))
2901:                          {
2902:                              *pbClientDrv = usbTPL[i].ClientDriver;
0045AE  209B50     MOV #0x9B5, W0
0045B0  784C10     MOV.B [W0], [W8]
2903:              
2904:              #if defined (DEBUG_ENABLE)
2905:                              DEBUG_PutString( "HOST: Client driver found.\r\n" );
2906:              #endif
2907:              
2908:                              return true;
0045B2  B3C013     MOV.B #0x1, W3
2909:                          }
2910:                      }
2911:                      i++;
2912:                  }
2913:              
2914:              #if defined (DEBUG_ENABLE)
2915:                  DEBUG_PutString( "HOST: Client driver NOT found.\r\n" );
2916:              #endif
2917:              
2918:                  return false;
00454E  EB4180     CLR.B W3
00455A  EB4180     CLR.B W3
004568  EB4180     CLR.B W3
004576  EB4180     CLR.B W3
0045A8  EB4180     CLR.B W3
2919:              
2920:              } // _USB_FindClassDriver
0045B4  784003     MOV.B W3, W0
0045B6  78044F     MOV [--W15], W8
0045B8  FA8000     ULNK
0045BA  060000     RETURN
2921:              
2922:              
2923:              /****************************************************************************
2924:                Function:
2925:                  bool _USB_FindDeviceLevelClientDriver( void )
2926:              
2927:                Description:
2928:                  This function searches the TPL to try to find a device-level client
2929:                  driver.
2930:              
2931:                Precondition:
2932:                  * usbHostState == STATE_ATTACHED|SUBSTATE_VALIDATE_VID_PID
2933:                  * usbTPL must be define by the application.
2934:              
2935:                Parameters:
2936:                  None - None
2937:              
2938:                Return Values:
2939:                  true    - Client driver found
2940:                  false   - Client driver not found
2941:              
2942:                Remarks:
2943:                  If successful, this function preserves the client's index from the client
2944:                  driver table and sets flags indicating that the device should use a
2945:                  single client driver.
2946:                ***************************************************************************/
2947:              
2948:              bool _USB_FindDeviceLevelClientDriver( void )
2949:              {
0045BC  FA0008     LNK #0x8
2950:                  uint16_t                   i;
2951:                  USB_DEVICE_DESCRIPTOR *pDesc = (USB_DEVICE_DESCRIPTOR *)pDeviceDescriptor;
0045BE  807D31     MOV pDeviceDescriptor, W1
2952:              
2953:                  // Scan TPL
2954:                  i = 0;
2955:                  usbDeviceInfo.flags.bfUseDeviceClientDriver = 0;
0045C0  2096E0     MOV #0x96E, W0
0045C2  A16010     BCLR [W0], #6
2956:                  usbDeviceInfo.flags.bfUseEP0Driver = 0;
0045C4  A17010     BCLR [W0], #7
2957:                  while (i < NUM_TPL_ENTRIES)
2958:                  {
2959:                      if (usbTPL[i].flags.bfIsClassDriver)
0045C6  804DB0     MOV 0x9B6, W0
0045C8  D10000     LSR W0, W0
0045CA  A30800     BTST.Z W0, #0
0045CC  32000F     BRA Z, .L36
2960:                      {
2961:                          // Check for a device-class client driver
2962:                          if ((usbTPL[i].device.bClass    == pDesc->bDeviceClass   ) &&
0045CE  904041     MOV.B [W1+4], W0
0045D0  209B02     MOV #0x9B0, W2
0045D2  104F92     SUBR.B W0, [W2], [W15]
0045D4  3A0051     BRA NZ, .L37, .LBE2
0045D6  904051     MOV.B [W1+5], W0
0045D8  E80102     INC W2, W2
0045DA  104F92     SUBR.B W0, [W2], [W15]
0045DC  3A004D     BRA NZ, .L37, .LBE2
2963:                              (usbTPL[i].device.bSubClass == pDesc->bDeviceSubClass) &&
0045DE  904061     MOV.B [W1+6], W0
0045E0  E80082     INC W2, W1
0045E2  104F91     SUBR.B W0, [W1], [W15]
0045E4  3A0049     BRA NZ, .L37, .LBE2
2964:                              (usbTPL[i].device.bProtocol == pDesc->bDeviceProtocol)   )
2965:                          {
2966:              #if defined (DEBUG_ENABLE)
2967:                              DEBUG_PutString( "HOST: Device validated by class\r\n" );
2968:              #endif
2969:              
2970:                              usbDeviceInfo.flags.bfUseDeviceClientDriver = 1;
0045E6  2096E0     MOV #0x96E, W0
0045E8  A06010     BSET [W0], #6
0045EA  370046     BRA .L37, .LBE2
2971:                          }
2972:                      }
2973:                      else
2974:                      {
2975:                          // Check for a device-specific client driver by VID & PID
2976:                          if ((usbTPL[i].device.idVendor  == pDesc->idVendor ) &&
0045EC  904901     MOV.B [W1+8], W2
0045EE  FB8102     ZE W2, W2
0045F0  904811     MOV.B [W1+9], W0
0045F2  DD0048     SL W0, #8, W0
0045F4  710000     IOR W2, W0, W0
0045F6  804D82     MOV 0x9B0, W2
0045F8  510F80     SUB W2, W0, [W15]
0045FA  3A0019     BRA NZ, .L38
004606  804D92     MOV 0x9B2, W2
004608  510F80     SUB W2, W0, [W15]
00460A  3A0011     BRA NZ, .L38
2977:                              (usbTPL[i].device.idProduct == pDesc->idProduct))
0045FC  904921     MOV.B [W1+10], W2
0045FE  FB8102     ZE W2, W2
004600  904831     MOV.B [W1+11], W0
004602  DD0048     SL W0, #8, W0
004604  710000     IOR W2, W0, W0
2978:                          {
2979:                              if( usbTPL[i].flags.bfEP0OnlyCustomDriver == 1 )
00460C  804DB0     MOV 0x9B6, W0
00460E  A37800     BTST.Z W0, #7
004610  32000C     BRA Z, .L39
2980:                              {
2981:                                  usbDeviceInfo.flags.bfUseEP0Driver = 1;
004612  2096E0     MOV #0x96E, W0
004614  A07010     BSET [W0], #7
2982:                                  usbDeviceInfo.deviceEP0Driver = usbTPL[i].ClientDriver;
004616  209B52     MOV #0x9B5, W2
004618  50006A     SUB W0, #0xA, W0
00461A  784812     MOV.B [W2], [W0]
2983:              
2984:                                  // Select configuration if it is given in the TPL
2985:                                  if (usbTPL[i].flags.bfSetConfiguration)
00461C  804DB0     MOV 0x9B6, W0
00461E  A32800     BTST.Z W0, #2
004620  320006     BRA Z, .L38
2986:                                  {
2987:                                      usbDeviceInfo.currentConfiguration = usbTPL[i].bConfiguration;
004622  E90102     DEC W2, W2
004624  2095E0     MOV #0x95E, W0
004626  784812     MOV.B [W2], [W0]
004628  370002     BRA .L38
2988:                                  }
2989:                              }
2990:                              else
2991:                              {
2992:              #if defined (DEBUG_ENABLE)
2993:                                  DEBUG_PutString( "HOST: Device validated by VID/PID\r\n" );
2994:              #endif
2995:              
2996:                                  usbDeviceInfo.flags.bfUseDeviceClientDriver = 1;
00462A  2096E0     MOV #0x96E, W0
00462C  A06010     BSET [W0], #6
2997:                              }
2998:                          }
2999:              
3000:                          #ifdef ALLOW_GLOBAL_VID_AND_PID
3001:                          if ((usbTPL[i].device.idVendor  == 0xFFFF) &&
00462E  804D80     MOV 0x9B0, W0
004630  400FE1     ADD W0, #0x1, [W15]
004632  3A0022     BRA NZ, .L37, .LBE2
004634  804D90     MOV 0x9B2, W0
004636  400FE1     ADD W0, #0x1, [W15]
004638  3A001F     BRA NZ, .L37, .LBE2
3002:                              (usbTPL[i].device.idProduct == 0xFFFF))
3003:                          {
3004:                              USB_OVERRIDE_CLIENT_DRIVER_EVENT_DATA   eventData;
3005:              
3006:                              // Make sure the application layer does not have a problem with the selection.
3007:                              // If the application layer returns false, which it should if the event is not
3008:                              // defined, then accept the selection.
3009:                              eventData.idVendor          = pDesc->idVendor;
00463A  904801     MOV.B [W1+8], W0
00463C  FB8000     ZE W0, W0
00463E  904911     MOV.B [W1+9], W2
004640  DD1148     SL W2, #8, W2
004642  710100     IOR W2, W0, W2
004644  9FBFC2     MOV W2, [W15-8]
3010:                              eventData.idProduct         = pDesc->idProduct;
004646  904821     MOV.B [W1+10], W0
004648  FB8000     ZE W0, W0
00464A  9048B1     MOV.B [W1+11], W1
00464C  DD08C8     SL W1, #8, W1
00464E  700001     IOR W0, W1, W0
004650  9FBFD0     MOV W0, [W15-6]
3011:                              eventData.bDeviceClass      = usbTPL[i].device.bClass;
004652  209B00     MOV #0x9B0, W0
004654  784010     MOV.B [W0], W0
004656  9FFFC0     MOV.B W0, [W15-4]
3012:                              eventData.bDeviceSubClass   = usbTPL[i].device.bSubClass;
004658  209B10     MOV #0x9B1, W0
00465A  784010     MOV.B [W0], W0
00465C  9FFFD0     MOV.B W0, [W15-3]
3013:                              eventData.bDeviceProtocol   = usbTPL[i].device.bProtocol;
00465E  209B20     MOV #0x9B2, W0
004660  784010     MOV.B [W0], W0
004662  9FFFE0     MOV.B W0, [W15-2]
3014:              
3015:                              if (!USB_HOST_APP_EVENT_HANDLER( USB_ROOT_HUB, EVENT_OVERRIDE_CLIENT_DRIVER_SELECTION,
004664  200084     MOV #0x8, W4
004666  200005     MOV #0x0, W5
004668  578168     SUB W15, #0x8, W2
00466A  200791     MOV #0x79, W1
00466C  EBC000     SETM.B W0
00466E  073222     RCALL USB_Host_ApplicationEventHandler
004670  E00400     CP0.B W0
004672  3A0002     BRA NZ, .L37, .LBE2
3016:                                              &eventData, sizeof(USB_OVERRIDE_CLIENT_DRIVER_EVENT_DATA) ))
3017:                              {
3018:              #if defined (DEBUG_ENABLE)
3019:                                  DEBUG_PutString( "HOST: Device validated by VID/PID\r\n" );
3020:              #endif
3021:              
3022:                                  usbDeviceInfo.flags.bfUseDeviceClientDriver = 1;
004674  2096E0     MOV #0x96E, W0
004676  A06010     BSET [W0], #6
3023:                              }
3024:                          }
3025:                          #endif
3026:                      }
3027:              
3028:                      if (usbDeviceInfo.flags.bfUseDeviceClientDriver)
004678  804B71     MOV 0x96E, W1
00467C  A36801     BTST.Z W1, #6
00467E  32000B     BRA Z, .L40
3029:                      {
3030:                          // Save client driver info
3031:                          usbDeviceInfo.deviceClientDriver = usbTPL[i].ClientDriver;
004680  209B51     MOV #0x9B5, W1
004682  209630     MOV #0x963, W0
004684  784811     MOV.B [W1], [W0]
3032:              
3033:                          // Select configuration if it is given in the TPL
3034:                          if (usbTPL[i].flags.bfSetConfiguration)
004688  804DB1     MOV 0x9B6, W1
00468A  A32801     BTST.Z W1, #2
00468C  320004     BRA Z, .L40
3035:                          {
3036:                              usbDeviceInfo.currentConfiguration = usbTPL[i].bConfiguration;
00468E  209B41     MOV #0x9B4, W1
004690  2095E0     MOV #0x95E, W0
004692  784811     MOV.B [W1], [W0]
3037:                          }
3038:              
3039:                          return true;
004686  B3C010     MOV.B #0x1, W0
004694  B3C010     MOV.B #0x1, W0
3040:                      }
3041:              
3042:                      i++;
3043:                  }
3044:              
3045:              #if defined (DEBUG_ENABLE)
3046:                  DEBUG_PutString( "HOST: Device not yet validated\r\n" );
3047:              #endif
3048:              
3049:                  return false;
00467A  EB4000     CLR.B W0
3050:              }
004696  FA8000     ULNK
004698  060000     RETURN
3051:              
3052:              
3053:              /****************************************************************************
3054:                Function:
3055:                  USB_ENDPOINT_INFO * _USB_FindEndpoint( uint8_t endpoint )
3056:              
3057:                Description:
3058:                  This function searches the list of interfaces to try to find the specified
3059:                  endpoint.
3060:              
3061:                Precondition:
3062:                  None
3063:              
3064:                Parameters:
3065:                  uint8_t endpoint   - The endpoint to find.
3066:              
3067:                Returns:
3068:                  Returns a pointer to the USB_ENDPOINT_INFO structure for the endpoint.
3069:              
3070:                Remarks:
3071:                  None
3072:                ***************************************************************************/
3073:              
3074:              USB_ENDPOINT_INFO * _USB_FindEndpoint( uint8_t endpoint )
3075:              {
00469A  784080     MOV.B W0, W1
3076:                  USB_ENDPOINT_INFO           *pEndpoint;
3077:                  USB_INTERFACE_INFO          *pInterface;
3078:              
3079:                  if (endpoint == 0)
00469C  E00401     CP0.B W1
00469E  3A0002     BRA NZ, .L44
3080:                  {
3081:                      return usbDeviceInfo.pEndpoint0;
0046A0  804B60     MOV 0x96C, W0
0046A2  370018     BRA .L45
3082:                  }
3083:              
3084:                  pInterface = usbDeviceInfo.pInterfaceList;
0046A4  804B53     MOV 0x96A, W3
3085:                  while (pInterface)
0046A8  E00003     CP0 W3
0046AA  320014     BRA Z, .L45
0046CE  E00003     CP0 W3
0046D0  3AFFED     BRA NZ, .L52
3086:                  {
3087:                      // Look for the endpoint in the currently active setting.
3088:                      if (pInterface->pCurrentSetting)
0046AC  900023     MOV [W3+4], W0
0046AE  E00000     CP0 W0
0046B0  32000D     BRA Z, .L46
3089:                      {
3090:                          pEndpoint = pInterface->pCurrentSetting->pEndpointList;
0046B2  900020     MOV [W0+4], W0
3091:                          while (pEndpoint)
0046B4  E00000     CP0 W0
0046B6  32000A     BRA Z, .L46
0046C8  E00000     CP0 W0
0046CA  3AFFFA     BRA NZ, .L49
3092:                          {
3093:                              if (pEndpoint->bEndpointAddress == endpoint)
0046B8  905920     MOV.B [W0+26], W2
0046BA  514F81     SUB.B W2, W1, [W15]
0046BC  3A0004     BRA NZ, .L54
0046BE  37000A     BRA .L45
0046C0  905920     MOV.B [W0+26], W2
0046C2  514F81     SUB.B W2, W1, [W15]
0046C4  320007     BRA Z, .L45
3094:                              {
3095:                                  // We have found the endpoint.
3096:                                  return pEndpoint;
3097:                              }
3098:                              pEndpoint = pEndpoint->next;
0046C6  780010     MOV [W0], W0
3099:                          }
3100:                      }
3101:              
3102:                      // Go to the next interface.
3103:                      pInterface = pInterface->next;
0046CC  780193     MOV [W3], W3
3104:                  }
3105:              
3106:                  return NULL;
0046A6  EB0000     CLR W0
0046D2  EB0000     CLR W0
3107:              }
0046D4  060000     RETURN
3108:              
3109:              
3110:              /****************************************************************************
3111:                Function:
3112:                  USB_INTERFACE_INFO * _USB_FindInterface ( uint8_t bInterface, uint8_t bAltSetting )
3113:              
3114:                Description:
3115:                  This routine scans the interface linked list and returns a pointer to the
3116:                  node identified by the interface and alternate setting.
3117:              
3118:                Precondition:
3119:                  None
3120:              
3121:                Parameters:
3122:                  bInterface  - Interface number
3123:                  bAltSetting - Interface alternate setting number
3124:              
3125:                Returns:
3126:                  USB_INTERFACE_INFO *  - Pointer to the interface linked list node.
3127:              
3128:                Remarks:
3129:                  None
3130:                ***************************************************************************/
3131:              /*
3132:              USB_INTERFACE_INFO * _USB_FindInterface ( uint8_t bInterface, uint8_t bAltSetting )
3133:              {
3134:                  USB_INTERFACE_INFO *pCurIntf = usbDeviceInfo.pInterfaceList;
3135:              
3136:                  while (pCurIntf)
3137:                  {
3138:                      if (pCurIntf->interface           == bInterface &&
3139:                          pCurIntf->interfaceAltSetting == bAltSetting  )
3140:                      {
3141:                          return pCurIntf;
3142:                      }
3143:                  }
3144:              
3145:                  return NULL;
3146:              
3147:              } // _USB_FindInterface
3148:              */
3149:              
3150:              /****************************************************************************
3151:                Function:
3152:                  void _USB_FindNextToken( void )
3153:              
3154:                Description:
3155:                  This function determines the next token to send of all current pending
3156:                  transfers.
3157:              
3158:                Precondition:
3159:                  None
3160:              
3161:                Parameters:
3162:                  None - None
3163:              
3164:                Return Values:
3165:                  true    - A token was sent
3166:                  false   - No token was found to send, so the routine can be called again.
3167:              
3168:                Remarks:
3169:                  This routine is only called from an interrupt handler, either SOFIF or
3170:                  TRNIF.
3171:                ***************************************************************************/
3172:              
3173:              void _USB_FindNextToken( void )
3174:              {
005A28  BE9F88     MOV.D W8, [W15++]
005A2A  BE9F8A     MOV.D W10, [W15++]
005A2C  BE9F8C     MOV.D W12, [W15++]
3175:                  bool    illegalState = false;
005A34  EB4400     CLR.B W8
0061E8  EB4400     CLR.B W8
0061EA  37FDFE     BRA .L441
3176:              
3177:                  // If the device is suspended or resuming, do not send any tokens.  We will
3178:                  // send the next token on an SOF interrupt after the resume recovery time
3179:                  // has expired.
3180:                  if ((usbHostState & (SUBSTATE_MASK | SUBSUBSTATE_MASK)) == (STATE_RUNNING | SUBSTATE_SUSPEND_AND_RESUME))
005A2E  807D60     MOV usbHostState, W0
3181:                  {
3182:                      return;
3183:                  }
3184:              
3185:                  // If we are currently sending a token, we cannot do anything.  We will come
3186:                  // back in here when we get either the Token Done or the Start of Frame interrupt.
3187:                  if (usbBusInfo.flags.bfTokenAlreadyWritten) //(U1CONbits.TOKBUSY)
005A30  AB8FB0     BTST usbBusInfo, #4
005A32  3A03DC     BRA NZ, .L438
3188:                  {
3189:                      return;
3190:                  }
3191:              
3192:                  // We will handle control transfers first.  We only allow one control
3193:                  // transfer per frame.
3194:                  if (!usbBusInfo.flags.bfControlTransfersDone)
005A36  AB0FB0     BTST usbBusInfo, #0
005A38  3A01D8     BRA NZ, .L440
3195:                  {
3196:                      // Look for any control transfers.
3197:                      if (_USB_FindServiceEndpoint( USB_TRANSFER_TYPE_CONTROL ))
005A3A  784008     MOV.B W8, W0
005A3C  07F6B3     RCALL _USB_FindServiceEndpoint
005A3E  E00400     CP0.B W0
005A40  3201D3     BRA Z, .L441
3198:                      {
3199:                          switch (pCurrentEndpoint->transferState & TSTATE_MASK)
005A42  807D70     MOV pCurrentEndpoint, W0
005A44  905880     MOV.B [W0+24], W1
005A46  B20F01     AND #0xF0, W1
005A48  200202     MOV #0x20, W2
005A4A  508F82     SUB W1, W2, [W15]
005A4C  320094     BRA Z, .L444
005A4E  410170     ADD W2, #0x10, W2
005A50  508F82     SUB W1, W2, [W15]
005A52  32012A     BRA Z, .L445
005A54  508FF0     SUB W1, #0x10, [W15]
005A56  3A01C1     BRA NZ, .L442
3200:                          {
3201:                              case TSTATE_CONTROL_NO_DATA:
3202:                                  switch (pCurrentEndpoint->transferState & TSUBSTATE_MASK)
005A58  905880     MOV.B [W0+24], W1
005A5A  6080EF     AND W1, #0xF, W1
005A5C  508FE1     SUB W1, #0x1, [W15]
005A5E  320014     BRA Z, .L447
005A60  3C0003     BRA GT, .L450
005A62  E00001     CP0 W1
005A64  320006     BRA Z, .L446
005A66  3701B9     BRA .L442
005A68  508FE2     SUB W1, #0x2, [W15]
005A6A  32001E     BRA Z, .L448
005A6C  508FEF     SUB W1, #0xF, [W15]
005A6E  3A01B5     BRA NZ, .L442
005A70  37004F     BRA .L551
3203:                                  {
3204:                                      case TSUBSTATE_CONTROL_NO_DATA_SETUP:
3205:                                          _USB_SetDATA01( DTS_DATA0 );
005A72  900090     MOV [W0+2], W1
005A74  A1B001     BCLR W1, #11
005A76  980011     MOV W1, [W0+2]
3206:                                          _USB_SetBDT( USB_TOKEN_SETUP );
005A78  B3C0D0     MOV.B #0xD, W0
005A7A  07FF50     RCALL _USB_SetBDT
3207:                                          _USB_SendToken( pCurrentEndpoint->bEndpointAddress, USB_TOKEN_SETUP );
005A7C  807D70     MOV pCurrentEndpoint, W0
005A7E  905820     MOV.B [W0+26], W0
005A80  B3C0D1     MOV.B #0xD, W1
005A82  07FF30     RCALL _USB_SendToken
3208:                                          #ifdef ONE_CONTROL_TRANSACTION_PER_FRAME
3209:                                              usbBusInfo.flags.bfControlTransfersDone = 1; // Only one control transfer per frame.
005A84  A80FB0     BSET usbBusInfo, #0
3210:                                          #endif
3211:                                          return;
005A86  3703B2     BRA .L438
3212:                                          break;
3213:              
3214:                                      case TSUBSTATE_CONTROL_NO_DATA_ACK:
3215:                                          pCurrentEndpoint->dataCountMax = pCurrentEndpoint->dataCount;
005A88  900900     MOV [W0+16], W2
005A8A  900990     MOV [W0+18], W3
005A8C  980052     MOV W2, [W0+10]
005A8E  980063     MOV W3, [W0+12]
3216:                                          _USB_SetDATA01( DTS_DATA1 );
005A90  807D70     MOV pCurrentEndpoint, W0
005A92  900090     MOV [W0+2], W1
005A94  A0B001     BSET W1, #11
005A96  980011     MOV W1, [W0+2]
3217:                                          _USB_SetBDT( USB_TOKEN_IN );
005A98  B3C090     MOV.B #0x9, W0
005A9A  07FF40     RCALL _USB_SetBDT
3218:                                          _USB_SendToken( pCurrentEndpoint->bEndpointAddress, USB_TOKEN_IN );
005A9C  807D70     MOV pCurrentEndpoint, W0
005A9E  905820     MOV.B [W0+26], W0
005AA0  B3C091     MOV.B #0x9, W1
005AA2  07FF20     RCALL _USB_SendToken
3219:                                          #ifdef ONE_CONTROL_TRANSACTION_PER_FRAME
3220:                                              usbBusInfo.flags.bfControlTransfersDone = 1; // Only one control transfer per frame.
005AA4  A80FB0     BSET usbBusInfo, #0
3221:                                          #endif
3222:                                          return;
005AA6  3703A2     BRA .L438
3223:                                          break;
3224:              
3225:                                      case TSUBSTATE_CONTROL_NO_DATA_COMPLETE:
3226:                                          pCurrentEndpoint->transferState               = TSTATE_IDLE;
005AA8  EB4080     CLR.B W1
005AAA  985801     MOV.B W1, [W0+24]
3227:                                          pCurrentEndpoint->status.bfTransferComplete   = 1;
005AAC  807D70     MOV pCurrentEndpoint, W0
005AAE  900090     MOV [W0+2], W1
005AB0  A09001     BSET W1, #9
005AB2  980011     MOV W1, [W0+2]
3228:                                          #if defined( USB_ENABLE_TRANSFER_EVENT )
3229:                                              if (StructQueueIsNotFull(&usbEventQueue, USB_EVENT_QUEUE_DEPTH))
005AB4  804BA0     MOV 0x974, W0
005AB6  500FE3     SUB W0, #0x3, [W15]
005AB8  3C0027     BRA GT, .L451, .LBE9
3230:                                              {
3231:                                                  USB_EVENT_DATA *data;
3232:              
3233:                                                  data = StructQueueAdd(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
005ABA  209741     MOV #0x974, W1
005ABC  E80880     INC W0, [W1]
005ABE  804B80     MOV usbEventQueue, W0
005AC0  500FE2     SUB W0, #0x2, [W15]
005AC2  3C0003     BRA GT, .L452
005AC4  5080E4     SUB W1, #0x4, W1
005AC6  E80880     INC W0, [W1]
005AC8  370002     BRA .L453
005ACA  209700     MOV #0x970, W0
005ACC  EB0800     CLR [W0]
005ACE  209702     MOV #0x970, W2
005AD0  780192     MOV [W2], W3
3234:                                                  data->event = EVENT_TRANSFER;
005AD2  B9186C     MUL.SU W3, #12, W0
005AD4  780080     MOV W0, W1
005AD6  410201     ADD W2, W1, W4
005AD8  200720     MOV #0x72, W0
005ADA  980230     MOV W0, [W4+6]
3235:                                                  data->TransferData.dataCount        = pCurrentEndpoint->dataCount;
005ADC  807D70     MOV pCurrentEndpoint, W0
005ADE  900B00     MOV [W0+16], W6
005AE0  900B90     MOV [W0+18], W7
005AE2  980246     MOV W6, [W4+8]
005AE4  980257     MOV W7, [W4+10]
3236:                                                  data->TransferData.pUserData        = pCurrentEndpoint->pUserData;
005AE6  E80183     INC W3, W3
005AE8  B91A6C     MUL.SU W3, #12, W4
005AEA  900BB0     MOV [W0+22], W7
005AEC  7A3107     MOV W7, [W2+W4]
3237:                                                  data->TransferData.bErrorCode       = USB_SUCCESS;
005AEE  41016E     ADD W2, #0xE, W2
005AF0  410101     ADD W2, W1, W2
005AF2  EB4180     CLR.B W3
005AF4  984113     MOV.B W3, [W2+1]
3238:                                                  data->TransferData.bEndpointAddress = pCurrentEndpoint->bEndpointAddress;
005AF6  9059A0     MOV.B [W0+26], W3
005AF8  784903     MOV.B W3, [W2]
3239:                                                  data->TransferData.bmAttributes.val = pCurrentEndpoint->bmAttributes.val;
005AFA  209802     MOV #0x980, W2
005AFC  410081     ADD W2, W1, W1
005AFE  905A30     MOV.B [W0+27], W4
005B00  784884     MOV.B W4, [W1]
3240:                                                  data->TransferData.clientDriver     = pCurrentEndpoint->clientDriver;
005B02  905810     MOV.B [W0+25], W0
005B04  984090     MOV.B W0, [W1+1]
005B06  370370     BRA .L454
3241:                                              }
3242:                                              else
3243:                                              {
3244:                                                  pCurrentEndpoint->bmAttributes.val = USB_EVENT_QUEUE_FULL;
005B08  B3C081     MOV.B #0x8, W1
005B0A  807D70     MOV pCurrentEndpoint, W0
005B0C  985831     MOV.B W1, [W0+27]
005B0E  37036C     BRA .L454
3245:                                              }
3246:                                          #endif
3247:                                  break;
3248:              
3249:                                      case TSUBSTATE_ERROR:
3250:                                          pCurrentEndpoint->transferState               = TSTATE_IDLE;
005B10  EB4080     CLR.B W1
005B12  985801     MOV.B W1, [W0+24]
3251:                                          pCurrentEndpoint->status.bfTransferComplete   = 1;
005B14  807D70     MOV pCurrentEndpoint, W0
005B16  900090     MOV [W0+2], W1
005B18  A09001     BSET W1, #9
005B1A  980011     MOV W1, [W0+2]
3252:                                          #if defined( USB_ENABLE_TRANSFER_EVENT )
3253:                                              if (StructQueueIsNotFull(&usbEventQueue, USB_EVENT_QUEUE_DEPTH))
005B1C  804BA0     MOV 0x974, W0
005B1E  500FE3     SUB W0, #0x3, [W15]
005B20  3C0026     BRA GT, .L455, .LBE10
3254:                                              {
3255:                                                  USB_EVENT_DATA *data;
3256:              
3257:                                                  data = StructQueueAdd(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
005B22  209741     MOV #0x974, W1
005B24  E80880     INC W0, [W1]
005B26  804B80     MOV usbEventQueue, W0
005B28  500FE2     SUB W0, #0x2, [W15]
005B2A  3C0003     BRA GT, .L456
005B2C  5080E4     SUB W1, #0x4, W1
005B2E  E80880     INC W0, [W1]
005B30  370002     BRA .L457
005B32  209700     MOV #0x970, W0
005B34  EB0800     CLR [W0]
005B36  209700     MOV #0x970, W0
005B38  780110     MOV [W0], W2
3258:                                                  data->event = EVENT_BUS_ERROR;
005B3A  B9126C     MUL.SU W2, #12, W4
005B3C  780084     MOV W4, W1
005B3E  400181     ADD W0, W1, W3
005B40  27FFF4     MOV #0x7FFF, W4
005B42  9801B4     MOV W4, [W3+6]
3259:                                                  data->TransferData.dataCount        = 0;
005B44  B83360     MUL.UU W6, #0, W6
005B46  9801C6     MOV W6, [W3+8]
005B48  9801D7     MOV W7, [W3+10]
3260:                                                  data->TransferData.pUserData        = NULL;
005B4A  E80102     INC W2, W2
005B4C  B9116C     MUL.SU W2, #12, W2
005B4E  400002     ADD W0, W2, W0
005B50  EB0800     CLR [W0]
3261:                                                  data->TransferData.bErrorCode       = pCurrentEndpoint->bErrorCode;
005B52  807D70     MOV pCurrentEndpoint, W0
005B54  2097E2     MOV #0x97E, W2
005B56  410101     ADD W2, W1, W2
005B58  905BC0     MOV.B [W0+28], W7
005B5A  984117     MOV.B W7, [W2+1]
3262:                                                  data->TransferData.bEndpointAddress = pCurrentEndpoint->bEndpointAddress;
005B5C  9059A0     MOV.B [W0+26], W3
005B5E  784903     MOV.B W3, [W2]
3263:                                                  data->TransferData.bmAttributes.val = pCurrentEndpoint->bmAttributes.val;
005B60  209802     MOV #0x980, W2
005B62  410081     ADD W2, W1, W1
005B64  905A30     MOV.B [W0+27], W4
005B66  784884     MOV.B W4, [W1]
3264:                                                  data->TransferData.clientDriver     = pCurrentEndpoint->clientDriver;
005B68  905810     MOV.B [W0+25], W0
005B6A  984090     MOV.B W0, [W1+1]
005B6C  37033D     BRA .L454
3265:                                              }
3266:                                              else
3267:                                              {
3268:                                                  pCurrentEndpoint->bmAttributes.val = USB_EVENT_QUEUE_FULL;
005B6E  B3C081     MOV.B #0x8, W1
005B70  807D70     MOV pCurrentEndpoint, W0
005B72  985831     MOV.B W1, [W0+27]
005B74  370339     BRA .L454
3269:                                              }
3270:                                          #endif
3271:                                          break;
3272:              
3273:                                      default:
3274:                                          illegalState = true;
3275:                                          break;
3276:                                  }
3277:                                  break;
3278:              
3279:                              case TSTATE_CONTROL_READ:
3280:                                  switch (pCurrentEndpoint->transferState & TSUBSTATE_MASK)
005B76  905880     MOV.B [W0+24], W1
005B78  6080EF     AND W1, #0xF, W1
005B7A  508FE2     SUB W1, #0x2, [W15]
005B7C  32001E     BRA Z, .L460
005B7E  3C0005     BRA GT, .L463
005B80  E00001     CP0 W1
005B82  320008     BRA Z, .L458
005B84  508FE1     SUB W1, #0x1, [W15]
005B86  3A0129     BRA NZ, .L442
005B88  370010     BRA .L552
005B8A  508FE3     SUB W1, #0x3, [W15]
005B8C  320026     BRA Z, .L461
005B8E  508FEF     SUB W1, #0xF, [W15]
005B90  3A0124     BRA NZ, .L442
005B92  370057     BRA .L553
3281:                                  {
3282:                                      case TSUBSTATE_CONTROL_READ_SETUP:
3283:                                          _USB_SetDATA01( DTS_DATA0 );
005B94  900090     MOV [W0+2], W1
005B96  A1B001     BCLR W1, #11
005B98  980011     MOV W1, [W0+2]
3284:                                          _USB_SetBDT( USB_TOKEN_SETUP );
005B9A  B3C0D0     MOV.B #0xD, W0
005B9C  07FEBF     RCALL _USB_SetBDT
3285:                                          _USB_SendToken( pCurrentEndpoint->bEndpointAddress, USB_TOKEN_SETUP );
005B9E  807D70     MOV pCurrentEndpoint, W0
005BA0  905820     MOV.B [W0+26], W0
005BA2  B3C0D1     MOV.B #0xD, W1
005BA4  07FE9F     RCALL _USB_SendToken
3286:                                          #ifdef ONE_CONTROL_TRANSACTION_PER_FRAME
3287:                                              usbBusInfo.flags.bfControlTransfersDone = 1; // Only one control transfer per frame.
005BA6  A80FB0     BSET usbBusInfo, #0
3288:                                          #endif
3289:                                          return;
005BA8  370321     BRA .L438
3290:                                          break;
3291:              
3292:                                      case TSUBSTATE_CONTROL_READ_DATA:
3293:                                          _USB_SetBDT( USB_TOKEN_IN );
005BAA  B3C090     MOV.B #0x9, W0
005BAC  07FEB7     RCALL _USB_SetBDT
3294:                                          _USB_SendToken( pCurrentEndpoint->bEndpointAddress, USB_TOKEN_IN );
005BAE  807D70     MOV pCurrentEndpoint, W0
005BB0  905820     MOV.B [W0+26], W0
005BB2  B3C091     MOV.B #0x9, W1
005BB4  07FE97     RCALL _USB_SendToken
3295:                                          #ifdef ONE_CONTROL_TRANSACTION_PER_FRAME
3296:                                              usbBusInfo.flags.bfControlTransfersDone = 1; // Only one control transfer per frame.
005BB6  A80FB0     BSET usbBusInfo, #0
3297:                                          #endif
3298:                                          return;
005BB8  370319     BRA .L438
3299:                                          break;
3300:              
3301:                                      case TSUBSTATE_CONTROL_READ_ACK:
3302:                                          pCurrentEndpoint->dataCountMax = pCurrentEndpoint->dataCount;
005BBA  900B00     MOV [W0+16], W6
005BBC  900B90     MOV [W0+18], W7
005BBE  980056     MOV W6, [W0+10]
005BC0  980067     MOV W7, [W0+12]
3303:                                          _USB_SetDATA01( DTS_DATA1 );
005BC2  807D70     MOV pCurrentEndpoint, W0
005BC4  900090     MOV [W0+2], W1
005BC6  A0B001     BSET W1, #11
005BC8  980011     MOV W1, [W0+2]
3304:                                          _USB_SetBDT( USB_TOKEN_OUT );
005BCA  B3C010     MOV.B #0x1, W0
005BCC  07FEA7     RCALL _USB_SetBDT
3305:                                          _USB_SendToken( pCurrentEndpoint->bEndpointAddress, USB_TOKEN_OUT );
005BCE  807D70     MOV pCurrentEndpoint, W0
005BD0  905820     MOV.B [W0+26], W0
005BD2  B3C011     MOV.B #0x1, W1
005BD4  07FE87     RCALL _USB_SendToken
3306:                                          #ifdef ONE_CONTROL_TRANSACTION_PER_FRAME
3307:                                              usbBusInfo.flags.bfControlTransfersDone = 1; // Only one control transfer per frame.
005BD6  A80FB0     BSET usbBusInfo, #0
3308:                                          #endif
3309:                                          return;
005BD8  370309     BRA .L438
3310:                                          break;
3311:              
3312:                                      case TSUBSTATE_CONTROL_READ_COMPLETE:
3313:                                          pCurrentEndpoint->transferState               = TSTATE_IDLE;
005BDA  EB4080     CLR.B W1
005BDC  985801     MOV.B W1, [W0+24]
3314:                                          pCurrentEndpoint->status.bfTransferComplete   = 1;
005BDE  807D70     MOV pCurrentEndpoint, W0
005BE0  900090     MOV [W0+2], W1
005BE2  A09001     BSET W1, #9
005BE4  980011     MOV W1, [W0+2]
3315:                                          #if defined( USB_ENABLE_TRANSFER_EVENT )
3316:                                              if (StructQueueIsNotFull(&usbEventQueue, USB_EVENT_QUEUE_DEPTH))
005BE6  804BA0     MOV 0x974, W0
005BE8  500FE3     SUB W0, #0x3, [W15]
005BEA  3C0027     BRA GT, .L464, .LBE11
3317:                                              {
3318:                                                  USB_EVENT_DATA *data;
3319:              
3320:                                                  data = StructQueueAdd(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
005BEC  209741     MOV #0x974, W1
005BEE  E80880     INC W0, [W1]
005BF0  804B80     MOV usbEventQueue, W0
005BF2  500FE2     SUB W0, #0x2, [W15]
005BF4  3C0003     BRA GT, .L465
005BF6  5080E4     SUB W1, #0x4, W1
005BF8  E80880     INC W0, [W1]
005BFA  370002     BRA .L466
005BFC  209700     MOV #0x970, W0
005BFE  EB0800     CLR [W0]
005C00  209702     MOV #0x970, W2
005C02  780192     MOV [W2], W3
3321:                                                  data->event = EVENT_TRANSFER;
005C04  B9186C     MUL.SU W3, #12, W0
005C06  780080     MOV W0, W1
005C08  410201     ADD W2, W1, W4
005C0A  200720     MOV #0x72, W0
005C0C  980230     MOV W0, [W4+6]
3322:                                                  data->TransferData.dataCount        = pCurrentEndpoint->dataCount;
005C0E  807D70     MOV pCurrentEndpoint, W0
005C10  900B00     MOV [W0+16], W6
005C12  900B90     MOV [W0+18], W7
005C14  980246     MOV W6, [W4+8]
005C16  980257     MOV W7, [W4+10]
3323:                                                  data->TransferData.pUserData        = pCurrentEndpoint->pUserData;
005C18  E80183     INC W3, W3
005C1A  B91A6C     MUL.SU W3, #12, W4
005C1C  900BB0     MOV [W0+22], W7
005C1E  7A3107     MOV W7, [W2+W4]
3324:                                                  data->TransferData.bErrorCode       = USB_SUCCESS;
005C20  41016E     ADD W2, #0xE, W2
005C22  410101     ADD W2, W1, W2
005C24  EB4180     CLR.B W3
005C26  984113     MOV.B W3, [W2+1]
3325:                                                  data->TransferData.bEndpointAddress = pCurrentEndpoint->bEndpointAddress;
005C28  9059A0     MOV.B [W0+26], W3
005C2A  784903     MOV.B W3, [W2]
3326:                                                  data->TransferData.bmAttributes.val = pCurrentEndpoint->bmAttributes.val;
005C2C  209802     MOV #0x980, W2
005C2E  410081     ADD W2, W1, W1
005C30  905A30     MOV.B [W0+27], W4
005C32  784884     MOV.B W4, [W1]
3327:                                                  data->TransferData.clientDriver     = pCurrentEndpoint->clientDriver;
005C34  905810     MOV.B [W0+25], W0
005C36  984090     MOV.B W0, [W1+1]
005C38  3702D7     BRA .L454
3328:                                              }
3329:                                              else
3330:                                              {
3331:                                                  pCurrentEndpoint->bmAttributes.val = USB_EVENT_QUEUE_FULL;
005C3A  B3C081     MOV.B #0x8, W1
005C3C  807D70     MOV pCurrentEndpoint, W0
005C3E  985831     MOV.B W1, [W0+27]
005C40  3702D3     BRA .L454
3332:                                              }
3333:                                          #endif
3334:                                          break;
3335:              
3336:                                      case TSUBSTATE_ERROR:
3337:                                          pCurrentEndpoint->transferState               = TSTATE_IDLE;
005C42  EB4080     CLR.B W1
005C44  985801     MOV.B W1, [W0+24]
3338:                                          pCurrentEndpoint->status.bfTransferComplete   = 1;
005C46  807D70     MOV pCurrentEndpoint, W0
005C48  900090     MOV [W0+2], W1
005C4A  A09001     BSET W1, #9
005C4C  980011     MOV W1, [W0+2]
3339:                                          #if defined( USB_ENABLE_TRANSFER_EVENT )
3340:                                              if (StructQueueIsNotFull(&usbEventQueue, USB_EVENT_QUEUE_DEPTH))
005C4E  804BA0     MOV 0x974, W0
005C50  500FE3     SUB W0, #0x3, [W15]
005C52  3C0026     BRA GT, .L467, .LBE12
3341:                                              {
3342:                                                  USB_EVENT_DATA *data;
3343:              
3344:                                                  data = StructQueueAdd(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
005C54  209741     MOV #0x974, W1
005C56  E80880     INC W0, [W1]
005C58  804B80     MOV usbEventQueue, W0
005C5A  500FE2     SUB W0, #0x2, [W15]
005C5C  3C0003     BRA GT, .L468
005C5E  5080E4     SUB W1, #0x4, W1
005C60  E80880     INC W0, [W1]
005C62  370002     BRA .L469
005C64  209700     MOV #0x970, W0
005C66  EB0800     CLR [W0]
005C68  209700     MOV #0x970, W0
005C6A  780110     MOV [W0], W2
3345:                                                  data->event = EVENT_BUS_ERROR;
005C6C  B9126C     MUL.SU W2, #12, W4
005C6E  780084     MOV W4, W1
005C70  400181     ADD W0, W1, W3
005C72  27FFF4     MOV #0x7FFF, W4
005C74  9801B4     MOV W4, [W3+6]
3346:                                                  data->TransferData.dataCount        = 0;
005C76  B83360     MUL.UU W6, #0, W6
005C78  9801C6     MOV W6, [W3+8]
005C7A  9801D7     MOV W7, [W3+10]
3347:                                                  data->TransferData.pUserData        = NULL;
005C7C  E80102     INC W2, W2
005C7E  B9116C     MUL.SU W2, #12, W2
005C80  400002     ADD W0, W2, W0
005C82  EB0800     CLR [W0]
3348:                                                  data->TransferData.bErrorCode       = pCurrentEndpoint->bErrorCode;
005C84  807D70     MOV pCurrentEndpoint, W0
005C86  2097E2     MOV #0x97E, W2
005C88  410101     ADD W2, W1, W2
005C8A  905BC0     MOV.B [W0+28], W7
005C8C  984117     MOV.B W7, [W2+1]
3349:                                                  data->TransferData.bEndpointAddress = pCurrentEndpoint->bEndpointAddress;
005C8E  9059A0     MOV.B [W0+26], W3
005C90  784903     MOV.B W3, [W2]
3350:                                                  data->TransferData.bmAttributes.val = pCurrentEndpoint->bmAttributes.val;
005C92  209802     MOV #0x980, W2
005C94  410081     ADD W2, W1, W1
005C96  905A30     MOV.B [W0+27], W4
005C98  784884     MOV.B W4, [W1]
3351:                                                  data->TransferData.clientDriver     = pCurrentEndpoint->clientDriver;
005C9A  905810     MOV.B [W0+25], W0
005C9C  984090     MOV.B W0, [W1+1]
005C9E  3702A4     BRA .L454
3352:                                              }
3353:                                              else
3354:                                              {
3355:                                                  pCurrentEndpoint->bmAttributes.val = USB_EVENT_QUEUE_FULL;
005CA0  B3C081     MOV.B #0x8, W1
005CA2  807D70     MOV pCurrentEndpoint, W0
005CA4  985831     MOV.B W1, [W0+27]
005CA6  3702A0     BRA .L454
3356:                                              }
3357:                                          #endif
3358:                                          break;
3359:              
3360:                                      default:
3361:                                          illegalState = true;
3362:                                          break;
3363:                                  }
3364:                                  break;
3365:              
3366:                              case TSTATE_CONTROL_WRITE:
3367:                                  switch (pCurrentEndpoint->transferState & TSUBSTATE_MASK)
005CA8  905880     MOV.B [W0+24], W1
005CAA  6080EF     AND W1, #0xF, W1
005CAC  508FE2     SUB W1, #0x2, [W15]
005CAE  32001E     BRA Z, .L472
005CB0  3C0005     BRA GT, .L475
005CB2  E00001     CP0 W1
005CB4  320008     BRA Z, .L470
005CB6  508FE1     SUB W1, #0x1, [W15]
005CB8  3A0090     BRA NZ, .L442
005CBA  370010     BRA .L554
005CBC  508FE3     SUB W1, #0x3, [W15]
005CBE  320026     BRA Z, .L473
005CC0  508FEF     SUB W1, #0xF, [W15]
005CC2  3A008B     BRA NZ, .L442
005CC4  370057     BRA .L555
3368:                                  {
3369:                                      case TSUBSTATE_CONTROL_WRITE_SETUP:
3370:                                          _USB_SetDATA01( DTS_DATA0 );
005CC6  900090     MOV [W0+2], W1
005CC8  A1B001     BCLR W1, #11
005CCA  980011     MOV W1, [W0+2]
3371:                                          _USB_SetBDT( USB_TOKEN_SETUP );
005CCC  B3C0D0     MOV.B #0xD, W0
005CCE  07FE26     RCALL _USB_SetBDT
3372:                                          _USB_SendToken( pCurrentEndpoint->bEndpointAddress, USB_TOKEN_SETUP );
005CD0  807D70     MOV pCurrentEndpoint, W0
005CD2  905820     MOV.B [W0+26], W0
005CD4  B3C0D1     MOV.B #0xD, W1
005CD6  07FE06     RCALL _USB_SendToken
3373:                                          #ifdef ONE_CONTROL_TRANSACTION_PER_FRAME
3374:                                              usbBusInfo.flags.bfControlTransfersDone = 1; // Only one control transfer per frame.
005CD8  A80FB0     BSET usbBusInfo, #0
3375:                                          #endif
3376:                                          return;
005CDA  370288     BRA .L438
3377:                                          break;
3378:              
3379:                                      case TSUBSTATE_CONTROL_WRITE_DATA:
3380:                                          _USB_SetBDT( USB_TOKEN_OUT );
005CDC  B3C010     MOV.B #0x1, W0
005CDE  07FE1E     RCALL _USB_SetBDT
3381:                                          _USB_SendToken( pCurrentEndpoint->bEndpointAddress, USB_TOKEN_OUT );
005CE0  807D70     MOV pCurrentEndpoint, W0
005CE2  905820     MOV.B [W0+26], W0
005CE4  B3C011     MOV.B #0x1, W1
005CE6  07FDFE     RCALL _USB_SendToken
3382:                                          #ifdef ONE_CONTROL_TRANSACTION_PER_FRAME
3383:                                              usbBusInfo.flags.bfControlTransfersDone = 1; // Only one control transfer per frame.
005CE8  A80FB0     BSET usbBusInfo, #0
3384:                                          #endif
3385:                                          return;
005CEA  370280     BRA .L438
3386:                                          break;
3387:              
3388:                                      case TSUBSTATE_CONTROL_WRITE_ACK:
3389:                                          pCurrentEndpoint->dataCountMax = pCurrentEndpoint->dataCount;
005CEC  900B00     MOV [W0+16], W6
005CEE  900B90     MOV [W0+18], W7
005CF0  980056     MOV W6, [W0+10]
005CF2  980067     MOV W7, [W0+12]
3390:                                          _USB_SetDATA01( DTS_DATA1 );
005CF4  807D70     MOV pCurrentEndpoint, W0
005CF6  900090     MOV [W0+2], W1
005CF8  A0B001     BSET W1, #11
005CFA  980011     MOV W1, [W0+2]
3391:                                          _USB_SetBDT( USB_TOKEN_IN );
005CFC  B3C090     MOV.B #0x9, W0
005CFE  07FE0E     RCALL _USB_SetBDT
3392:                                          _USB_SendToken( pCurrentEndpoint->bEndpointAddress, USB_TOKEN_IN );
005D00  807D70     MOV pCurrentEndpoint, W0
005D02  905820     MOV.B [W0+26], W0
005D04  B3C091     MOV.B #0x9, W1
005D06  07FDEE     RCALL _USB_SendToken
3393:                                          #ifdef ONE_CONTROL_TRANSACTION_PER_FRAME
3394:                                              usbBusInfo.flags.bfControlTransfersDone = 1; // Only one control transfer per frame.
005D08  A80FB0     BSET usbBusInfo, #0
3395:                                          #endif
3396:                                          return;
005D0A  370270     BRA .L438
3397:                                          break;
3398:              
3399:                                      case TSUBSTATE_CONTROL_WRITE_COMPLETE:
3400:                                          pCurrentEndpoint->transferState               = TSTATE_IDLE;
005D0C  EB4080     CLR.B W1
005D0E  985801     MOV.B W1, [W0+24]
3401:                                          pCurrentEndpoint->status.bfTransferComplete   = 1;
005D10  807D70     MOV pCurrentEndpoint, W0
005D12  900090     MOV [W0+2], W1
005D14  A09001     BSET W1, #9
005D16  980011     MOV W1, [W0+2]
3402:                                          #if defined( USB_ENABLE_TRANSFER_EVENT )
3403:                                              if (StructQueueIsNotFull(&usbEventQueue, USB_EVENT_QUEUE_DEPTH))
005D18  804BA0     MOV 0x974, W0
005D1A  500FE3     SUB W0, #0x3, [W15]
005D1C  3C0027     BRA GT, .L476, .LBE13
3404:                                              {
3405:                                                  USB_EVENT_DATA *data;
3406:              
3407:                                                  data = StructQueueAdd(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
005D1E  209741     MOV #0x974, W1
005D20  E80880     INC W0, [W1]
005D22  804B80     MOV usbEventQueue, W0
005D24  500FE2     SUB W0, #0x2, [W15]
005D26  3C0003     BRA GT, .L477
005D28  5080E4     SUB W1, #0x4, W1
005D2A  E80880     INC W0, [W1]
005D2C  370002     BRA .L478
005D2E  209700     MOV #0x970, W0
005D30  EB0800     CLR [W0]
005D32  209702     MOV #0x970, W2
005D34  780192     MOV [W2], W3
3408:                                                  data->event = EVENT_TRANSFER;
005D36  B9186C     MUL.SU W3, #12, W0
005D38  780080     MOV W0, W1
005D3A  410201     ADD W2, W1, W4
005D3C  200720     MOV #0x72, W0
005D3E  980230     MOV W0, [W4+6]
3409:                                                  data->TransferData.dataCount        = pCurrentEndpoint->dataCount;
005D40  807D70     MOV pCurrentEndpoint, W0
005D42  900B00     MOV [W0+16], W6
005D44  900B90     MOV [W0+18], W7
005D46  980246     MOV W6, [W4+8]
005D48  980257     MOV W7, [W4+10]
3410:                                                  data->TransferData.pUserData        = pCurrentEndpoint->pUserData;
005D4A  E80183     INC W3, W3
005D4C  B91A6C     MUL.SU W3, #12, W4
005D4E  900BB0     MOV [W0+22], W7
005D50  7A3107     MOV W7, [W2+W4]
3411:                                                  data->TransferData.bErrorCode       = USB_SUCCESS;
005D52  41016E     ADD W2, #0xE, W2
005D54  410101     ADD W2, W1, W2
005D56  EB4180     CLR.B W3
005D58  984113     MOV.B W3, [W2+1]
3412:                                                  data->TransferData.bEndpointAddress = pCurrentEndpoint->bEndpointAddress;
005D5A  9059A0     MOV.B [W0+26], W3
005D5C  784903     MOV.B W3, [W2]
3413:                                                  data->TransferData.bmAttributes.val = pCurrentEndpoint->bmAttributes.val;
005D5E  209802     MOV #0x980, W2
005D60  410081     ADD W2, W1, W1
005D62  905A30     MOV.B [W0+27], W4
005D64  784884     MOV.B W4, [W1]
3414:                                                  data->TransferData.clientDriver     = pCurrentEndpoint->clientDriver;
005D66  905810     MOV.B [W0+25], W0
005D68  984090     MOV.B W0, [W1+1]
005D6A  37023E     BRA .L454
3415:                                              }
3416:                                              else
3417:                                              {
3418:                                                  pCurrentEndpoint->bmAttributes.val = USB_EVENT_QUEUE_FULL;
005D6C  B3C081     MOV.B #0x8, W1
005D6E  807D70     MOV pCurrentEndpoint, W0
005D70  985831     MOV.B W1, [W0+27]
005D72  37023A     BRA .L454
3419:                                              }
3420:                                          #endif
3421:                                          break;
3422:              
3423:                                      case TSUBSTATE_ERROR:
3424:                                          pCurrentEndpoint->transferState               = TSTATE_IDLE;
005D74  EB4080     CLR.B W1
005D76  985801     MOV.B W1, [W0+24]
3425:                                          pCurrentEndpoint->status.bfTransferComplete   = 1;
005D78  807D70     MOV pCurrentEndpoint, W0
005D7A  900090     MOV [W0+2], W1
005D7C  A09001     BSET W1, #9
005D7E  980011     MOV W1, [W0+2]
3426:                                          #if defined( USB_ENABLE_TRANSFER_EVENT )
3427:                                              if (StructQueueIsNotFull(&usbEventQueue, USB_EVENT_QUEUE_DEPTH))
005D80  804BA0     MOV 0x974, W0
005D82  500FE3     SUB W0, #0x3, [W15]
005D84  3C0026     BRA GT, .L479, .LBE14
3428:                                              {
3429:                                                  USB_EVENT_DATA *data;
3430:              
3431:                                                  data = StructQueueAdd(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
005D86  209741     MOV #0x974, W1
005D88  E80880     INC W0, [W1]
005D8A  804B80     MOV usbEventQueue, W0
005D8C  500FE2     SUB W0, #0x2, [W15]
005D8E  3C0003     BRA GT, .L480
005D90  5080E4     SUB W1, #0x4, W1
005D92  E80880     INC W0, [W1]
005D94  370002     BRA .L481
005D96  209700     MOV #0x970, W0
005D98  EB0800     CLR [W0]
005D9A  209700     MOV #0x970, W0
005D9C  780110     MOV [W0], W2
3432:                                                  data->event = EVENT_BUS_ERROR;
005D9E  B9126C     MUL.SU W2, #12, W4
005DA0  780084     MOV W4, W1
005DA2  400181     ADD W0, W1, W3
005DA4  27FFF4     MOV #0x7FFF, W4
005DA6  9801B4     MOV W4, [W3+6]
3433:                                                  data->TransferData.dataCount        = 0;
005DA8  B83360     MUL.UU W6, #0, W6
005DAA  9801C6     MOV W6, [W3+8]
005DAC  9801D7     MOV W7, [W3+10]
3434:                                                  data->TransferData.pUserData        = NULL;
005DAE  E80102     INC W2, W2
005DB0  B9116C     MUL.SU W2, #12, W2
005DB2  400002     ADD W0, W2, W0
005DB4  EB0800     CLR [W0]
3435:                                                  data->TransferData.bErrorCode       = pCurrentEndpoint->bErrorCode;
005DB6  807D70     MOV pCurrentEndpoint, W0
005DB8  2097E2     MOV #0x97E, W2
005DBA  410101     ADD W2, W1, W2
005DBC  905BC0     MOV.B [W0+28], W7
005DBE  984117     MOV.B W7, [W2+1]
3436:                                                  data->TransferData.bEndpointAddress = pCurrentEndpoint->bEndpointAddress;
005DC0  9059A0     MOV.B [W0+26], W3
005DC2  784903     MOV.B W3, [W2]
3437:                                                  data->TransferData.bmAttributes.val = pCurrentEndpoint->bmAttributes.val;
005DC4  209802     MOV #0x980, W2
005DC6  410081     ADD W2, W1, W1
005DC8  905A30     MOV.B [W0+27], W4
005DCA  784884     MOV.B W4, [W1]
3438:                                                  data->TransferData.clientDriver     = pCurrentEndpoint->clientDriver;
005DCC  905810     MOV.B [W0+25], W0
005DCE  984090     MOV.B W0, [W1+1]
005DD0  37020B     BRA .L454
3439:                                              }
3440:                                              else
3441:                                              {
3442:                                                  pCurrentEndpoint->bmAttributes.val = USB_EVENT_QUEUE_FULL;
005DD2  B3C081     MOV.B #0x8, W1
005DD4  807D70     MOV pCurrentEndpoint, W0
005DD6  985831     MOV.B W1, [W0+27]
005DD8  370207     BRA .L454
3443:                                              }
3444:                                          #endif
3445:                                          break;
3446:              
3447:                                      default:
3448:                                          illegalState = true;
3449:                                          break;
3450:                                  }
3451:                                  break;
3452:              
3453:                              default:
3454:                                  illegalState = true;
3455:                          }
3456:              
3457:                          if (illegalState)
3458:                          {
3459:                              // We should never use this, but in case we do, put the endpoint
3460:                              // in a recoverable state.
3461:                              pCurrentEndpoint->transferState               = TSTATE_IDLE;
005DDA  EB4080     CLR.B W1
005DDC  985801     MOV.B W1, [W0+24]
3462:                              pCurrentEndpoint->status.bfTransferComplete   = 1;
005DDE  807D70     MOV pCurrentEndpoint, W0
005DE0  900090     MOV [W0+2], W1
005DE2  A09001     BSET W1, #9
005DE4  980011     MOV W1, [W0+2]
005DE6  B3C018     MOV.B #0x1, W8
3463:                          }
3464:                      }
3465:              
3466:                      // If we've gone through all the endpoints, we do not have any more control transfers.
3467:                      usbBusInfo.flags.bfControlTransfersDone = 1;
005DE8  A80FB0     BSET usbBusInfo, #0
3468:                  }
3469:              
3470:                  #ifdef USB_SUPPORT_ISOCHRONOUS_TRANSFERS
3471:                      // Next, we will handle isochronous transfers.  We must be careful with
3472:                      // these.  The maximum packet size for an isochronous transfer is 1023
3473:                      // bytes, so we cannot use the threshold register (U1SOF) to ensure that
3474:                      // we do not write too many tokens during a frame.  Instead, we must count
3475:                      // the number of bytes we are sending and stop sending isochronous
3476:                      // transfers when we reach that limit.
3477:              
3478:                      // MCHP: Implement scheduling by using usbBusInfo.dBytesSentInFrame
3479:              
3480:                      // Current Limitation:  The stack currently supports only one attached
3481:                      // device.  We will make the assumption that the control, isochronous, and
3482:                      // interrupt transfers requested by a single device will not exceed one
3483:                      // frame, and defer the scheduler.
3484:              
3485:                      // Due to the nature of isochronous transfers, transfer events must be used.
3486:                      #if !defined( USB_ENABLE_TRANSFER_EVENT )
3487:                          #error Transfer events are required for isochronous transfers
3488:                      #endif
3489:              
3490:                      if (!usbBusInfo.flags.bfIsochronousTransfersDone)
3491:                      {
3492:                          // Look for any isochronous operations.
3493:                          while (_USB_FindServiceEndpoint( USB_TRANSFER_TYPE_ISOCHRONOUS ))
3494:                          {
3495:                              switch (pCurrentEndpoint->transferState & TSTATE_MASK)
3496:                              {
3497:                                  case TSTATE_ISOCHRONOUS_READ:
3498:                                      switch (pCurrentEndpoint->transferState & TSUBSTATE_MASK)
3499:                                      {
3500:                                          case TSUBSTATE_ISOCHRONOUS_READ_DATA:
3501:                                              // Don't overwrite data the user has not yet processed.  We will skip this interval.
3502:                                              if (((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->buffers[((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->currentBufferUSB].bfDataLengthValid)
3503:                                              {
3504:                                                  // We have buffer overflow.
3505:                                              }
3506:                                              else
3507:                                              {
3508:                                                  // Initialize the data buffer.
3509:                                                  ((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->buffers[((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->currentBufferUSB].bfDataLengthValid = 0;
3510:                                                  pCurrentEndpoint->dataCount = 0;
3511:              
3512:                                                  _USB_SetDATA01( DTS_DATA0 );    // Always DATA0 for isochronous
3513:                                                  _USB_SetBDT( USB_TOKEN_IN );
3514:                                                  _USB_SendToken( pCurrentEndpoint->bEndpointAddress, USB_TOKEN_IN );
3515:                                                  return;
3516:                                              }
3517:                                              break;
3518:              
3519:                                          case TSUBSTATE_ISOCHRONOUS_READ_COMPLETE:
3520:                                              // Isochronous transfers are continuous until the user stops them.
3521:                                              // Send an event that there is new data, and reset for the next
3522:                                              // interval.
3523:                                              pCurrentEndpoint->transferState     = TSTATE_ISOCHRONOUS_READ | TSUBSTATE_ISOCHRONOUS_READ_DATA;
3524:                                              pCurrentEndpoint->wIntervalCount    = pCurrentEndpoint->wInterval;
3525:              
3526:                                              // Update the valid data length for this buffer.
3527:                                              ((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->buffers[((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->currentBufferUSB].dataLength = pCurrentEndpoint->dataCount;
3528:                                              ((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->buffers[((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->currentBufferUSB].bfDataLengthValid = 1;
3529:                                              #if defined( USB_ENABLE_ISOC_TRANSFER_EVENT )
3530:                                                  if (StructQueueIsNotFull(&usbEventQueue, USB_EVENT_QUEUE_DEPTH))
3531:                                                  {
3532:                                                      USB_EVENT_DATA *data;
3533:              
3534:                                                      data = StructQueueAdd(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
3535:                                                      data->event = EVENT_TRANSFER;
3536:                                                      data->TransferData.dataCount        = pCurrentEndpoint->dataCount;
3537:                                                      data->TransferData.pUserData        = ((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->buffers[((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->currentBufferUSB].pBuffer;
3538:                                                      data->TransferData.bErrorCode       = USB_SUCCESS;
3539:                                                      data->TransferData.bEndpointAddress = pCurrentEndpoint->bEndpointAddress;
3540:                                                      data->TransferData.bmAttributes.val = pCurrentEndpoint->bmAttributes.val;
3541:                                                      data->TransferData.clientDriver     = pCurrentEndpoint->clientDriver;
3542:                                                  }
3543:                                                  else
3544:                                                  {
3545:                                                      pCurrentEndpoint->bmAttributes.val = USB_EVENT_QUEUE_FULL;
3546:                                                  }
3547:                                              #endif
3548:              
3549:                                              // If the user wants an event from the interrupt handler to handle the data as quickly as
3550:                                              // possible, send up the event.  Then mark the packet as used.
3551:                                              #ifdef USB_HOST_APP_DATA_EVENT_HANDLER
3552:                                                  if(usbClientDrvTable[pCurrentEndpoint->clientDriver].DataEventHandler != NULL)
3553:                                                  {
3554:                                                      usbClientDrvTable[pCurrentEndpoint->clientDriver].DataEventHandler( usbDeviceInfo.deviceAddress, EVENT_DATA_ISOC_READ, ((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->buffers[((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->currentBufferUSB].pBuffer, pCurrentEndpoint->dataCount );
3555:                                                  }
3556:                                                  ((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->buffers[((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->currentBufferUSB].bfDataLengthValid = 0;
3557:                                              #endif
3558:              
3559:                                              // Move to the next data buffer.
3560:                                              ((ISOCHRONOUS_DATA *)pCurrentEndpoint->pUserData)->currentBufferUSB++;
3561:                                              if (((ISOCHRONOUS_DATA *)pCurrentEndpoint->pUserData)->currentBufferUSB >= ((ISOCHRONOUS_DATA *)pCurrentEndpoint->pUserData)->totalBuffers)
3562:                                              {
3563:                                                  ((ISOCHRONOUS_DATA *)pCurrentEndpoint->pUserData)->currentBufferUSB = 0;
3564:                                              }
3565:                                              break;
3566:              
3567:                                          case TSUBSTATE_ERROR:
3568:                                              // Isochronous transfers are continuous until the user stops them.
3569:                                              // Send an event that there is an error, and reset for the next
3570:                                              // interval.
3571:                                              pCurrentEndpoint->transferState     = TSTATE_ISOCHRONOUS_READ | TSUBSTATE_ISOCHRONOUS_READ_DATA;
3572:                                              pCurrentEndpoint->wIntervalCount    = pCurrentEndpoint->wInterval;
3573:                                              #if defined( USB_ENABLE_TRANSFER_EVENT )
3574:                                                  if (StructQueueIsNotFull(&usbEventQueue, USB_EVENT_QUEUE_DEPTH))
3575:                                                  {
3576:                                                      USB_EVENT_DATA *data;
3577:              
3578:                                                      data = StructQueueAdd(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
3579:                                                      data->event = EVENT_BUS_ERROR;
3580:                                                      data->TransferData.dataCount        = 0;
3581:                                                      data->TransferData.pUserData        = NULL;
3582:                                                      data->TransferData.bEndpointAddress = pCurrentEndpoint->bEndpointAddress;
3583:                                                      data->TransferData.bErrorCode       = pCurrentEndpoint->bErrorCode;
3584:                                                      data->TransferData.bmAttributes.val = pCurrentEndpoint->bmAttributes.val;
3585:                                                  }
3586:                                                  else
3587:                                                  {
3588:                                                      pCurrentEndpoint->bmAttributes.val = USB_EVENT_QUEUE_FULL;
3589:                                                  }
3590:                                              #endif
3591:                                              break;
3592:              
3593:                                          default:
3594:                                              illegalState = true;
3595:                                              break;
3596:                                      }
3597:                                      break;
3598:              
3599:                                  case TSTATE_ISOCHRONOUS_WRITE:
3600:                                      switch (pCurrentEndpoint->transferState & TSUBSTATE_MASK)
3601:                                      {
3602:                                          case TSUBSTATE_ISOCHRONOUS_WRITE_DATA:
3603:                                              if (!((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->buffers[((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->currentBufferUSB].bfDataLengthValid)
3604:                                              {
3605:                                                  // We have buffer underrun.
3606:                                              }
3607:                                              else
3608:                                              {
3609:                                                  pCurrentEndpoint->dataCount = ((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->buffers[((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->currentBufferUSB].dataLength;
3610:              
3611:                                                  _USB_SetDATA01( DTS_DATA0 );    // Always DATA0 for isochronous
3612:                                                  _USB_SetBDT( USB_TOKEN_OUT );
3613:                                                  _USB_SendToken( pCurrentEndpoint->bEndpointAddress, USB_TOKEN_OUT );
3614:                                                  return;
3615:                                              }
3616:                                              break;
3617:              
3618:                                          case TSUBSTATE_ISOCHRONOUS_WRITE_COMPLETE:
3619:                                              // Isochronous transfers are continuous until the user stops them.
3620:                                              // Send an event that data has been sent, and reset for the next
3621:                                              // interval.
3622:                                              pCurrentEndpoint->wIntervalCount    = pCurrentEndpoint->wInterval;
3623:                                              pCurrentEndpoint->transferState     = TSTATE_ISOCHRONOUS_WRITE | TSUBSTATE_ISOCHRONOUS_WRITE_DATA;
3624:              
3625:                                              // Update the valid data length for this buffer.
3626:                                              ((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->buffers[((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->currentBufferUSB].bfDataLengthValid = 0;
3627:                                              #if defined( USB_ENABLE_ISOC_TRANSFER_EVENT )
3628:                                                  if (StructQueueIsNotFull(&usbEventQueue, USB_EVENT_QUEUE_DEPTH))
3629:                                                  {
3630:                                                      USB_EVENT_DATA *data;
3631:              
3632:                                                      data = StructQueueAdd(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
3633:                                                      data->event = EVENT_TRANSFER;
3634:                                                      data->TransferData.dataCount        = pCurrentEndpoint->dataCount;
3635:                                                      data->TransferData.pUserData        = ((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->buffers[((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->currentBufferUSB].pBuffer;
3636:                                                      data->TransferData.bErrorCode       = USB_SUCCESS;
3637:                                                      data->TransferData.bEndpointAddress = pCurrentEndpoint->bEndpointAddress;
3638:                                                      data->TransferData.bmAttributes.val = pCurrentEndpoint->bmAttributes.val;
3639:                                                      data->TransferData.clientDriver     = pCurrentEndpoint->clientDriver;
3640:                                                  }
3641:                                                  else
3642:                                                  {
3643:                                                      pCurrentEndpoint->bmAttributes.val = USB_EVENT_QUEUE_FULL;
3644:                                                  }
3645:                                              #endif
3646:              
3647:                                              // If the user wants an event from the interrupt handler to handle the data as quickly as
3648:                                              // possible, send up the event.
3649:                                              #ifdef USB_HOST_APP_DATA_EVENT_HANDLER
3650:                                              if(usbClientDrvTable[pCurrentEndpoint->clientDriver].DataEventHandler != NULL)
3651:                                              {
3652:                                                  usbClientDrvTable[pCurrentEndpoint->clientDriver].DataEventHandler( usbDeviceInfo.deviceAddress, EVENT_DATA_ISOC_WRITE, ((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->buffers[((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->currentBufferUSB].pBuffer, pCurrentEndpoint->dataCount );
3653:                                              }
3654:                                              #endif
3655:              
3656:                                              // Move to the next data buffer.
3657:                                              ((ISOCHRONOUS_DATA *)pCurrentEndpoint->pUserData)->currentBufferUSB++;
3658:                                              if (((ISOCHRONOUS_DATA *)pCurrentEndpoint->pUserData)->currentBufferUSB >= ((ISOCHRONOUS_DATA *)pCurrentEndpoint->pUserData)->totalBuffers)
3659:                                              {
3660:                                                  ((ISOCHRONOUS_DATA *)pCurrentEndpoint->pUserData)->currentBufferUSB = 0;
3661:                                              }
3662:              								((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->buffers[((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->currentBufferUSB].bfDataLengthValid = 1;
3663:                                              break;
3664:              
3665:                                          case TSUBSTATE_ERROR:
3666:                                              // Isochronous transfers are continuous until the user stops them.
3667:                                              // Send an event that there is an error, and reset for the next
3668:                                              // interval.
3669:                                              pCurrentEndpoint->transferState     = TSTATE_ISOCHRONOUS_WRITE | TSUBSTATE_ISOCHRONOUS_WRITE_DATA;
3670:                                              pCurrentEndpoint->wIntervalCount    = pCurrentEndpoint->wInterval;
3671:              
3672:                                              #if defined( USB_ENABLE_TRANSFER_EVENT )
3673:                                                  if (StructQueueIsNotFull(&usbEventQueue, USB_EVENT_QUEUE_DEPTH))
3674:                                                  {
3675:                                                      USB_EVENT_DATA *data;
3676:              
3677:                                                      data = StructQueueAdd(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
3678:                                                      data->event = EVENT_BUS_ERROR;
3679:                                                      data->TransferData.dataCount        = 0;
3680:                                                      data->TransferData.pUserData        = NULL;
3681:                                                      data->TransferData.bErrorCode       = pCurrentEndpoint->bErrorCode;
3682:                                                      data->TransferData.bEndpointAddress = pCurrentEndpoint->bEndpointAddress;
3683:                                                      data->TransferData.bmAttributes.val = pCurrentEndpoint->bmAttributes.val;
3684:                                                      data->TransferData.clientDriver     = pCurrentEndpoint->clientDriver;
3685:                                                  }
3686:                                                  else
3687:                                                  {
3688:                                                      pCurrentEndpoint->bmAttributes.val = USB_EVENT_QUEUE_FULL;
3689:                                                  }
3690:                                              #endif
3691:                                              break;
3692:              
3693:                                          default:
3694:                                              illegalState = true;
3695:                                              break;
3696:                                      }
3697:                                      break;
3698:              
3699:                                  default:
3700:                                      illegalState = true;
3701:                                      break;
3702:                              }
3703:              
3704:                              if (illegalState)
3705:                              {
3706:                                  // We should never use this, but in case we do, put the endpoint
3707:                                  // in a recoverable state.
3708:                                  pCurrentEndpoint->transferState             = TSTATE_IDLE;
3709:                                  pCurrentEndpoint->wIntervalCount            = pCurrentEndpoint->wInterval;
3710:                                  pCurrentEndpoint->status.bfTransferComplete = 1;
3711:                              }
3712:                          }
3713:              
3714:                          // If we've gone through all the endpoints, we do not have any more isochronous transfers.
3715:                          usbBusInfo.flags.bfIsochronousTransfersDone = 1;
3716:                      }
3717:                  #endif
3718:              
3719:                  #ifdef USB_SUPPORT_INTERRUPT_TRANSFERS
3720:                      if (!usbBusInfo.flags.bfInterruptTransfersDone)
005DEA  AB2FB0     BTST usbBusInfo, #1
005DEC  3200F6     BRA Z, .L540
005DEE  3700FF     BRA .L483
3721:                      {
3722:                          // Look for any interrupt operations.
3723:                          while (_USB_FindServiceEndpoint( USB_TRANSFER_TYPE_INTERRUPT ))
005FE4  B3C030     MOV.B #0x3, W0
005FE6  07F3DE     RCALL _USB_FindServiceEndpoint
005FE8  E00400     CP0.B W0
005FEA  3AFF02     BRA NZ, .L506
3724:                          {
3725:                              switch (pCurrentEndpoint->transferState & TSTATE_MASK)
005DF0  807D70     MOV pCurrentEndpoint, W0
005DF2  905880     MOV.B [W0+24], W1
005DF4  B20F01     AND #0xF0, W1
005DF6  200402     MOV #0x40, W2
005DF8  508F82     SUB W1, W2, [W15]
005DFA  320004     BRA Z, .L485
005DFC  410170     ADD W2, #0x10, W2
005DFE  508F82     SUB W1, W2, [W15]
005E00  3A00DB     BRA NZ, .L545
005E02  37006D     BRA .L556
3726:                              {
3727:                                  case TSTATE_INTERRUPT_READ:
3728:                                      switch (pCurrentEndpoint->transferState & TSUBSTATE_MASK)
005E04  905880     MOV.B [W0+24], W1
005E06  6080EF     AND W1, #0xF, W1
005E08  508FE1     SUB W1, #0x1, [W15]
005E0A  32000B     BRA Z, .L488
005E0C  508FEF     SUB W1, #0xF, [W15]
005E0E  320039     BRA Z, .L489
005E10  E00001     CP0 W1
005E12  3A00D4     BRA NZ, .L546
3729:                                      {
3730:                                          case TSUBSTATE_INTERRUPT_READ_DATA:
3731:                                              _USB_SetBDT( USB_TOKEN_IN );
005E14  B3C090     MOV.B #0x9, W0
005E16  07FD82     RCALL _USB_SetBDT
3732:                                              _USB_SendToken( pCurrentEndpoint->bEndpointAddress, USB_TOKEN_IN );
005E18  807D70     MOV pCurrentEndpoint, W0
005E1A  905820     MOV.B [W0+26], W0
005E1C  B3C091     MOV.B #0x9, W1
005E1E  07FD62     RCALL _USB_SendToken
3733:                                              return;
005E20  3701E5     BRA .L438
3734:                                              break;
3735:              
3736:                                          case TSUBSTATE_INTERRUPT_READ_COMPLETE:
3737:                                              pCurrentEndpoint->transferState             = TSTATE_IDLE;
005E22  EB4080     CLR.B W1
005E24  985801     MOV.B W1, [W0+24]
3738:                                              pCurrentEndpoint->wIntervalCount            = pCurrentEndpoint->wInterval;
005E26  807D70     MOV pCurrentEndpoint, W0
005E28  9002A0     MOV [W0+4], W5
005E2A  980035     MOV W5, [W0+6]
3739:                                              pCurrentEndpoint->status.bfTransferComplete = 1;
005E2C  900090     MOV [W0+2], W1
005E2E  A09001     BSET W1, #9
005E30  980011     MOV W1, [W0+2]
3740:                                              #if defined( USB_ENABLE_TRANSFER_EVENT )
3741:                                                  if (StructQueueIsNotFull(&usbEventQueue, USB_EVENT_QUEUE_DEPTH))
005E32  78001A     MOV [W10], W0
005E34  500FE3     SUB W0, #0x3, [W15]
005E36  3C0021     BRA GT, .L490, .LBE15
005FDA  20974A     MOV #0x974, W10
3742:                                                  {
3743:                                                      USB_EVENT_DATA *data;
3744:              
3745:                                                      data = StructQueueAdd(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
005E38  E80D00     INC W0, [W10]
005E3A  780019     MOV [W9], W0
005E3C  500FE2     SUB W0, #0x2, [W15]
005E3E  3C0002     BRA GT, .L491
005E40  E80C80     INC W0, [W9]
005E42  370001     BRA .L492
005E44  EB0C80     CLR [W9]
005E46  780119     MOV [W9], W2
005FDC  5504E4     SUB W10, #0x4, W9
3746:                                                      data->event = EVENT_TRANSFER;
005E48  B9106C     MUL.SU W2, #12, W0
005E4A  780080     MOV W0, W1
005E4C  448181     ADD W9, W1, W3
005E4E  200720     MOV #0x72, W0
005E50  9801B0     MOV W0, [W3+6]
3747:                                                      data->TransferData.dataCount        = pCurrentEndpoint->dataCount;
005E52  807D70     MOV pCurrentEndpoint, W0
005E54  900B00     MOV [W0+16], W6
005E56  900B90     MOV [W0+18], W7
005E58  9801C6     MOV W6, [W3+8]
005E5A  9801D7     MOV W7, [W3+10]
3748:                                                      data->TransferData.pUserData        = pCurrentEndpoint->pUserData;
005E5C  E80102     INC W2, W2
005E5E  B9116C     MUL.SU W2, #12, W2
005E60  900BB0     MOV [W0+22], W7
005E62  793487     MOV W7, [W9+W2]
3749:                                                      data->TransferData.bErrorCode       = USB_SUCCESS;
005E64  458101     ADD W11, W1, W2
005E66  EB4180     CLR.B W3
005E68  984113     MOV.B W3, [W2+1]
005FDE  4485EE     ADD W9, #0xE, W11
3750:                                                      data->TransferData.bEndpointAddress = pCurrentEndpoint->bEndpointAddress;
005E6A  9059A0     MOV.B [W0+26], W3
005E6C  784903     MOV.B W3, [W2]
3751:                                                      data->TransferData.bmAttributes.val = pCurrentEndpoint->bmAttributes.val;
005E6E  460081     ADD W12, W1, W1
005E70  905A30     MOV.B [W0+27], W4
005E72  784884     MOV.B W4, [W1]
005FE0  448670     ADD W9, #0x10, W12
3752:                                                      data->TransferData.clientDriver     = pCurrentEndpoint->clientDriver;
005E74  905810     MOV.B [W0+25], W0
005E76  984090     MOV.B W0, [W1+1]
005E78  3700A4     BRA .L484
3753:                                                  }
3754:                                                  else
3755:                                                  {
3756:                                                      pCurrentEndpoint->bmAttributes.val = USB_EVENT_QUEUE_FULL;
005E7A  B3C081     MOV.B #0x8, W1
005E7C  807D70     MOV pCurrentEndpoint, W0
005E7E  985831     MOV.B W1, [W0+27]
005E80  3700A0     BRA .L484
3757:                                                  }
3758:                                              #endif
3759:                                              break;
3760:              
3761:                                          case TSUBSTATE_ERROR:
3762:                                              pCurrentEndpoint->transferState             = TSTATE_IDLE;
005E82  EB4080     CLR.B W1
005E84  985801     MOV.B W1, [W0+24]
3763:                                              pCurrentEndpoint->wIntervalCount            = pCurrentEndpoint->wInterval;
005E86  807D70     MOV pCurrentEndpoint, W0
005E88  9002A0     MOV [W0+4], W5
005E8A  980035     MOV W5, [W0+6]
3764:                                              pCurrentEndpoint->status.bfTransferComplete = 1;
005E8C  900090     MOV [W0+2], W1
005E8E  A09001     BSET W1, #9
005E90  980011     MOV W1, [W0+2]
3765:                                              #if defined( USB_ENABLE_TRANSFER_EVENT )
3766:                                                  if (StructQueueIsNotFull(&usbEventQueue, USB_EVENT_QUEUE_DEPTH))
005E92  78001A     MOV [W10], W0
005E94  500FE3     SUB W0, #0x3, [W15]
005E96  3C001F     BRA GT, .L493, .LBE16
3767:                                                  {
3768:                                                      USB_EVENT_DATA *data;
3769:              
3770:                                                      data = StructQueueAdd(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
005E98  E80D00     INC W0, [W10]
005E9A  780019     MOV [W9], W0
005E9C  500FE2     SUB W0, #0x2, [W15]
005E9E  3C0002     BRA GT, .L494
005EA0  E80C80     INC W0, [W9]
005EA2  370001     BRA .L495
005EA4  EB0C80     CLR [W9]
005EA6  780019     MOV [W9], W0
3771:                                                      data->event = EVENT_BUS_ERROR;
005EA8  B9016C     MUL.SU W0, #12, W2
005EAA  780082     MOV W2, W1
005EAC  448101     ADD W9, W1, W2
005EAE  98013D     MOV W13, [W2+6]
005FE2  27FFFD     MOV #0x7FFF, W13
3772:                                                      data->TransferData.dataCount        = 0;
005EB0  B83360     MUL.UU W6, #0, W6
005EB2  980146     MOV W6, [W2+8]
005EB4  980157     MOV W7, [W2+10]
3773:                                                      data->TransferData.pUserData        = NULL;
005EB6  E80100     INC W0, W2
005EB8  B9116C     MUL.SU W2, #12, W2
005EBA  448002     ADD W9, W2, W0
005EBC  EB0800     CLR [W0]
3774:                                                      data->TransferData.bErrorCode       = pCurrentEndpoint->bErrorCode;
005EBE  807D70     MOV pCurrentEndpoint, W0
005EC0  458101     ADD W11, W1, W2
005EC2  905BC0     MOV.B [W0+28], W7
005EC4  984117     MOV.B W7, [W2+1]
3775:                                                      data->TransferData.bEndpointAddress = pCurrentEndpoint->bEndpointAddress;
005EC6  9059A0     MOV.B [W0+26], W3
005EC8  784903     MOV.B W3, [W2]
3776:                                                      data->TransferData.bmAttributes.val = pCurrentEndpoint->bmAttributes.val;
005ECA  460081     ADD W12, W1, W1
005ECC  905A30     MOV.B [W0+27], W4
005ECE  784884     MOV.B W4, [W1]
3777:                                                      data->TransferData.clientDriver     = pCurrentEndpoint->clientDriver;
005ED0  905810     MOV.B [W0+25], W0
005ED2  984090     MOV.B W0, [W1+1]
005ED4  370076     BRA .L484
3778:                                                  }
3779:                                                  else
3780:                                                  {
3781:                                                      pCurrentEndpoint->bmAttributes.val = USB_EVENT_QUEUE_FULL;
005ED6  B3C081     MOV.B #0x8, W1
005ED8  807D70     MOV pCurrentEndpoint, W0
005EDA  985831     MOV.B W1, [W0+27]
005EDC  370072     BRA .L484
3782:                                                  }
3783:                                              #endif
3784:                                              break;
3785:              
3786:                                          default:
3787:                                              illegalState = true;
005FBC  B3C018     MOV.B #0x1, W8
005FBE  370001     BRA .L484
3788:                                              break;
3789:                                      }
3790:                                      break;
3791:              
3792:                                  case TSTATE_INTERRUPT_WRITE:
3793:                                      switch (pCurrentEndpoint->transferState & TSUBSTATE_MASK)
005EDE  905880     MOV.B [W0+24], W1
005EE0  6080EF     AND W1, #0xF, W1
005EE2  508FE1     SUB W1, #0x1, [W15]
005EE4  32000B     BRA Z, .L497
005EE6  508FEF     SUB W1, #0xF, [W15]
005EE8  320039     BRA Z, .L498
005EEA  E00001     CP0 W1
005EEC  3A0069     BRA NZ, .L547
3794:                                      {
3795:                                          case TSUBSTATE_INTERRUPT_WRITE_DATA:
3796:                                              _USB_SetBDT( USB_TOKEN_OUT );
005EEE  B3C010     MOV.B #0x1, W0
005EF0  07FD15     RCALL _USB_SetBDT
3797:                                              _USB_SendToken( pCurrentEndpoint->bEndpointAddress, USB_TOKEN_OUT );
005EF2  807D70     MOV pCurrentEndpoint, W0
005EF4  905820     MOV.B [W0+26], W0
005EF6  B3C011     MOV.B #0x1, W1
005EF8  07FCF5     RCALL _USB_SendToken
3798:                                              return;
005EFA  370178     BRA .L438
3799:                                              break;
3800:              
3801:                                          case TSUBSTATE_INTERRUPT_WRITE_COMPLETE:
3802:                                              pCurrentEndpoint->transferState             = TSTATE_IDLE;
005EFC  EB4080     CLR.B W1
005EFE  985801     MOV.B W1, [W0+24]
3803:                                              pCurrentEndpoint->wIntervalCount            = pCurrentEndpoint->wInterval;
005F00  807D70     MOV pCurrentEndpoint, W0
005F02  9002A0     MOV [W0+4], W5
005F04  980035     MOV W5, [W0+6]
3804:                                              pCurrentEndpoint->status.bfTransferComplete = 1;
005F06  900090     MOV [W0+2], W1
005F08  A09001     BSET W1, #9
005F0A  980011     MOV W1, [W0+2]
3805:                                              #if defined( USB_ENABLE_TRANSFER_EVENT )
3806:                                                  if (StructQueueIsNotFull(&usbEventQueue, USB_EVENT_QUEUE_DEPTH))
005F0C  78001A     MOV [W10], W0
005F0E  500FE3     SUB W0, #0x3, [W15]
005F10  3C0021     BRA GT, .L499, .LBE17
3807:                                                  {
3808:                                                      USB_EVENT_DATA *data;
3809:              
3810:                                                      data = StructQueueAdd(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
005F12  E80D00     INC W0, [W10]
005F14  780019     MOV [W9], W0
005F16  500FE2     SUB W0, #0x2, [W15]
005F18  3C0002     BRA GT, .L500
005F1A  E80C80     INC W0, [W9]
005F1C  370001     BRA .L501
005F1E  EB0C80     CLR [W9]
005F20  780119     MOV [W9], W2
3811:                                                      data->event = EVENT_TRANSFER;
005F22  B9106C     MUL.SU W2, #12, W0
005F24  780080     MOV W0, W1
005F26  448181     ADD W9, W1, W3
005F28  200720     MOV #0x72, W0
005F2A  9801B0     MOV W0, [W3+6]
3812:                                                      data->TransferData.dataCount        = pCurrentEndpoint->dataCount;
005F2C  807D70     MOV pCurrentEndpoint, W0
005F2E  900B00     MOV [W0+16], W6
005F30  900B90     MOV [W0+18], W7
005F32  9801C6     MOV W6, [W3+8]
005F34  9801D7     MOV W7, [W3+10]
3813:                                                      data->TransferData.pUserData        = pCurrentEndpoint->pUserData;
005F36  E80102     INC W2, W2
005F38  B9116C     MUL.SU W2, #12, W2
005F3A  900BB0     MOV [W0+22], W7
005F3C  793487     MOV W7, [W9+W2]
3814:                                                      data->TransferData.bErrorCode       = USB_SUCCESS;
005F3E  458101     ADD W11, W1, W2
005F40  EB4180     CLR.B W3
005F42  984113     MOV.B W3, [W2+1]
3815:                                                      data->TransferData.bEndpointAddress = pCurrentEndpoint->bEndpointAddress;
005F44  9059A0     MOV.B [W0+26], W3
005F46  784903     MOV.B W3, [W2]
3816:                                                      data->TransferData.bmAttributes.val = pCurrentEndpoint->bmAttributes.val;
005F48  460081     ADD W12, W1, W1
005F4A  905A30     MOV.B [W0+27], W4
005F4C  784884     MOV.B W4, [W1]
3817:                                                      data->TransferData.clientDriver     = pCurrentEndpoint->clientDriver;
005F4E  905810     MOV.B [W0+25], W0
005F50  984090     MOV.B W0, [W1+1]
005F52  370037     BRA .L484
3818:                                                  }
3819:                                                  else
3820:                                                  {
3821:                                                      pCurrentEndpoint->bmAttributes.val = USB_EVENT_QUEUE_FULL;
005F54  B3C081     MOV.B #0x8, W1
005F56  807D70     MOV pCurrentEndpoint, W0
005F58  985831     MOV.B W1, [W0+27]
005F5A  370033     BRA .L484
3822:                                                  }
3823:                                              #endif
3824:                                              break;
3825:              
3826:                                          case TSUBSTATE_ERROR:
3827:                                              pCurrentEndpoint->transferState             = TSTATE_IDLE;
005F5C  EB4080     CLR.B W1
005F5E  985801     MOV.B W1, [W0+24]
3828:                                              pCurrentEndpoint->wIntervalCount            = pCurrentEndpoint->wInterval;
005F60  807D70     MOV pCurrentEndpoint, W0
005F62  9002A0     MOV [W0+4], W5
005F64  980035     MOV W5, [W0+6]
3829:                                              pCurrentEndpoint->status.bfTransferComplete = 1;
005F66  900090     MOV [W0+2], W1
005F68  A09001     BSET W1, #9
005F6A  980011     MOV W1, [W0+2]
3830:                                              #if defined( USB_ENABLE_TRANSFER_EVENT )
3831:                                                  if (StructQueueIsNotFull(&usbEventQueue, USB_EVENT_QUEUE_DEPTH))
005F6C  78001A     MOV [W10], W0
005F6E  500FE3     SUB W0, #0x3, [W15]
005F70  3C001F     BRA GT, .L502, .LBE18
3832:                                                  {
3833:                                                      USB_EVENT_DATA *data;
3834:              
3835:                                                      data = StructQueueAdd(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
005F72  E80D00     INC W0, [W10]
005F74  780019     MOV [W9], W0
005F76  500FE2     SUB W0, #0x2, [W15]
005F78  3C0002     BRA GT, .L503
005F7A  E80C80     INC W0, [W9]
005F7C  370001     BRA .L504
005F7E  EB0C80     CLR [W9]
005F80  780019     MOV [W9], W0
3836:                                                      data->event = EVENT_BUS_ERROR;
005F82  B9016C     MUL.SU W0, #12, W2
005F84  780082     MOV W2, W1
005F86  448101     ADD W9, W1, W2
005F88  98013D     MOV W13, [W2+6]
3837:                                                      data->TransferData.dataCount        = 0;
005F8A  B83360     MUL.UU W6, #0, W6
005F8C  980146     MOV W6, [W2+8]
005F8E  980157     MOV W7, [W2+10]
3838:                                                      data->TransferData.pUserData        = NULL;
005F90  E80100     INC W0, W2
005F92  B9116C     MUL.SU W2, #12, W2
005F94  448002     ADD W9, W2, W0
005F96  EB0800     CLR [W0]
3839:                                                      data->TransferData.bErrorCode       = pCurrentEndpoint->bErrorCode;
005F98  807D70     MOV pCurrentEndpoint, W0
005F9A  458101     ADD W11, W1, W2
005F9C  905BC0     MOV.B [W0+28], W7
005F9E  984117     MOV.B W7, [W2+1]
3840:                                                      data->TransferData.bEndpointAddress = pCurrentEndpoint->bEndpointAddress;
005FA0  9059A0     MOV.B [W0+26], W3
005FA2  784903     MOV.B W3, [W2]
3841:                                                      data->TransferData.bmAttributes.val = pCurrentEndpoint->bmAttributes.val;
005FA4  460081     ADD W12, W1, W1
005FA6  905A30     MOV.B [W0+27], W4
005FA8  784884     MOV.B W4, [W1]
3842:                                                      data->TransferData.clientDriver     = pCurrentEndpoint->clientDriver;
005FAA  905810     MOV.B [W0+25], W0
005FAC  984090     MOV.B W0, [W1+1]
005FAE  370009     BRA .L484
3843:                                                  }
3844:                                                  else
3845:                                                  {
3846:                                                      pCurrentEndpoint->bmAttributes.val = USB_EVENT_QUEUE_FULL;
005FB0  B3C081     MOV.B #0x8, W1
005FB2  807D70     MOV pCurrentEndpoint, W0
005FB4  985831     MOV.B W1, [W0+27]
005FB6  370005     BRA .L484
3847:                                                  }
3848:                                              #endif
3849:                                              break;
3850:              
3851:                                          default:
3852:                                              illegalState = true;
005FC0  B3C018     MOV.B #0x1, W8
3853:                                              break;
3854:                                      }
3855:                                      break;
3856:              
3857:                                  default:
3858:                                      illegalState = true;
005FB8  B3C018     MOV.B #0x1, W8
005FBA  370003     BRA .L484
3859:                                      break;
3860:                              }
3861:              
3862:                              if (illegalState)
005FC2  E00408     CP0.B W8
005FC4  32000F     BRA Z, .L544
3863:                              {
3864:                                  // We should never use this, but in case we do, put the endpoint
3865:                                  // in a recoverable state.
3866:                                  pCurrentEndpoint->transferState             = TSTATE_IDLE;
005FC6  EB4080     CLR.B W1
005FC8  807D70     MOV pCurrentEndpoint, W0
005FCA  985801     MOV.B W1, [W0+24]
3867:                                  pCurrentEndpoint->wIntervalCount            = pCurrentEndpoint->wInterval;
005FCC  807D70     MOV pCurrentEndpoint, W0
005FCE  9002A0     MOV [W0+4], W5
005FD0  980035     MOV W5, [W0+6]
3868:                                  pCurrentEndpoint->status.bfTransferComplete = 1;
005FD2  900090     MOV [W0+2], W1
005FD4  A09001     BSET W1, #9
005FD6  980011     MOV W1, [W0+2]
005FD8  370005     BRA .L544
3869:                              }
3870:                          }
3871:              
3872:                          // If we've gone through all the endpoints, we do not have any more interrupt transfers.
3873:                          usbBusInfo.flags.bfInterruptTransfersDone = 1;
005FEC  A82FB0     BSET usbBusInfo, #1
3874:                      }
3875:                  #endif
3876:              
3877:                  #ifdef USB_SUPPORT_BULK_TRANSFERS
3878:              #ifdef ALLOW_MULTIPLE_BULK_TRANSACTIONS_PER_FRAME
3879:              TryBulk:
3880:              #endif
3881:              
3882:                      if (!usbBusInfo.flags.bfBulkTransfersDone)
005FEE  AB6FB0     BTST usbBusInfo, #3
005FF0  3A00FD     BRA NZ, .L438
0061DE  AB6FB0     BTST usbBusInfo, #3
0061E0  32FF0D     BRA Z, .L541, .LBE22
0061E2  370004     BRA .L438
3883:                      {
3884:                          #ifndef ALLOW_MULTIPLE_BULK_TRANSACTIONS_PER_FRAME
3885:                              // Only go through this section once if we are not allowing multiple transactions
3886:                              // per frame.
3887:                              usbBusInfo.flags.bfBulkTransfersDone = 1;
3888:                          #endif
3889:              
3890:                          // Look for any bulk operations.  Try to service all pending requests within the frame.
3891:                          if (_USB_FindServiceEndpoint( USB_TRANSFER_TYPE_BULK ))
005FFC  B3C020     MOV.B #0x2, W0
005FFE  07F3D2     RCALL _USB_FindServiceEndpoint
006000  E00400     CP0.B W0
006002  3200EA     BRA Z, .L507
3892:                          {
3893:                              switch (pCurrentEndpoint->transferState & TSTATE_MASK)
006004  807D70     MOV pCurrentEndpoint, W0
006006  905880     MOV.B [W0+24], W1
006008  B20F01     AND #0xF0, W1
00600A  200802     MOV #0x80, W2
00600C  508F82     SUB W1, W2, [W15]
00600E  320004     BRA Z, .L509
006010  410170     ADD W2, #0x10, W2
006012  508F82     SUB W1, W2, [W15]
006014  3A00D3     BRA NZ, .L548
006016  370069     BRA .L557
3894:                              {
3895:                                  case TSTATE_BULK_READ:
3896:                                      switch (pCurrentEndpoint->transferState & TSUBSTATE_MASK)
006018  905880     MOV.B [W0+24], W1
00601A  6080EF     AND W1, #0xF, W1
00601C  508FE1     SUB W1, #0x1, [W15]
00601E  32000B     BRA Z, .L512
006020  508FEF     SUB W1, #0xF, [W15]
006022  320037     BRA Z, .L513
006024  E00001     CP0 W1
006026  3A00CC     BRA NZ, .L549
3897:                                      {
3898:                                          case TSUBSTATE_BULK_READ_DATA:
3899:                                              _USB_SetBDT( USB_TOKEN_IN );
006028  B3C090     MOV.B #0x9, W0
00602A  07FC78     RCALL _USB_SetBDT
3900:                                              _USB_SendToken( pCurrentEndpoint->bEndpointAddress, USB_TOKEN_IN );
00602C  807D70     MOV pCurrentEndpoint, W0
00602E  905820     MOV.B [W0+26], W0
006030  B3C091     MOV.B #0x9, W1
006032  07FC58     RCALL _USB_SendToken
3901:                                              return;
006034  3700DB     BRA .L438
3902:                                              break;
3903:              
3904:                                          case TSUBSTATE_BULK_READ_COMPLETE:
3905:                                              pCurrentEndpoint->transferState               = TSTATE_IDLE;
006036  EB4080     CLR.B W1
006038  985801     MOV.B W1, [W0+24]
3906:                                              pCurrentEndpoint->status.bfTransferComplete   = 1;
00603A  807D70     MOV pCurrentEndpoint, W0
00603C  900090     MOV [W0+2], W1
00603E  A09001     BSET W1, #9
006040  980011     MOV W1, [W0+2]
3907:                                              #if defined( USB_ENABLE_TRANSFER_EVENT )
3908:                                                  if (StructQueueIsNotFull(&usbEventQueue, USB_EVENT_QUEUE_DEPTH))
005FF2  20974A     MOV #0x974, W10
006042  78001A     MOV [W10], W0
006044  500FE3     SUB W0, #0x3, [W15]
006046  3C0021     BRA GT, .L514
3909:                                                  {
3910:                                                      USB_EVENT_DATA *data;
3911:              
3912:                                                      data = StructQueueAdd(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
005FF4  5504E4     SUB W10, #0x4, W9
006048  E80D00     INC W0, [W10]
00604A  780019     MOV [W9], W0
00604C  500FE2     SUB W0, #0x2, [W15]
00604E  3C0002     BRA GT, .L515
006050  E80C80     INC W0, [W9]
006052  370001     BRA .L516
006054  EB0C80     CLR [W9]
006056  780119     MOV [W9], W2
3913:                                                      data->event = EVENT_TRANSFER;
006058  B9106C     MUL.SU W2, #12, W0
00605A  780080     MOV W0, W1
00605C  448181     ADD W9, W1, W3
00605E  200720     MOV #0x72, W0
006060  9801B0     MOV W0, [W3+6]
3914:                                                      data->TransferData.dataCount        = pCurrentEndpoint->dataCount;
006062  807D70     MOV pCurrentEndpoint, W0
006064  900B00     MOV [W0+16], W6
006066  900B90     MOV [W0+18], W7
006068  9801C6     MOV W6, [W3+8]
00606A  9801D7     MOV W7, [W3+10]
3915:                                                      data->TransferData.pUserData        = pCurrentEndpoint->pUserData;
00606C  E80102     INC W2, W2
00606E  B9116C     MUL.SU W2, #12, W2
006070  900BB0     MOV [W0+22], W7
006072  793487     MOV W7, [W9+W2]
3916:                                                      data->TransferData.bErrorCode       = USB_SUCCESS;
005FF6  4485EE     ADD W9, #0xE, W11
006074  458101     ADD W11, W1, W2
006076  EB4180     CLR.B W3
006078  984113     MOV.B W3, [W2+1]
3917:                                                      data->TransferData.bEndpointAddress = pCurrentEndpoint->bEndpointAddress;
00607A  9059A0     MOV.B [W0+26], W3
00607C  784903     MOV.B W3, [W2]
3918:                                                      data->TransferData.bmAttributes.val = pCurrentEndpoint->bmAttributes.val;
005FF8  448670     ADD W9, #0x10, W12
00607E  460081     ADD W12, W1, W1
006080  905A30     MOV.B [W0+27], W4
006082  784884     MOV.B W4, [W1]
3919:                                                      data->TransferData.clientDriver     = pCurrentEndpoint->clientDriver;
006084  905810     MOV.B [W0+25], W0
006086  984090     MOV.B W0, [W1+1]
006088  37009E     BRA .L508
3920:                                                  }
3921:                                                  else
3922:                                                  {
3923:                                                      pCurrentEndpoint->bmAttributes.val = USB_EVENT_QUEUE_FULL;
00608A  B3C081     MOV.B #0x8, W1
00608C  807D70     MOV pCurrentEndpoint, W0
00608E  985831     MOV.B W1, [W0+27]
006090  37009A     BRA .L508
3924:                                                  }
3925:                                              #endif
3926:                                              break;
3927:              
3928:                                          case TSUBSTATE_ERROR:
3929:                                              pCurrentEndpoint->transferState               = TSTATE_IDLE;
006092  EB4080     CLR.B W1
006094  985801     MOV.B W1, [W0+24]
3930:                                              pCurrentEndpoint->status.bfTransferComplete   = 1;
006096  807D70     MOV pCurrentEndpoint, W0
006098  900090     MOV [W0+2], W1
00609A  A09001     BSET W1, #9
00609C  980011     MOV W1, [W0+2]
3931:                                              #if defined( USB_ENABLE_TRANSFER_EVENT )
3932:                                                  if (StructQueueIsNotFull(&usbEventQueue, USB_EVENT_QUEUE_DEPTH))
00609E  78001A     MOV [W10], W0
0060A0  500FE3     SUB W0, #0x3, [W15]
0060A2  3C001F     BRA GT, .L517
3933:                                                  {
3934:                                                      USB_EVENT_DATA *data;
3935:              
3936:                                                      data = StructQueueAdd(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
0060A4  E80D00     INC W0, [W10]
0060A6  780019     MOV [W9], W0
0060A8  500FE2     SUB W0, #0x2, [W15]
0060AA  3C0002     BRA GT, .L518
0060AC  E80C80     INC W0, [W9]
0060AE  370001     BRA .L519
0060B0  EB0C80     CLR [W9]
0060B2  780019     MOV [W9], W0
3937:                                                      data->event = EVENT_BUS_ERROR;
005FFA  27FFFD     MOV #0x7FFF, W13
0060B4  B9016C     MUL.SU W0, #12, W2
0060B6  780082     MOV W2, W1
0060B8  448101     ADD W9, W1, W2
0060BA  98013D     MOV W13, [W2+6]
3938:                                                      data->TransferData.dataCount        = 0;
0060BC  B83360     MUL.UU W6, #0, W6
0060BE  980146     MOV W6, [W2+8]
0060C0  980157     MOV W7, [W2+10]
3939:                                                      data->TransferData.pUserData        = NULL;
0060C2  E80100     INC W0, W2
0060C4  B9116C     MUL.SU W2, #12, W2
0060C6  448002     ADD W9, W2, W0
0060C8  EB0800     CLR [W0]
3940:                                                      data->TransferData.bErrorCode       = pCurrentEndpoint->bErrorCode;
0060CA  807D70     MOV pCurrentEndpoint, W0
0060CC  458101     ADD W11, W1, W2
0060CE  905BC0     MOV.B [W0+28], W7
0060D0  984117     MOV.B W7, [W2+1]
3941:                                                      data->TransferData.bEndpointAddress = pCurrentEndpoint->bEndpointAddress;
0060D2  9059A0     MOV.B [W0+26], W3
0060D4  784903     MOV.B W3, [W2]
3942:                                                      data->TransferData.bmAttributes.val = pCurrentEndpoint->bmAttributes.val;
0060D6  460081     ADD W12, W1, W1
0060D8  905A30     MOV.B [W0+27], W4
0060DA  784884     MOV.B W4, [W1]
3943:                                                      data->TransferData.clientDriver     = pCurrentEndpoint->clientDriver;
0060DC  905810     MOV.B [W0+25], W0
0060DE  984090     MOV.B W0, [W1+1]
0060E0  370072     BRA .L508
3944:                                                  }
3945:                                                  else
3946:                                                  {
3947:                                                      pCurrentEndpoint->bmAttributes.val = USB_EVENT_QUEUE_FULL;
0060E2  B3C081     MOV.B #0x8, W1
0060E4  807D70     MOV pCurrentEndpoint, W0
0060E6  985831     MOV.B W1, [W0+27]
0060E8  37006E     BRA .L508
3948:                                                  }
3949:                                              #endif
3950:                                              break;
3951:              
3952:                                          default:
3953:                                              illegalState = true;
0061C0  B3C018     MOV.B #0x1, W8
0061C2  370001     BRA .L508
3954:                                              break;
3955:                                      }
3956:                                      break;
3957:              
3958:                                  case TSTATE_BULK_WRITE:
3959:                                      switch (pCurrentEndpoint->transferState & TSUBSTATE_MASK)
0060EA  905880     MOV.B [W0+24], W1
0060EC  6080EF     AND W1, #0xF, W1
0060EE  508FE1     SUB W1, #0x1, [W15]
0060F0  32000B     BRA Z, .L521
0060F2  508FEF     SUB W1, #0xF, [W15]
0060F4  320037     BRA Z, .L522
0060F6  E00001     CP0 W1
0060F8  3A0065     BRA NZ, .L550
3960:                                      {
3961:                                          case TSUBSTATE_BULK_WRITE_DATA:
3962:                                              _USB_SetBDT( USB_TOKEN_OUT );
0060FA  B3C010     MOV.B #0x1, W0
0060FC  07FC0F     RCALL _USB_SetBDT
3963:                                              _USB_SendToken( pCurrentEndpoint->bEndpointAddress, USB_TOKEN_OUT );
0060FE  807D70     MOV pCurrentEndpoint, W0
006100  905820     MOV.B [W0+26], W0
006102  B3C011     MOV.B #0x1, W1
006104  07FBEF     RCALL _USB_SendToken
3964:                                              return;
006106  370072     BRA .L438
3965:                                              break;
3966:              
3967:                                          case TSUBSTATE_BULK_WRITE_COMPLETE:
3968:                                              pCurrentEndpoint->transferState               = TSTATE_IDLE;
006108  EB4080     CLR.B W1
00610A  985801     MOV.B W1, [W0+24]
3969:                                              pCurrentEndpoint->status.bfTransferComplete   = 1;
00610C  807D70     MOV pCurrentEndpoint, W0
00610E  900090     MOV [W0+2], W1
006110  A09001     BSET W1, #9
006112  980011     MOV W1, [W0+2]
3970:                                              #if defined( USB_ENABLE_TRANSFER_EVENT )
3971:                                                  if (StructQueueIsNotFull(&usbEventQueue, USB_EVENT_QUEUE_DEPTH))
006114  78001A     MOV [W10], W0
006116  500FE3     SUB W0, #0x3, [W15]
006118  3C0021     BRA GT, .L523, .LBE25
3972:                                                  {
3973:                                                      USB_EVENT_DATA *data;
3974:              
3975:                                                      data = StructQueueAdd(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
00611A  E80D00     INC W0, [W10]
00611C  780019     MOV [W9], W0
00611E  500FE2     SUB W0, #0x2, [W15]
006120  3C0002     BRA GT, .L524
006122  E80C80     INC W0, [W9]
006124  370001     BRA .L525
006126  EB0C80     CLR [W9]
006128  780119     MOV [W9], W2
3976:                                                      data->event = EVENT_TRANSFER;
00612A  B9106C     MUL.SU W2, #12, W0
00612C  780080     MOV W0, W1
00612E  448181     ADD W9, W1, W3
006130  200720     MOV #0x72, W0
006132  9801B0     MOV W0, [W3+6]
3977:                                                      data->TransferData.dataCount        = pCurrentEndpoint->dataCount;
006134  807D70     MOV pCurrentEndpoint, W0
006136  900B00     MOV [W0+16], W6
006138  900B90     MOV [W0+18], W7
00613A  9801C6     MOV W6, [W3+8]
00613C  9801D7     MOV W7, [W3+10]
3978:                                                      data->TransferData.pUserData        = pCurrentEndpoint->pUserData;
00613E  E80102     INC W2, W2
006140  B9116C     MUL.SU W2, #12, W2
006142  900BB0     MOV [W0+22], W7
006144  793487     MOV W7, [W9+W2]
3979:                                                      data->TransferData.bErrorCode       = USB_SUCCESS;
006146  458101     ADD W11, W1, W2
006148  EB4180     CLR.B W3
00614A  984113     MOV.B W3, [W2+1]
3980:                                                      data->TransferData.bEndpointAddress = pCurrentEndpoint->bEndpointAddress;
00614C  9059A0     MOV.B [W0+26], W3
00614E  784903     MOV.B W3, [W2]
3981:                                                      data->TransferData.bmAttributes.val = pCurrentEndpoint->bmAttributes.val;
006150  460081     ADD W12, W1, W1
006152  905A30     MOV.B [W0+27], W4
006154  784884     MOV.B W4, [W1]
3982:                                                      data->TransferData.clientDriver     = pCurrentEndpoint->clientDriver;
006156  905810     MOV.B [W0+25], W0
006158  984090     MOV.B W0, [W1+1]
00615A  370035     BRA .L508
3983:                                                  }
3984:                                                  else
3985:                                                  {
3986:                                                      pCurrentEndpoint->bmAttributes.val = USB_EVENT_QUEUE_FULL;
00615C  B3C081     MOV.B #0x8, W1
00615E  807D70     MOV pCurrentEndpoint, W0
006160  985831     MOV.B W1, [W0+27]
006162  370031     BRA .L508
3987:                                                  }
3988:                                              #endif
3989:                                              break;
3990:              
3991:                                          case TSUBSTATE_ERROR:
3992:                                              pCurrentEndpoint->transferState               = TSTATE_IDLE;
006164  EB4080     CLR.B W1
006166  985801     MOV.B W1, [W0+24]
3993:                                              pCurrentEndpoint->status.bfTransferComplete   = 1;
006168  807D70     MOV pCurrentEndpoint, W0
00616A  900090     MOV [W0+2], W1
00616C  A09001     BSET W1, #9
00616E  980011     MOV W1, [W0+2]
3994:                                              #if defined( USB_ENABLE_TRANSFER_EVENT )
3995:                                                  if (StructQueueIsNotFull(&usbEventQueue, USB_EVENT_QUEUE_DEPTH))
006170  78001A     MOV [W10], W0
006172  500FE3     SUB W0, #0x3, [W15]
006174  3C001F     BRA GT, .L526, .LBE26
3996:                                                  {
3997:                                                      USB_EVENT_DATA *data;
3998:              
3999:                                                      data = StructQueueAdd(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
006176  E80D00     INC W0, [W10]
006178  780019     MOV [W9], W0
00617A  500FE2     SUB W0, #0x2, [W15]
00617C  3C0002     BRA GT, .L527
00617E  E80C80     INC W0, [W9]
006180  370001     BRA .L528
006182  EB0C80     CLR [W9]
006184  780019     MOV [W9], W0
4000:                                                      data->event = EVENT_BUS_ERROR;
006186  B9016C     MUL.SU W0, #12, W2
006188  780082     MOV W2, W1
00618A  448101     ADD W9, W1, W2
00618C  98013D     MOV W13, [W2+6]
4001:                                                      data->TransferData.dataCount        = 0;
00618E  B83360     MUL.UU W6, #0, W6
006190  980146     MOV W6, [W2+8]
006192  980157     MOV W7, [W2+10]
4002:                                                      data->TransferData.pUserData        = NULL;
006194  E80100     INC W0, W2
006196  B9116C     MUL.SU W2, #12, W2
006198  448002     ADD W9, W2, W0
00619A  EB0800     CLR [W0]
4003:                                                      data->TransferData.bErrorCode       = pCurrentEndpoint->bErrorCode;
00619C  807D70     MOV pCurrentEndpoint, W0
00619E  458101     ADD W11, W1, W2
0061A0  905BC0     MOV.B [W0+28], W7
0061A2  984117     MOV.B W7, [W2+1]
4004:                                                      data->TransferData.bEndpointAddress = pCurrentEndpoint->bEndpointAddress;
0061A4  9059A0     MOV.B [W0+26], W3
0061A6  784903     MOV.B W3, [W2]
4005:                                                      data->TransferData.bmAttributes.val = pCurrentEndpoint->bmAttributes.val;
0061A8  460081     ADD W12, W1, W1
0061AA  905A30     MOV.B [W0+27], W4
0061AC  784884     MOV.B W4, [W1]
4006:                                                      data->TransferData.clientDriver     = pCurrentEndpoint->clientDriver;
0061AE  905810     MOV.B [W0+25], W0
0061B0  984090     MOV.B W0, [W1+1]
0061B2  370009     BRA .L508
4007:                                                  }
4008:                                                  else
4009:                                                  {
4010:                                                      pCurrentEndpoint->bmAttributes.val = USB_EVENT_QUEUE_FULL;
0061B4  B3C081     MOV.B #0x8, W1
0061B6  807D70     MOV pCurrentEndpoint, W0
0061B8  985831     MOV.B W1, [W0+27]
0061BA  370005     BRA .L508
4011:                                                  }
4012:                                              #endif
4013:                                              break;
4014:              
4015:                                          default:
4016:                                              illegalState = true;
0061C4  B3C018     MOV.B #0x1, W8
4017:                                              break;
4018:                                      }
4019:                                      break;
4020:              
4021:                                  default:
4022:                                      illegalState = true;
0061BC  B3C018     MOV.B #0x1, W8
0061BE  370003     BRA .L508
4023:                                      break;
4024:                              }
4025:              
4026:                              if (illegalState)
0061C6  E00408     CP0.B W8
0061C8  320007     BRA Z, .L507
4027:                              {
4028:                                  // We should never use this, but in case we do, put the endpoint
4029:                                  // in a recoverable state.
4030:                                  pCurrentEndpoint->transferState               = TSTATE_IDLE;
0061CA  EB4080     CLR.B W1
0061CC  807D70     MOV pCurrentEndpoint, W0
0061CE  985801     MOV.B W1, [W0+24]
4031:                                  pCurrentEndpoint->status.bfTransferComplete   = 1;
0061D0  807D70     MOV pCurrentEndpoint, W0
0061D2  900090     MOV [W0+2], W1
0061D4  A09001     BSET W1, #9
0061D6  980011     MOV W1, [W0+2]
4032:                              }
4033:                          }
4034:              
4035:                          // We've gone through all the bulk transactions, but we have time for more.
4036:                          // If we have any bulk transactions, go back to the beginning of the list
4037:                          // and start over.
4038:                          #ifdef ALLOW_MULTIPLE_BULK_TRANSACTIONS_PER_FRAME
4039:                              if (usbBusInfo.countBulkTransactions)
0061D8  E24FB3     CP0.B 0xFB3
0061DA  320004     BRA Z, .L529
4040:                              {
4041:                                  usbBusInfo.lastBulkTransaction = 0;
0061DC  EF6FB2     CLR.B 0xFB2
4042:                                  goto TryBulk;
4043:              
4044:                              }
4045:                          #endif
4046:              
4047:                          // If we've gone through all the endpoints, we do not have any more bulk transfers.
4048:                          usbBusInfo.flags.bfBulkTransfersDone = 1;
0061E4  A86FB0     BSET usbBusInfo, #3
0061E6  370002     BRA .L438
4049:                      }
4050:                  #endif
4051:              
4052:                  return;
4053:              }
0061EC  BE064F     MOV.D [--W15], W12
0061EE  BE054F     MOV.D [--W15], W10
0061F0  BE044F     MOV.D [--W15], W8
0061F2  060000     RETURN
4054:              
4055:              
4056:              /****************************************************************************
4057:                Function:
4058:                  bool _USB_FindServiceEndpoint( uint8_t transferType )
4059:              
4060:                Description:
4061:                  This function finds an endpoint of the specified transfer type that is
4062:                  ready for servicing.  If it finds one, usbDeviceInfo.pCurrentEndpoint is
4063:                  updated to point to the endpoint information structure.
4064:              
4065:                Precondition:
4066:                  None
4067:              
4068:                Parameters:
4069:                  uint8_t transferType - Endpoint transfer type.  Valid values are:
4070:                                          * USB_TRANSFER_TYPE_CONTROL
4071:                                          * USB_TRANSFER_TYPE_ISOCHRONOUS
4072:                                          * USB_TRANSFER_TYPE_INTERRUPT
4073:                                          * USB_TRANSFER_TYPE_BULK
4074:              
4075:                Return Values:
4076:                  true    - An endpoint of the indicated transfer type needs to be serviced,
4077:                              and pCurrentEndpoint has been updated to point to the endpoint.
4078:                  false   - No endpoints of the indicated transfer type need to be serviced.
4079:              
4080:                Remarks:
4081:                  The EP 0 block is retained.
4082:                ***************************************************************************/
4083:              bool _USB_FindServiceEndpoint( uint8_t transferType )
4084:              {
0047A4  784200     MOV.B W0, W4
4085:                  USB_ENDPOINT_INFO           *pEndpoint;
4086:                  USB_INTERFACE_INFO          *pInterface;
4087:              
4088:                  // Check endpoint 0.
4089:                  if ((usbDeviceInfo.pEndpoint0->bmAttributes.bfTransferType == transferType) &&
0047A6  804B60     MOV 0x96C, W0
0047A8  FB8184     ZE W4, W3
0047AA  9008D0     MOV [W0+26], W1
0047AC  DE08C8     LSR W1, #8, W1
0047AE  6080E3     AND W1, #0x3, W1
0047B0  508F83     SUB W1, W3, [W15]
0047B2  3A0006     BRA NZ, .L74
0047B6  A39801     BTST.Z W1, #9
0047B8  3A0003     BRA NZ, .L74
4090:                      !usbDeviceInfo.pEndpoint0->status.bfTransferComplete)
0047B4  900090     MOV [W0+2], W1
4091:                  {
4092:                      pCurrentEndpoint = usbDeviceInfo.pEndpoint0;
0047BA  887D70     MOV W0, pCurrentEndpoint
4093:                      return true;
0047BC  B3C010     MOV.B #0x1, W0
0047BE  37004F     BRA .L75
4094:                  }
4095:              
4096:                  usbBusInfo.countBulkTransactions = 0;
0047C0  EF6FB3     CLR.B 0xFB3
4097:                  pEndpoint = NULL;
0047CC  EB0080     CLR W1
4098:                  pInterface = usbDeviceInfo.pInterfaceList;
0047C2  804B52     MOV 0x96A, W2
4099:                  if (pInterface && pInterface->pCurrentSetting)
0047C6  E00002     CP0 W2
0047C8  32004A     BRA Z, .L75
0047CA  900022     MOV [W2+4], W0
0047CE  E00000     CP0 W0
0047D0  320001     BRA Z, .L92
4100:                  {
4101:                      pEndpoint = pInterface->pCurrentSetting->pEndpointList;
0047D2  9000A0     MOV [W0+4], W1
4102:                  }
4103:              
4104:                  while (pInterface)
004854  E00002     CP0 W2
004856  3AFFBF     BRA NZ, .L94
4105:                  {
4106:                      if (pEndpoint != NULL)
0047D6  E00001     CP0 W1
0047D8  320034     BRA Z, .L77
4107:                      {
4108:                          if (pEndpoint->bmAttributes.bfTransferType == transferType)
0047DA  900851     MOV [W1+26], W0
0047DC  DE0048     LSR W0, #8, W0
0047DE  600063     AND W0, #0x3, W0
0047E0  518F80     SUB W3, W0, [W15]
0047E2  3A002C     BRA NZ, .L78
4109:                          {
4110:                              switch (transferType)
0047E4  524FE2     SUB.B W4, #0x2, [W15]
0047E6  320019     BRA Z, .L80
0047E8  524FE3     SUB.B W4, #0x3, [W15]
0047EA  320008     BRA Z, .L81
0047EC  E00404     CP0.B W4
0047EE  3A0026     BRA NZ, .L78
4111:                              {
4112:                                  case USB_TRANSFER_TYPE_CONTROL:
4113:                                          if (!pEndpoint->status.bfTransferComplete)
0047F0  900011     MOV [W1+2], W0
0047F2  A39800     BTST.Z W0, #9
0047F4  3A0023     BRA NZ, .L78
4114:                                          {
4115:                                                  pCurrentEndpoint = pEndpoint;
0047F6  887D71     MOV W1, pCurrentEndpoint
4116:                                                  return true;
0047F8  B3C010     MOV.B #0x1, W0
0047FA  370031     BRA .L75
4117:                                          }
4118:                                          break;
4119:              
4120:                                  #ifdef USB_SUPPORT_ISOCHRONOUS_TRANSFERS
4121:                                  case USB_TRANSFER_TYPE_ISOCHRONOUS:
4122:                                  #endif
4123:                                  #ifdef USB_SUPPORT_INTERRUPT_TRANSFERS
4124:                                  case USB_TRANSFER_TYPE_INTERRUPT:
4125:                                  #endif
4126:                                  #if defined( USB_SUPPORT_ISOCHRONOUS_TRANSFERS ) || defined( USB_SUPPORT_INTERRUPT_TRANSFERS )
4127:                                          if (pEndpoint->status.bfTransferComplete)
0047FC  900011     MOV [W1+2], W0
0047FE  A39800     BTST.Z W0, #9
004800  320006     BRA Z, .L82
4128:                                          {
4129:                                                  // The endpoint doesn't need servicing.  If the interval count
4130:                                                  // has reached 0 and the user has not initiated another transaction,
4131:                                                  // reset the interval count for the next interval.
4132:                                                  if (pEndpoint->wIntervalCount == 0)
004802  900031     MOV [W1+6], W0
004804  E00000     CP0 W0
004806  3A001A     BRA NZ, .L78
4133:                                                  {
4134:                                                          // Reset the interval count for the next packet.
4135:                                                          pEndpoint->wIntervalCount = pEndpoint->wInterval;
004808  900021     MOV [W1+4], W0
00480A  9800B0     MOV W0, [W1+6]
00480C  370017     BRA .L78
4136:                                                  }
4137:                                          }
4138:                                          else
4139:                                          {
4140:                                                  if (pEndpoint->wIntervalCount == 0)
00480E  900031     MOV [W1+6], W0
004810  E00000     CP0 W0
004812  3A0014     BRA NZ, .L78
4141:                                                  {
4142:                                                  pCurrentEndpoint = pEndpoint;
004814  887D71     MOV W1, pCurrentEndpoint
4143:                                                  return true;
004816  B3C010     MOV.B #0x1, W0
004818  370022     BRA .L75
4144:                              }
4145:                                          }
4146:                                          break;
4147:                                  #endif
4148:              
4149:                                  #ifdef USB_SUPPORT_BULK_TRANSFERS
4150:                                  case USB_TRANSFER_TYPE_BULK:
4151:                                          #ifdef ALLOW_MULTIPLE_NAKS_PER_FRAME
4152:                                          if (!pEndpoint->status.bfTransferComplete)
4153:                                          #else
4154:                                          if (!pEndpoint->status.bfTransferComplete &&
00481A  900011     MOV [W1+2], W0
00481C  A39800     BTST.Z W0, #9
00481E  3A000E     BRA NZ, .L78
004822  A3C800     BTST.Z W0, #12
004824  3A000B     BRA NZ, .L78
4155:                                                  !pEndpoint->status.bfLastTransferNAKd)
004820  900011     MOV [W1+2], W0
4156:                                          #endif
4157:                                          {
4158:                                                  usbBusInfo.countBulkTransactions ++;
004826  EC6FB3     INC.B 0xFB3
4159:                                                  if (usbBusInfo.countBulkTransactions > usbBusInfo.lastBulkTransaction)
004828  BFCFB2     MOV.B 0xFB2, WREG
00482A  E34FB3     CP.B 0xFB3
00482C  360007     BRA LEU, .L78
4160:                                                  {
4161:                                                          usbBusInfo.lastBulkTransaction  = usbBusInfo.countBulkTransactions;
00482E  20FB32     MOV #0xFB3, W2
004830  784112     MOV.B [W2], W2
004832  20FB20     MOV #0xFB2, W0
004834  784802     MOV.B W2, [W0]
4162:                                                          pCurrentEndpoint                = pEndpoint;
004836  887D71     MOV W1, pCurrentEndpoint
4163:                                                          return true;
004838  B3C010     MOV.B #0x1, W0
00483A  370011     BRA .L75
4164:                                                  }
4165:                                          }
4166:                                          break;
4167:                                  #endif
4168:                              }
4169:                          }
4170:              
4171:              	        // Go to the next endpoint.
4172:                          pEndpoint = pEndpoint->next;
00483C  780091     MOV [W1], W1
4173:                      }
4174:              
4175:                      if (pEndpoint == NULL)
00483E  E00001     CP0 W1
004840  3A0009     BRA NZ, .L83
4176:                      {
4177:                          // Go to the next interface.
4178:                          pInterface = pInterface->next;
004842  780112     MOV [W2], W2
4179:                          if (pInterface && pInterface->pCurrentSetting)
0047D4  EB0280     CLR W5
004844  E00002     CP0 W2
004846  32000A     BRA Z, .L89
004848  900022     MOV [W2+4], W0
00484A  780085     MOV W5, W1
00484C  E00000     CP0 W0
00484E  32FFC3     BRA Z, .L94
4180:                          {
4181:                              pEndpoint = pInterface->pCurrentSetting->pEndpointList;
004850  9000A0     MOV [W0+4], W1
004852  37FFC1     BRA .L94
4182:                          }
4183:                      }
4184:                  }
4185:              
4186:                  // No endpoints with the desired description are ready for servicing.
4187:                  return false;
0047C4  EB4000     CLR.B W0
004858  EB4000     CLR.B W0
00485A  370001     BRA .L75
00485C  EB4000     CLR.B W0
4188:              }
00485E  060000     RETURN
4189:              
4190:              
4191:              /****************************************************************************
4192:                Function:
4193:                  void _USB_FreeConfigMemory( void )
4194:              
4195:                Description:
4196:                  This function frees the interface and endpoint lists associated
4197:                              with a configuration.
4198:              
4199:                Precondition:
4200:                  None
4201:              
4202:                Parameters:
4203:                  None - None
4204:              
4205:                Returns:
4206:                  None
4207:              
4208:                Remarks:
4209:                  The EP 0 block is retained.
4210:                ***************************************************************************/
4211:              
4212:              void _USB_FreeConfigMemory( void )
4213:              {
004860  BE9F88     MOV.D W8, [W15++]
004862  BE9F8A     MOV.D W10, [W15++]
004864  781F8C     MOV W12, [W15++]
4214:                  USB_INTERFACE_INFO          *pTempInterface;
4215:                  USB_INTERFACE_SETTING_INFO  *pTempSetting;
4216:                  USB_ENDPOINT_INFO           *pTempEndpoint;
4217:              
4218:                  while (usbDeviceInfo.pInterfaceList != NULL)
004866  804B5C     MOV 0x96A, W12
004868  E0000C     CP0 W12
00486A  320028     BRA Z, .L96
0048B8  E0000C     CP0 W12
0048BA  3AFFDA     BRA NZ, .L102
4219:                  {
4220:                      pTempInterface = usbDeviceInfo.pInterfaceList->next;
004870  78061C     MOV [W12], W12
4221:              
4222:                      while (usbDeviceInfo.pInterfaceList->pInterfaceSettings != NULL)
00486C  2096AB     MOV #0x96A, W11
004872  78001B     MOV [W11], W0
004874  900090     MOV [W0+2], W1
004876  E00001     CP0 W1
004878  32001D     BRA Z, .L97
0048AC  78001B     MOV [W11], W0
0048AE  900090     MOV [W0+2], W1
0048B0  E00001     CP0 W1
0048B2  3AFFE3     BRA NZ, .L103
4223:                      {
4224:                          pTempSetting = usbDeviceInfo.pInterfaceList->pInterfaceSettings->next;
00487A  780511     MOV [W1], W10
4225:              
4226:                          while (usbDeviceInfo.pInterfaceList->pInterfaceSettings->pEndpointList != NULL)
00487C  804B50     MOV 0x96A, W0
00487E  900090     MOV [W0+2], W1
004880  900021     MOV [W1+4], W0
004882  E00000     CP0 W0
004884  32000D     BRA Z, .L98
004896  804B50     MOV 0x96A, W0
004898  900090     MOV [W0+2], W1
00489A  900021     MOV [W1+4], W0
00489C  E00000     CP0 W0
00489E  3AFFF3     BRA NZ, .L104
4227:                          {
4228:                              pTempEndpoint = usbDeviceInfo.pInterfaceList->pInterfaceSettings->pEndpointList->next;
004886  780410     MOV [W0], W8
4229:                              USB_FREE_AND_CLEAR( usbDeviceInfo.pInterfaceList->pInterfaceSettings->pEndpointList );
00486E  EB0480     CLR W9
004888  07DD7F     RCALL 0x388
00488A  804B50     MOV 0x96A, W0
00488C  900010     MOV [W0+2], W0
00488E  980029     MOV W9, [W0+4]
4230:                              usbDeviceInfo.pInterfaceList->pInterfaceSettings->pEndpointList = pTempEndpoint;
004890  804B50     MOV 0x96A, W0
004892  900010     MOV [W0+2], W0
004894  980028     MOV W8, [W0+4]
4231:                          }
4232:                          USB_FREE_AND_CLEAR( usbDeviceInfo.pInterfaceList->pInterfaceSettings );
0048A0  780001     MOV W1, W0
0048A2  07DD72     RCALL 0x388
0048A4  804B50     MOV 0x96A, W0
0048A6  980019     MOV W9, [W0+2]
4233:                          usbDeviceInfo.pInterfaceList->pInterfaceSettings = pTempSetting;
0048A8  804B50     MOV 0x96A, W0
0048AA  98001A     MOV W10, [W0+2]
4234:                      }
4235:                      USB_FREE_AND_CLEAR( usbDeviceInfo.pInterfaceList );
0048B4  07DD69     RCALL 0x388
4236:                      usbDeviceInfo.pInterfaceList = pTempInterface;
0048B6  780D8C     MOV W12, [W11]
4237:                  }
4238:              
4239:                  pCurrentEndpoint = usbDeviceInfo.pEndpoint0;
0048BC  804B60     MOV 0x96C, W0
0048BE  887D70     MOV W0, pCurrentEndpoint
4240:              
4241:              } // _USB_FreeConfigMemory
0048C0  78064F     MOV [--W15], W12
0048C2  BE054F     MOV.D [--W15], W10
0048C4  BE044F     MOV.D [--W15], W8
0048C6  060000     RETURN
4242:              
4243:              
4244:              /****************************************************************************
4245:                Function:
4246:                  void _USB_FreeMemory( void )
4247:              
4248:                Description:
4249:                  This function frees all memory that can be freed.  Only the EP0
4250:                  information block is retained.
4251:              
4252:                Precondition:
4253:                  None
4254:              
4255:                Parameters:
4256:                  None - None
4257:              
4258:                Returns:
4259:                  None
4260:              
4261:                Remarks:
4262:                  None
4263:                ***************************************************************************/
4264:              
4265:              void _USB_FreeMemory( void )
4266:              {
0048C8  BE9F88     MOV.D W8, [W15++]
0048CA  781F8A     MOV W10, [W15++]
4267:                  uint8_t    *pTemp;
4268:              
4269:                  while (usbDeviceInfo.pConfigurationDescriptorList != NULL)
0048CC  804B40     MOV 0x968, W0
0048CE  E00000     CP0 W0
0048D0  3A0003     BRA NZ, .L114
0048D2  37000E     BRA .L109
0048D4  780008     MOV W8, W0
0048D6  370002     BRA .L115
0048EC  E00008     CP0 W8
0048EE  3AFFF2     BRA NZ, .L113
4270:                  {
4271:                      pTemp = (uint8_t *)usbDeviceInfo.pConfigurationDescriptorList->next;
0048DC  900410     MOV [W0+2], W8
4272:                      USB_FREE_AND_CLEAR( usbDeviceInfo.pConfigurationDescriptorList->descriptor );
0048D8  EB0500     CLR W10
0048DE  780010     MOV [W0], W0
0048E0  07DD53     RCALL 0x388
0048E2  804B40     MOV 0x968, W0
0048E4  78080A     MOV W10, [W0]
4273:                      USB_FREE_AND_CLEAR( usbDeviceInfo.pConfigurationDescriptorList );
0048DA  209689     MOV #0x968, W9
0048E6  780019     MOV [W9], W0
0048E8  07DD4F     RCALL 0x388
4274:                      usbDeviceInfo.pConfigurationDescriptorList = (USB_CONFIGURATION *)pTemp;
0048EA  780C88     MOV W8, [W9]
4275:                  }
4276:                  if (pDeviceDescriptor != NULL)
0048F0  807D30     MOV pDeviceDescriptor, W0
0048F2  E00000     CP0 W0
0048F4  320002     BRA Z, .L111
4277:                  {
4278:                      USB_FREE_AND_CLEAR( pDeviceDescriptor );
0048F6  07DD48     RCALL 0x388
0048F8  EF2FA6     CLR pDeviceDescriptor
4279:                  }
4280:                  if (pEP0Data != NULL)
0048FA  807DA0     MOV pEP0Data, W0
0048FC  E00000     CP0 W0
0048FE  320002     BRA Z, .L112
4281:                  {
4282:                      USB_FREE_AND_CLEAR( pEP0Data );
004900  07DD43     RCALL 0x388
004902  EF2FB4     CLR pEP0Data
4283:                  }
4284:              
4285:                  _USB_FreeConfigMemory();
004904  07FFAD     RCALL _USB_FreeConfigMemory
4286:              
4287:              }
004906  78054F     MOV [--W15], W10
004908  BE044F     MOV.D [--W15], W8
00490A  060000     RETURN
4288:              
4289:              
4290:              /****************************************************************************
4291:                Function:
4292:                  void _USB_InitControlRead( USB_ENDPOINT_INFO *pEndpoint,
4293:                                      uint8_t *pControlData, uint16_t controlSize, uint8_t *pData,
4294:                                      uint16_t size )
4295:              
4296:                Description:
4297:                  This function sets up the endpoint information for a control (SETUP)
4298:                  transfer that will read information.
4299:              
4300:                Precondition:
4301:                  All error checking must be done prior to calling this function.
4302:              
4303:                Parameters:
4304:                  USB_ENDPOINT_INFO *pEndpoint    - Points to the desired endpoint
4305:                                                      in the endpoint information list.
4306:                  uint8_t *pControlData              - Points to the SETUP message.
4307:                  uint16_t controlSize                - Size of the SETUP message.
4308:                  uint8_t *pData                     - Points to where the read data
4309:                                                      is to be stored.
4310:                  uint16_t size                       - Number of data bytes to read.
4311:              
4312:                Returns:
4313:                  None
4314:              
4315:                Remarks:
4316:                  Since endpoint servicing is interrupt driven, the bfTransferComplete
4317:                  flag must be set last.
4318:                ***************************************************************************/
4319:              
4320:              void _USB_InitControlRead( USB_ENDPOINT_INFO *pEndpoint, uint8_t *pControlData, uint16_t controlSize,
4321:                                          uint8_t *pData, uint16_t size )
4322:              {
4323:                  pEndpoint->status.bfStalled             = 0;
004948  900290     MOV [W0+2], W5
00494A  A15005     BCLR W5, #5
00494C  980015     MOV W5, [W0+2]
4324:                  pEndpoint->status.bfError               = 0;
00494E  900290     MOV [W0+2], W5
004950  A16005     BCLR W5, #6
004952  980015     MOV W5, [W0+2]
4325:                  pEndpoint->status.bfUserAbort           = 0;
004954  900290     MOV [W0+2], W5
004956  A17005     BCLR W5, #7
004958  980015     MOV W5, [W0+2]
4326:                  pEndpoint->status.bfTransferSuccessful  = 0;
00495A  900290     MOV [W0+2], W5
00495C  A18005     BCLR W5, #8
00495E  980015     MOV W5, [W0+2]
4327:                  pEndpoint->status.bfErrorCount          = 0;
004960  900310     MOV [W0+2], W6
004962  2FFE05     MOV #0xFFE0, W5
004964  630285     AND W6, W5, W5
004966  980015     MOV W5, [W0+2]
4328:                  pEndpoint->status.bfLastTransferNAKd    = 0;
004968  900290     MOV [W0+2], W5
00496A  A1C005     BCLR W5, #12
00496C  980015     MOV W5, [W0+2]
4329:                  pEndpoint->pUserData                    = pData;
00496E  980833     MOV W3, [W0+22]
4330:                  pEndpoint->dataCount                    = 0;
004970  B83360     MUL.UU W6, #0, W6
004972  980806     MOV W6, [W0+16]
004974  980817     MOV W7, [W0+18]
4331:                  pEndpoint->dataCountMax                 = size;
004976  EB0280     CLR W5
004978  980054     MOV W4, [W0+10]
00497A  980065     MOV W5, [W0+12]
4332:                  pEndpoint->countNAKs                    = 0;
00497C  EB0180     CLR W3
00497E  980873     MOV W3, [W0+30]
4333:              
4334:                  pEndpoint->pUserDataSETUP               = pControlData;
004980  980821     MOV W1, [W0+20]
4335:                  pEndpoint->dataCountMaxSETUP            = controlSize;
004982  980072     MOV W2, [W0+14]
4336:                  pEndpoint->transferState                = TSTATE_CONTROL_READ;
004984  B3C201     MOV.B #0x20, W1
004986  985801     MOV.B W1, [W0+24]
4337:              
4338:                  // Set the flag last so all the parameters are set for an interrupt.
4339:                  pEndpoint->status.bfTransferComplete    = 0;
004988  900090     MOV [W0+2], W1
00498A  A19001     BCLR W1, #9
00498C  980011     MOV W1, [W0+2]
4340:              }
00498E  060000     RETURN
4341:              
4342:              
4343:              /****************************************************************************
4344:                Function:
4345:                  void _USB_InitControlWrite( USB_ENDPOINT_INFO *pEndpoint,
4346:                                      uint8_t *pControlData, uint16_t controlSize, uint8_t *pData,
4347:                                      uint16_t size )
4348:              
4349:                Description:
4350:                  This function sets up the endpoint information for a control (SETUP)
4351:                  transfer that will write information.
4352:              
4353:                Precondition:
4354:                  All error checking must be done prior to calling this function.
4355:              
4356:                Parameters:
4357:                  USB_ENDPOINT_INFO *pEndpoint    - Points to the desired endpoint
4358:                                                                    in the endpoint information list.
4359:                  uint8_t *pControlData              - Points to the SETUP message.
4360:                  uint16_t controlSize                - Size of the SETUP message.
4361:                  uint8_t *pData                     - Points to where the write data
4362:                                                                    is to be stored.
4363:                  uint16_t size                       - Number of data bytes to write.
4364:              
4365:                Returns:
4366:                  None
4367:              
4368:                Remarks:
4369:                  Since endpoint servicing is interrupt driven, the bfTransferComplete
4370:                  flag must be set last.
4371:                ***************************************************************************/
4372:              
4373:              void _USB_InitControlWrite( USB_ENDPOINT_INFO *pEndpoint, uint8_t *pControlData,
4374:                              uint16_t controlSize, uint8_t *pData, uint16_t size )
4375:              {
4376:                  pEndpoint->status.bfStalled             = 0;
004990  900290     MOV [W0+2], W5
004992  A15005     BCLR W5, #5
004994  980015     MOV W5, [W0+2]
4377:                  pEndpoint->status.bfError               = 0;
004996  900290     MOV [W0+2], W5
004998  A16005     BCLR W5, #6
00499A  980015     MOV W5, [W0+2]
4378:                  pEndpoint->status.bfUserAbort           = 0;
00499C  900290     MOV [W0+2], W5
00499E  A17005     BCLR W5, #7
0049A0  980015     MOV W5, [W0+2]
4379:                  pEndpoint->status.bfTransferSuccessful  = 0;
0049A2  900290     MOV [W0+2], W5
0049A4  A18005     BCLR W5, #8
0049A6  980015     MOV W5, [W0+2]
4380:                  pEndpoint->status.bfErrorCount          = 0;
0049A8  900310     MOV [W0+2], W6
0049AA  2FFE05     MOV #0xFFE0, W5
0049AC  630285     AND W6, W5, W5
0049AE  980015     MOV W5, [W0+2]
4381:                  pEndpoint->status.bfLastTransferNAKd    = 0;
0049B0  900290     MOV [W0+2], W5
0049B2  A1C005     BCLR W5, #12
0049B4  980015     MOV W5, [W0+2]
4382:                  pEndpoint->pUserData                    = pData;
0049B6  980833     MOV W3, [W0+22]
4383:                  pEndpoint->dataCount                    = 0;
0049B8  B83360     MUL.UU W6, #0, W6
0049BA  980806     MOV W6, [W0+16]
0049BC  980817     MOV W7, [W0+18]
4384:                  pEndpoint->dataCountMax                 = size;
0049BE  B82361     MUL.UU W4, #1, W6
0049C0  980056     MOV W6, [W0+10]
0049C2  980067     MOV W7, [W0+12]
4385:                  pEndpoint->countNAKs                    = 0;
0049C4  EB0180     CLR W3
0049C6  980873     MOV W3, [W0+30]
4386:              
4387:                  pEndpoint->pUserDataSETUP               = pControlData;
0049C8  980821     MOV W1, [W0+20]
4388:                  pEndpoint->dataCountMaxSETUP            = controlSize;
0049CA  980072     MOV W2, [W0+14]
4389:              
4390:                  if (size == 0)
0049CC  E00004     CP0 W4
0049CE  3A0003     BRA NZ, .L123
4391:                  {
4392:                      pEndpoint->transferState    = TSTATE_CONTROL_NO_DATA;
0049D0  B3C101     MOV.B #0x10, W1
0049D2  985801     MOV.B W1, [W0+24]
0049D4  370002     BRA .L124
4393:                  }
4394:                  else
4395:                  {
4396:                      pEndpoint->transferState    = TSTATE_CONTROL_WRITE;
0049D6  B3C301     MOV.B #0x30, W1
0049D8  985801     MOV.B W1, [W0+24]
4397:                  }
4398:              
4399:                  // Set the flag last so all the parameters are set for an interrupt.
4400:                  pEndpoint->status.bfTransferComplete    = 0;
0049DA  900090     MOV [W0+2], W1
0049DC  A19001     BCLR W1, #9
0049DE  980011     MOV W1, [W0+2]
4401:              }
0049E0  060000     RETURN
4402:              
4403:              
4404:              /****************************************************************************
4405:                Function:
4406:                  void _USB_InitRead( USB_ENDPOINT_INFO *pEndpoint, uint8_t *pData,
4407:                                      uint16_t size )
4408:              
4409:                Description:
4410:                  This function sets up the endpoint information for an interrupt,
4411:                  isochronous, or bulk read.  If the transfer is isochronous, the pData
4412:                  and size parameters have different meaning.
4413:              
4414:                Precondition:
4415:                  All error checking must be done prior to calling this function.
4416:              
4417:                Parameters:
4418:                  USB_ENDPOINT_INFO *pEndpoint  - Points to the desired endpoint in the
4419:                                                  endpoint information list.
4420:                  uint8_t *pData                   - Points to where the data is to be
4421:                                                  stored.  If the endpoint is isochronous,
4422:                                                  this points to an ISOCHRONOUS_DATA_BUFFERS
4423:                                                  structure.
4424:                  uint16_t size                     - Number of data bytes to read. If the
4425:                                                  endpoint is isochronous, this is the number
4426:                                                  of data buffer pointers pointed to by
4427:                                                  pData.
4428:              
4429:                Returns:
4430:                  None
4431:              
4432:                Remarks:
4433:                  * Control reads should use the routine _USB_InitControlRead().  Since
4434:                      endpoint servicing is interrupt driven, the bfTransferComplete flag
4435:                      must be set last.
4436:              
4437:                  * For interrupt and isochronous endpoints, we let the interval count
4438:                      free run.  The transaction will begin when the interval count
4439:                      reaches 0.
4440:                ***************************************************************************/
4441:              
4442:              void _USB_InitRead( USB_ENDPOINT_INFO *pEndpoint, uint8_t *pData, uint16_t size )
4443:              {
4444:                  pEndpoint->status.bfUserAbort           = 0;
0049E2  900190     MOV [W0+2], W3
0049E4  A17003     BCLR W3, #7
0049E6  980013     MOV W3, [W0+2]
4445:                  pEndpoint->status.bfTransferSuccessful  = 0;
0049E8  900190     MOV [W0+2], W3
0049EA  A18003     BCLR W3, #8
0049EC  980013     MOV W3, [W0+2]
4446:                  pEndpoint->status.bfErrorCount          = 0;
0049EE  900210     MOV [W0+2], W4
0049F0  2FFE03     MOV #0xFFE0, W3
0049F2  620183     AND W4, W3, W3
0049F4  980013     MOV W3, [W0+2]
4447:                  pEndpoint->status.bfLastTransferNAKd    = 0;
0049F6  900190     MOV [W0+2], W3
0049F8  A1C003     BCLR W3, #12
0049FA  980013     MOV W3, [W0+2]
4448:                  pEndpoint->pUserData                    = pData;
0049FC  980831     MOV W1, [W0+22]
4449:                  pEndpoint->dataCount                    = 0;
0049FE  B82260     MUL.UU W4, #0, W4
004A00  980804     MOV W4, [W0+16]
004A02  980815     MOV W5, [W0+18]
4450:                  pEndpoint->dataCountMax                 = size; // Not used for isochronous.
004A04  EB0180     CLR W3
004A06  980052     MOV W2, [W0+10]
004A08  980063     MOV W3, [W0+12]
4451:                  pEndpoint->countNAKs                    = 0;
004A0A  EB0100     CLR W2
004A0C  980872     MOV W2, [W0+30]
4452:              
4453:                  if (pEndpoint->bmAttributes.bfTransferType == USB_TRANSFER_TYPE_INTERRUPT)
004A0E  9009D0     MOV [W0+26], W3
004A10  203002     MOV #0x300, W2
004A12  618182     AND W3, W2, W3
004A14  518F82     SUB W3, W2, [W15]
004A16  3A0003     BRA NZ, .L126
4454:                  {
4455:                      pEndpoint->transferState            = TSTATE_INTERRUPT_READ;
004A18  B3C401     MOV.B #0x40, W1
004A1A  985801     MOV.B W1, [W0+24]
004A1C  37000A     BRA .L127
4456:                  }
4457:                  else if (pEndpoint->bmAttributes.bfTransferType == USB_TRANSFER_TYPE_ISOCHRONOUS)
004A1E  201002     MOV #0x100, W2
004A20  518F82     SUB W3, W2, [W15]
004A22  3A0005     BRA NZ, .L128
4458:                  {
4459:                      pEndpoint->transferState                                        = TSTATE_ISOCHRONOUS_READ;
004A24  B3C602     MOV.B #0x60, W2
004A26  985802     MOV.B W2, [W0+24]
4460:                      ((ISOCHRONOUS_DATA *)pEndpoint->pUserData)->currentBufferUSB    = 0;
004A28  EB4100     CLR.B W2
004A2A  984092     MOV.B W2, [W1+1]
004A2C  370002     BRA .L127
4461:                  }
4462:                  else // Bulk
4463:                  {
4464:                      pEndpoint->transferState            = TSTATE_BULK_READ;
004A2E  B3C801     MOV.B #0x80, W1
004A30  985801     MOV.B W1, [W0+24]
4465:                  }
4466:              
4467:                  // Set the flag last so all the parameters are set for an interrupt.
4468:                  pEndpoint->status.bfTransferComplete    = 0;
004A32  900090     MOV [W0+2], W1
004A34  A19001     BCLR W1, #9
004A36  980011     MOV W1, [W0+2]
4469:              }
004A38  060000     RETURN
4470:              
4471:              /****************************************************************************
4472:                Function:
4473:                  void _USB_InitWrite( USB_ENDPOINT_INFO *pEndpoint, uint8_t *pData,
4474:                                          uint16_t size )
4475:              
4476:                Description:
4477:                  This function sets up the endpoint information for an interrupt,
4478:                  isochronous, or bulk  write.  If the transfer is isochronous, the pData
4479:                  and size parameters have different meaning.
4480:              
4481:                Precondition:
4482:                  All error checking must be done prior to calling this function.
4483:              
4484:                Parameters:
4485:                  USB_ENDPOINT_INFO *pEndpoint  - Points to the desired endpoint in the
4486:                                                  endpoint information list.
4487:                  uint8_t *pData                   - Points to where the data to send is
4488:                                                  stored.  If the endpoint is isochronous,
4489:                                                  this points to an ISOCHRONOUS_DATA_BUFFERS
4490:                                                  structure.
4491:                  uint16_t size                     - Number of data bytes to write.  If the
4492:                                                  endpoint is isochronous, this is the number
4493:                                                  of data buffer pointers pointed to by
4494:                                                  pData.
4495:              
4496:                Returns:
4497:                  None
4498:              
4499:                Remarks:
4500:                  * Control writes should use the routine _USB_InitControlWrite().  Since
4501:                      endpoint servicing is interrupt driven, the bfTransferComplete flag
4502:                      must be set last.
4503:              
4504:                  * For interrupt and isochronous endpoints, we let the interval count
4505:                      free run.  The transaction will begin when the interval count
4506:                      reaches 0.
4507:                ***************************************************************************/
4508:              
4509:              void _USB_InitWrite( USB_ENDPOINT_INFO *pEndpoint, uint8_t *pData, uint16_t size )
4510:              {
4511:                  pEndpoint->status.bfUserAbort           = 0;
004A9E  900190     MOV [W0+2], W3
004AA0  A17003     BCLR W3, #7
004AA2  980013     MOV W3, [W0+2]
4512:                  pEndpoint->status.bfTransferSuccessful  = 0;
004AA4  900190     MOV [W0+2], W3
004AA6  A18003     BCLR W3, #8
004AA8  980013     MOV W3, [W0+2]
4513:                  pEndpoint->status.bfErrorCount          = 0;
004AAA  900210     MOV [W0+2], W4
004AAC  2FFE03     MOV #0xFFE0, W3
004AAE  620183     AND W4, W3, W3
004AB0  980013     MOV W3, [W0+2]
4514:                  pEndpoint->status.bfLastTransferNAKd    = 0;
004AB2  900190     MOV [W0+2], W3
004AB4  A1C003     BCLR W3, #12
004AB6  980013     MOV W3, [W0+2]
4515:                  pEndpoint->pUserData                    = pData;
004AB8  980831     MOV W1, [W0+22]
4516:                  pEndpoint->dataCount                    = 0;
004ABA  B82260     MUL.UU W4, #0, W4
004ABC  980804     MOV W4, [W0+16]
004ABE  980815     MOV W5, [W0+18]
4517:                  pEndpoint->dataCountMax                 = size; // Not used for isochronous.
004AC0  EB0180     CLR W3
004AC2  980052     MOV W2, [W0+10]
004AC4  980063     MOV W3, [W0+12]
4518:                  pEndpoint->countNAKs                    = 0;
004AC6  EB0100     CLR W2
004AC8  980872     MOV W2, [W0+30]
4519:              
4520:                  if (pEndpoint->bmAttributes.bfTransferType == USB_TRANSFER_TYPE_INTERRUPT)
004ACA  9009D0     MOV [W0+26], W3
004ACC  203002     MOV #0x300, W2
004ACE  618182     AND W3, W2, W3
004AD0  518F82     SUB W3, W2, [W15]
004AD2  3A0003     BRA NZ, .L140
4521:                  {
4522:                      pEndpoint->transferState            = TSTATE_INTERRUPT_WRITE;
004AD4  B3C501     MOV.B #0x50, W1
004AD6  985801     MOV.B W1, [W0+24]
004AD8  37000A     BRA .L141
4523:                  }
4524:                  else if (pEndpoint->bmAttributes.bfTransferType == USB_TRANSFER_TYPE_ISOCHRONOUS)
004ADA  201002     MOV #0x100, W2
004ADC  518F82     SUB W3, W2, [W15]
004ADE  3A0005     BRA NZ, .L142
4525:                  {
4526:                      pEndpoint->transferState                                        = TSTATE_ISOCHRONOUS_WRITE;
004AE0  B3C702     MOV.B #0x70, W2
004AE2  985802     MOV.B W2, [W0+24]
4527:                      ((ISOCHRONOUS_DATA *)pEndpoint->pUserData)->currentBufferUSB    = 0;
004AE4  EB4100     CLR.B W2
004AE6  984092     MOV.B W2, [W1+1]
004AE8  370002     BRA .L141
4528:                  }
4529:                  else // Bulk
4530:                  {
4531:                      pEndpoint->transferState            = TSTATE_BULK_WRITE;
004AEA  B3C901     MOV.B #0x90, W1
004AEC  985801     MOV.B W1, [W0+24]
4532:                  }
4533:              
4534:                  // Set the flag last so all the parameters are set for an interrupt.
4535:                  pEndpoint->status.bfTransferComplete    = 0;
004AEE  900090     MOV [W0+2], W1
004AF0  A19001     BCLR W1, #9
004AF2  980011     MOV W1, [W0+2]
4536:              }
004AF4  060000     RETURN
4537:              
4538:              
4539:              /****************************************************************************
4540:                Function:
4541:                  void _USB_NotifyClients( uint8_t address, USB_EVENT event, void *data,
4542:                              unsigned int size )
4543:              
4544:                Description:
4545:                  This routine notifies all active client drivers for the given device of
4546:                  the given event.
4547:              
4548:                Precondition:
4549:                  None
4550:              
4551:                Parameters:
4552:                  uint8_t address        - Address of the device generating the event
4553:                  USB_EVENT event     - Event ID
4554:                  void *data          - Pointer to event data
4555:                  unsigned int size   - Size of data pointed to by data
4556:              
4557:                Returns:
4558:                  None
4559:              
4560:                Remarks:
4561:                  When this driver is modified to support multiple devices, this function
4562:                  will require modification.
4563:                ***************************************************************************/
4564:              
4565:              void _USB_NotifyClients( uint8_t address, USB_EVENT event, void *data, unsigned int size )
4566:              {
004B5A  FA0004     LNK #0x4
004B5C  BE9F88     MOV.D W8, [W15++]
004B5E  BE9F8A     MOV.D W10, [W15++]
004B60  BE9F8C     MOV.D W12, [W15++]
004B62  784580     MOV.B W0, W11
004B64  780481     MOV W1, W9
004B66  780502     MOV W2, W10
004B68  780683     MOV W3, W13
4567:                  USB_INTERFACE_INFO  *pInterface;
4568:              
4569:                  // Some events go to all drivers, some only to specific drivers.
4570:                  switch(event)
004B6A  200720     MOV #0x72, W0
004B6C  548F80     SUB W9, W0, [W15]
004B6E  320003     BRA Z, .L155
004B70  27FFF0     MOV #0x7FFF, W0
004B72  548F80     SUB W9, W0, [W15]
004B74  3A000E     BRA NZ, .L161
4571:                  {
4572:                      case EVENT_TRANSFER:
4573:                      case EVENT_BUS_ERROR:
4574:                          if (((HOST_TRANSFER_DATA *)data)->clientDriver != CLIENT_DRIVER_HOST)
004B76  90481A     MOV.B [W10+9], W0
004B78  404FE1     ADD.B W0, #0x1, [W15]
004B7A  32002E     BRA Z, .L153
4575:                          {
4576:                              usbClientDrvTable[((HOST_TRANSFER_DATA *)data)->clientDriver].EventHandler(address, event, data, size);
004B7C  B3C0A2     MOV.B #0xA, W2
004B7E  BC4004     MUL.B WREG2
004B80  E88002     INC2 W2, W0
004B82  209A61     MOV #0x9A6, W1
004B84  7801E1     MOV [W1+W0], W3
004B86  B86A61     MUL.UU W13, #1, W4
004B88  78010A     MOV W10, W2
004B8A  780089     MOV W9, W1
004B8C  78400B     MOV.B W11, W0
004B8E  010003     CALL W3
004B90  370023     BRA .L153
4577:                          }
4578:                          break;
4579:                      default:
4580:                          pInterface = usbDeviceInfo.pInterfaceList;
004B92  804B58     MOV 0x96A, W8
4581:                          while (pInterface != NULL)  // Scan the interface list for all active drivers.
004B94  E00008     CP0 W8
004B96  320012     BRA Z, .L157
004BB8  E00008     CP0 W8
004BBA  3AFFF2     BRA NZ, .L159
4582:                          {
4583:                              usbClientDrvTable[pInterface->clientDriver].EventHandler(address, event, data, size);
004B98  209A6C     MOV #0x9A6, W12
004B9A  B86861     MUL.UU W13, #1, W0
004B9C  9FBF80     MOV W0, [W15-16]
004B9E  9FBF91     MOV W1, [W15-14]
004BA0  904078     MOV.B [W8+7], W0
004BA2  B3C0A2     MOV.B #0xA, W2
004BA4  BC4004     MUL.B WREG2
004BA6  E88102     INC2 W2, W2
004BA8  7901EC     MOV [W12+W2], W3
004BAA  97BA0F     MOV [W15-16], W4
004BAC  97BA9F     MOV [W15-14], W5
004BAE  78010A     MOV W10, W2
004BB0  780089     MOV W9, W1
004BB2  78400B     MOV.B W11, W0
004BB4  010003     CALL W3
4584:                              pInterface = pInterface->next;
004BB6  780418     MOV [W8], W8
4585:                          }
4586:              
4587:                          if(usbDeviceInfo.flags.bfUseEP0Driver == 1)
004BBC  804B70     MOV 0x96E, W0
004BBE  A37800     BTST.Z W0, #7
004BC0  32000B     BRA Z, .L153
4588:                          {
4589:                              usbClientDrvTable[usbDeviceInfo.deviceEP0Driver].EventHandler(address, event, data, size);
004BC2  209640     MOV #0x964, W0
004BC4  FB8010     ZE [W0], W0
004BC6  B9006A     MUL.SU W0, #10, W0
004BC8  E88000     INC2 W0, W0
004BCA  209A61     MOV #0x9A6, W1
004BCC  7801E1     MOV [W1+W0], W3
004BCE  B86A61     MUL.UU W13, #1, W4
004BD0  78010A     MOV W10, W2
004BD2  780089     MOV W9, W1
004BD4  78400B     MOV.B W11, W0
004BD6  010003     CALL W3
4590:                          }
4591:                          break;
4592:                  }
4593:              } // _USB_NotifyClients
004BD8  BE064F     MOV.D [--W15], W12
004BDA  BE054F     MOV.D [--W15], W10
004BDC  BE044F     MOV.D [--W15], W8
004BDE  FA8000     ULNK
004BE0  060000     RETURN
4594:              
4595:              /****************************************************************************
4596:                Function:
4597:                  void _USB_NotifyClients( uint8_t address, USB_EVENT event, void *data,
4598:                              unsigned int size )
4599:              
4600:                Description:
4601:                  This routine notifies all active client drivers for the given device of
4602:                  the given event.
4603:              
4604:                Precondition:
4605:                  None
4606:              
4607:                Parameters:
4608:                  uint8_t address        - Address of the device generating the event
4609:                  USB_EVENT event     - Event ID
4610:                  void *data          - Pointer to event data
4611:                  unsigned int size   - Size of data pointed to by data
4612:              
4613:                Returns:
4614:                  None
4615:              
4616:                Remarks:
4617:                  When this driver is modified to support multiple devices, this function
4618:                  will require modification.
4619:                ***************************************************************************/
4620:              
4621:              void _USB_NotifyDataClients( uint8_t address, USB_EVENT event, void *data, unsigned int size )
4622:              {
004C3C  FA0004     LNK #0x4
004C3E  BE9F88     MOV.D W8, [W15++]
004C40  BE9F8A     MOV.D W10, [W15++]
004C42  781F8C     MOV W12, [W15++]
004C44  784600     MOV.B W0, W12
004C46  780581     MOV W1, W11
004C48  780502     MOV W2, W10
4623:                  USB_INTERFACE_INFO  *pInterface;
4624:              
4625:                  // Some events go to all drivers, some only to specific drivers.
4626:                  switch(event)
4627:                  {
4628:                      default:
4629:                          pInterface = usbDeviceInfo.pInterfaceList;
004C4A  804B58     MOV 0x96A, W8
4630:                          while (pInterface != NULL)  // Scan the interface list for all active drivers.
004C4C  E00008     CP0 W8
004C4E  320014     BRA Z, .L170
004C74  E00008     CP0 W8
004C76  3AFFF0     BRA NZ, .L174
4631:                          {
4632:                              if(usbClientDrvTable[pInterface->clientDriver].DataEventHandler != NULL)
004C50  209A69     MOV #0x9A6, W9
004C58  904078     MOV.B [W8+7], W0
004C5A  B3C0A2     MOV.B #0xA, W2
004C5C  BC4004     MUL.B WREG2
004C5E  410164     ADD W2, #0x4, W2
004C60  7901E9     MOV [W9+W2], W3
004C62  E00003     CP0 W3
004C64  320006     BRA Z, .L172
4633:                              {
4634:                                  usbClientDrvTable[pInterface->clientDriver].DataEventHandler(address, event, data, size);
004C52  B81861     MUL.UU W3, #1, W0
004C54  9FBF90     MOV W0, [W15-14]
004C56  9FBFA1     MOV W1, [W15-12]
004C66  97BA1F     MOV [W15-14], W4
004C68  97BAAF     MOV [W15-12], W5
004C6A  78010A     MOV W10, W2
004C6C  78008B     MOV W11, W1
004C6E  78400C     MOV.B W12, W0
004C70  010003     CALL W3
4635:                              }
4636:                              pInterface = pInterface->next;
004C72  780418     MOV [W8], W8
4637:                          }
4638:                          break;
4639:                  }
4640:              } // _USB_NotifyClients
004C78  78064F     MOV [--W15], W12
004C7A  BE054F     MOV.D [--W15], W10
004C7C  BE044F     MOV.D [--W15], W8
004C7E  FA8000     ULNK
004C80  060000     RETURN
4641:              
4642:              /****************************************************************************
4643:                Function:
4644:                  void _USB_NotifyAllDataClients( uint8_t address, USB_EVENT event, void *data,
4645:                              unsigned int size )
4646:              
4647:                Description:
4648:                  This routine notifies all client drivers (active or not) for the given device of
4649:                  the given event.
4650:              
4651:                Precondition:
4652:                  None
4653:              
4654:                Parameters:
4655:                  uint8_t address        - Address of the device generating the event
4656:                  USB_EVENT event     - Event ID
4657:                  void *data          - Pointer to event data
4658:                  unsigned int size   - Size of data pointed to by data
4659:              
4660:                Returns:
4661:                  None
4662:              
4663:                Remarks:
4664:                  When this driver is modified to support multiple devices, this function
4665:                  will require modification.
4666:                ***************************************************************************/
4667:              #if defined(USB_ENABLE_1MS_EVENT) && defined(USB_HOST_APP_DATA_EVENT_HANDLER)
4668:              void _USB_NotifyAllDataClients( uint8_t address, USB_EVENT event, void *data, unsigned int size )
4669:              {
4670:                  uint16_t i;
4671:              
4672:                  // Some events go to all drivers, some only to specific drivers.
4673:                  switch(event)
4674:                  {
4675:                      default:
4676:                          for(i=0;i<NUM_CLIENT_DRIVER_ENTRIES;i++)
4677:                          {
4678:                              if ( usbClientDrvTable[i].DataEventHandler != NULL )
4679:                              {
4680:                                  usbClientDrvTable[i].DataEventHandler(address, event, data, size);
4681:                              }
4682:                          }
4683:                          break;
4684:                  }
4685:              } // _USB_NotifyClients
4686:              #endif
4687:              
4688:              /****************************************************************************
4689:                Function:
4690:                  bool _USB_ParseConfigurationDescriptor( void )
4691:              
4692:                Description:
4693:                  This function parses all the endpoint descriptors for the required
4694:                  setting of the required interface and sets up the internal endpoint
4695:                  information.
4696:              
4697:                Precondition:
4698:                  pCurrentConfigurationDescriptor points to a valid Configuration
4699:                  Descriptor, which contains the endpoint descriptors.  The current
4700:                  interface and the current interface settings must be set up in
4701:                  usbDeviceInfo.
4702:              
4703:                Parameters:
4704:                  None - None
4705:              
4706:                Returns:
4707:                  true    - Successful
4708:                  false   - Configuration not supported.
4709:              
4710:                Remarks:
4711:                  * This function also automatically resets all endpoints (except
4712:                      endpoint 0) to DATA0, so _USB_ResetDATA0 does not have to be
4713:                      called.
4714:              
4715:                  * If the configuration is not supported, the caller will need to clean
4716:                      up, freeing memory by calling _USB_FreeConfigMemory.
4717:              
4718:                  * We do not currently implement checks for descriptors that are shorter
4719:                      than the expected length, in the case of invalid USB Peripherals.
4720:              
4721:                  * If there is not enough available heap space for storing the
4722:                      interface or endpoint information, this function will return false.
4723:                      Currently, there is no other mechanism for informing the user of
4724:                      an out of dynamic memory condition.
4725:              
4726:                  * We are assuming that we can support a single interface on a single
4727:                      device.  When the driver is modified to support multiple devices,
4728:                      each endpoint should be checked to ensure that we have enough
4729:                      bandwidth to support it.
4730:                ***************************************************************************/
4731:              
4732:              bool _USB_ParseConfigurationDescriptor( void )
004DCC  780080     MOV W0, W1
004DCE  A7F001     BTSC W1, #15
004DD0  EA0081     NEG W1, W1
004DD2  E90081     DEC W1, W1
004DD4  DE08CF     LSR W1, #15, W1
4733:              {
004C82  4787F0     ADD W15, #0x10, W15
004C84  BE9F88     MOV.D W8, [W15++]
004C86  BE9F8A     MOV.D W10, [W15++]
004C88  BE9F8C     MOV.D W12, [W15++]
004C8A  781F8E     MOV W14, [W15++]
4734:                  uint8_t                        bAlternateSetting;
4735:                  uint8_t                        bDescriptorType;
4736:                  uint8_t                        bInterfaceNumber;
4737:                  uint8_t                        bLength;
4738:                  uint8_t                        bNumEndpoints;
4739:                  uint8_t                        bNumInterfaces;
4740:                  uint8_t                        bMaxPower;
4741:                  bool                        error;
4742:                  uint8_t                        Class;
4743:                  uint8_t                        SubClass;
4744:                  uint8_t                        Protocol;
4745:                  uint8_t                        ClientDriver;
4746:                  uint16_t                        wTotalLength;
4747:              
4748:                  uint8_t                        currentAlternateSetting;
4749:                  uint8_t                        currentConfiguration;
4750:                  uint8_t                        currentEndpoint;
4751:                  uint8_t                        currentInterface;
4752:                  uint16_t                        index;
4753:                  USB_ENDPOINT_INFO           *newEndpointInfo;
4754:                  USB_INTERFACE_INFO          *newInterfaceInfo;
4755:                  USB_INTERFACE_SETTING_INFO  *newSettingInfo;
4756:                  USB_VBUS_POWER_EVENT_DATA   powerRequest;
4757:                  USB_INTERFACE_INFO          *pTempInterfaceList;
4758:                  uint8_t                        *ptr;
4759:              
4760:                  // Prime the loops.
4761:                  currentEndpoint         = 0;
004CD8  784681     MOV.B W1, W13
4762:                  error                   = false;
4763:                  index                   = 0;
4764:                  ptr                     = pCurrentConfigurationDescriptor;
4765:                  currentInterface        = 0;
4766:                  currentAlternateSetting = 0;
4767:                  pTempInterfaceList      = usbDeviceInfo.pInterfaceList; // Don't set until everything is in place.
004C8C  804B59     MOV 0x96A, W9
4768:              
4769:                  // Assume no OTG support (determine otherwise, below).
4770:                  usbDeviceInfo.flags.bfSupportsOTG   = 0;
004C8E  2096E0     MOV #0x96E, W0
004C90  A11010     BCLR [W0], #1
4771:                  usbDeviceInfo.flags.bfConfiguredOTG = 1;
004C92  A02010     BSET [W0], #2
4772:              
4773:                  #ifdef USB_SUPPORT_OTG
4774:                      usbDeviceInfo.flags.bfAllowHNP = 1;  //Allow HNP From Host
4775:                  #endif
4776:              
4777:                  // Load up the values from the Configuration Descriptor
4778:                  bLength              = *ptr++;
004C94  807D20     MOV pCurrentConfigurationDescriptor, W0
004C96  7845B0     MOV.B [W0++], W11
4779:                  bDescriptorType      = *ptr++;
4780:                  wTotalLength         = *ptr++;           // In case these are not word aligned
004C98  E80000     INC W0, W0
004C9A  784430     MOV.B [W0++], W8
004CC6  FB8408     ZE W8, W8
4781:                  wTotalLength        += (*ptr++) << 8;
004C9C  784530     MOV.B [W0++], W10
004CC8  DD5648     SL W10, #8, W12
004CCA  460608     ADD W12, W8, W12
4782:                  bNumInterfaces       = *ptr++;
4783:                  currentConfiguration = *ptr++;  // bConfigurationValue
004C9E  E80000     INC W0, W0
004CA0  7840B0     MOV.B [W0++], W1
004CA2  9FEF81     MOV.B W1, [W15-24]
4784:                                          ptr++;  // iConfiguration
4785:                                          ptr++;  // bmAttributes
4786:                  bMaxPower            = *ptr;
004CA4  904020     MOV.B [W0+2], W0
004CA6  9FEF90     MOV.B W0, [W15-23]
4787:              
4788:                  // Check Max Power to see if we can support this configuration.
4789:                  powerRequest.current = bMaxPower;
004CA8  9FE7E0     MOV.B W0, [W15-26]
4790:                  powerRequest.port    = 0;        // Port 0
004CAA  57817C     SUB W15, #0x1C, W2
004CAC  EB6900     CLR.B [++W2]
4791:                  if (!USB_HOST_APP_EVENT_HANDLER( USB_ROOT_HUB, EVENT_VBUS_REQUEST_POWER,
004CAE  200024     MOV #0x2, W4
004CB0  200005     MOV #0x0, W5
004CB2  200691     MOV #0x69, W1
004CB4  EBC000     SETM.B W0
004CB6  072EFE     RCALL USB_Host_ApplicationEventHandler
004CB8  E00400     CP0.B W0
004CBA  3A0005     BRA NZ, .L177
4792:                          &powerRequest, sizeof(USB_VBUS_POWER_EVENT_DATA) ))
4793:                  {
4794:                      usbDeviceInfo.errorCode = USB_ERROR_INSUFFICIENT_POWER;
004CBC  B3C281     MOV.B #0x28, W1
004CBE  209620     MOV #0x962, W0
004CC0  784801     MOV.B W1, [W0]
4795:                      error = true;
004CC2  B3C011     MOV.B #0x1, W1
004CC4  3700DF     BRA .L178
4796:                  }
4797:              
4798:                  // Skip over the rest of the Configuration Descriptor
4799:                  index += bLength;
004CCC  FB850B     ZE W11, W10
4800:                  ptr    = &pCurrentConfigurationDescriptor[index];
004CCE  807D20     MOV pCurrentConfigurationDescriptor, W0
004CD6  40000A     ADD W0, W10, W0
4801:              
4802:                  while (!error && (index < wTotalLength))
004CD0  EB4080     CLR.B W1
004CD2  560F8A     SUB W12, W10, [W15]
004CD4  3600D7     BRA LEU, .L178
004E6E  E00401     CP0.B W1
004E70  3A0008     BRA NZ, .L230
004E72  560F8A     SUB W12, W10, [W15]
004E74  3EFF34     BRA GTU, .L199
004E76  97BC8F     MOV [W15-16], W9
004E78  EB4080     CLR.B W1
004E7A  370004     BRA .L178
004E7C  97BC8F     MOV [W15-16], W9
4803:                  {
4804:                      // Check the descriptor length and type
4805:                      bLength         = *ptr++;
004CDE  78000B     MOV W11, W0
004CE0  7845B0     MOV.B [W0++], W11
4806:                      bDescriptorType = *ptr++;
004CE2  7840B0     MOV.B [W0++], W1
4807:              
4808:              
4809:                      // Find the OTG discriptor (if present)
4810:                      if (bDescriptorType == USB_DESCRIPTOR_OTG)
004CE4  50CFE9     SUB.B W1, #0x9, [W15]
004CE6  3A000E     BRA NZ, .L179
4811:                      {
4812:                          // We found an OTG Descriptor, so the device supports OTG.
4813:                          usbDeviceInfo.flags.bfSupportsOTG = 1;
004CE8  2096E2     MOV #0x96E, W2
004CEA  A01012     BSET [W2], #1
4814:                          usbDeviceInfo.attributesOTG       = *ptr;
004CDA  9FBF89     MOV W9, [W15-16]
004CDC  780580     MOV W0, W11
004CEC  784010     MOV.B [W0], W0
004CEE  5101EF     SUB W2, #0xF, W3
004CF0  784980     MOV.B W0, [W3]
4815:              
4816:                          // See if we need to send the SET FEATURE command.  If we do,
4817:                          // clear the bConfiguredOTG flag.
4818:                          if ( (usbDeviceInfo.attributesOTG & OTG_HNP_SUPPORT) && (usbDeviceInfo.flags.bfAllowHNP))
004CF2  A31800     BTST.Z W0, #1
004CF4  320004     BRA Z, .L180
004CF6  A33812     BTST.Z [W2], #3
004CF8  320002     BRA Z, .L180
4819:                          {
4820:                              usbDeviceInfo.flags.bfConfiguredOTG = 0;
004CFA  A12012     BCLR [W2], #2
004CFC  370005     BRA .L181
4821:                          }
4822:                          else
4823:                          {
4824:                              usbDeviceInfo.flags.bfAllowHNP = 0;
004CFE  2096E4     MOV #0x96E, W4
004D00  A13014     BCLR [W4], #3
004D02  370002     BRA .L181
4825:                          }
4826:                      }
4827:              
4828:                      // Find an interface descriptor
4829:                      if (bDescriptorType != USB_DESCRIPTOR_INTERFACE)
004D04  50CFE4     SUB.B W1, #0x4, [W15]
004D06  320006     BRA Z, .L182
4830:                      {
4831:                          // Skip over the rest of the Descriptor
4832:                          index += bLength;
004D08  FB858B     ZE W11, W11
004D0A  45050B     ADD W10, W11, W10
4833:                          ptr = &pCurrentConfigurationDescriptor[index];
004D0C  78000A     MOV W10, W0
004D0E  B40FA4     ADD pCurrentConfigurationDescriptor, WREG
004D10  780580     MOV W0, W11
004D12  3700AF     BRA .L210
4834:                      }
4835:                      else
4836:                      {
4837:                          // Read some data from the interface descriptor
4838:                          bInterfaceNumber  = *ptr++;
004D14  784490     MOV.B [W0], W9
4839:                          bAlternateSetting = *ptr++;
004D16  7840D0     MOV.B [++W0], W1
004D18  9FEFA1     MOV.B W1, [W15-22]
004D1A  780100     MOV W0, W2
4840:                          bNumEndpoints     = *ptr++;
004D1C  784752     MOV.B [++W2], W14
4841:                          Class             = *ptr++;
004D1E  784052     MOV.B [++W2], W0
4842:                          SubClass          = *ptr++;
004D20  7840D2     MOV.B [++W2], W1
004D22  9FB7F2     MOV W2, [W15-18]
4843:                          Protocol          = *ptr++;
004D24  780182     MOV W2, W3
004D26  784153     MOV.B [++W3], W2
004D28  9FB7F3     MOV W3, [W15-18]
004D90  97B2FF     MOV [W15-18], W5
004D92  E80585     INC W5, W11
004D94  B3C011     MOV.B #0x1, W1
004D96  370069     BRA .L191
4844:              
4845:                          // Get client driver index
4846:                          if (usbDeviceInfo.flags.bfUseDeviceClientDriver)
004D2A  200405     MOV #0x40, W5
004D2C  2096E4     MOV #0x96E, W4
004D2E  628194     AND W5, [W4], W3
004D30  320004     BRA Z, .L184
4847:                          {
4848:                              ClientDriver = usbDeviceInfo.deviceClientDriver;
004D32  52006B     SUB W4, #0xB, W0
004D34  784010     MOV.B [W0], W0
004D36  9FE7C0     MOV.B W0, [W15-28]
004D38  37000A     BRA .L185
4849:                          }
4850:                          else
4851:                          {
4852:                              if (!_USB_FindClassDriver(Class, SubClass, Protocol, &ClientDriver))
004D3A  5781FC     SUB W15, #0x1C, W3
004D3C  07FC02     RCALL _USB_FindClassDriver
004D3E  E00400     CP0.B W0
004D40  3A0006     BRA NZ, .L185
4853:                              {
4854:                                  // If we cannot support this interface, skip it.
4855:                                  index += bLength;
004D42  FB858B     ZE W11, W11
004D44  45050B     ADD W10, W11, W10
4856:                                  ptr = &pCurrentConfigurationDescriptor[index];
004D46  78000A     MOV W10, W0
004D48  B40FA4     ADD pCurrentConfigurationDescriptor, WREG
004D4A  780580     MOV W0, W11
4857:                                  continue;
004D4C  370092     BRA .L210
4858:                              }
4859:                          }
4860:              
4861:                          // We can support this interface.  See if we already have a USB_INTERFACE_INFO node for it.
4862:                          newInterfaceInfo = pTempInterfaceList;
4863:                          while ((newInterfaceInfo != NULL) && (newInterfaceInfo->interface != bInterfaceNumber))
004D4E  97B88F     MOV [W15-16], W1
004D50  E00001     CP0 W1
004D52  32000B     BRA Z, .L186
004D54  904061     MOV.B [W1+6], W0
004D56  504F89     SUB.B W0, W9, [W15]
004D58  3200C4     BRA Z, .L212
004D5A  780401     MOV W1, W8
004D5E  E00008     CP0 W8
004D60  320004     BRA Z, .L186
004D62  904068     MOV.B [W8+6], W0
004D64  504F89     SUB.B W0, W9, [W15]
004D66  3AFFFA     BRA NZ, .L188
004D68  37000E     BRA .L207
004EE2  97BC0F     MOV [W15-16], W8
004EE4  37FF50     BRA .L207
4864:                          {
4865:                              newInterfaceInfo = newInterfaceInfo->next;
004D5C  780418     MOV [W8], W8
4866:                          }
4867:                          if (newInterfaceInfo == NULL)
4868:                          {
4869:                              // This is the first instance of this interface, so create a new node for it.
4870:                              if ((newInterfaceInfo = (USB_INTERFACE_INFO *)USB_MALLOC( sizeof(USB_INTERFACE_INFO) )) == NULL)
004D6A  200080     MOV #0x8, W0
004D6C  07DB72     RCALL 0x452
004D6E  780400     MOV W0, W8
004D70  E00008     CP0 W8
004D72  32000E     BRA Z, .L189
4871:                              {
4872:                                  // Out of memory
4873:                                  error = true;
4874:              
4875:                              }
4876:              
4877:                              if(error == false)
4878:                              {
4879:                                  // Initialize the interface node
4880:                                  newInterfaceInfo->interface             = bInterfaceNumber;
004D74  984469     MOV.B W9, [W8+6]
4881:                                  newInterfaceInfo->clientDriver          = ClientDriver;
004D76  97E14F     MOV.B [W15-28], W2
004D78  984472     MOV.B W2, [W8+7]
4882:                                  newInterfaceInfo->pInterfaceSettings    = NULL;
004D7A  EB0000     CLR W0
004D7C  980410     MOV W0, [W8+2]
4883:                                  newInterfaceInfo->pCurrentSetting       = NULL;
004D7E  980420     MOV W0, [W8+4]
4884:              
4885:                                  // Insert it into the list.
4886:                                  newInterfaceInfo->next                  = pTempInterfaceList;
004D80  97B98F     MOV [W15-16], W3
004D82  780C03     MOV W3, [W8]
4887:                                  pTempInterfaceList                      = newInterfaceInfo;
004D84  9FBF88     MOV W8, [W15-16]
4888:                              }
4889:                          }
4890:              
4891:                          if (!error)
4892:                          {
4893:                              // Create a new setting for this interface, and add it to the list.
4894:                              if ((newSettingInfo = (USB_INTERFACE_SETTING_INFO *)USB_MALLOC( sizeof(USB_INTERFACE_SETTING_INFO) )) == NULL)
004D86  200060     MOV #0x6, W0
004D88  07DB64     RCALL 0x452
004D8A  9FB7E0     MOV W0, [W15-20]
004D8C  E00000     CP0 W0
004D8E  3A00AB     BRA NZ, .L190
4895:                              {
4896:                                  // Out of memory
4897:                                  error = true;
4898:                              }
4899:                          }
4900:              
4901:                          if (!error)
4902:                          {
4903:                              newSettingInfo->next                    = newInterfaceInfo->pInterfaceSettings;
004EE6  900298     MOV [W8+2], W5
004EE8  97B26F     MOV [W15-20], W4
004EEA  780A05     MOV W5, [W4]
4904:                              newSettingInfo->interfaceAltSetting     = bAlternateSetting;
004EEC  97E82F     MOV.B [W15-22], W0
004EEE  984220     MOV.B W0, [W4+2]
4905:                              newSettingInfo->pEndpointList           = NULL;
004EF0  EB0000     CLR W0
004EF2  980220     MOV W0, [W4+4]
4906:                              newInterfaceInfo->pInterfaceSettings    = newSettingInfo;
004EF4  980414     MOV W4, [W8+2]
4907:                              if (bAlternateSetting == 0)
004EF6  97E8AF     MOV.B [W15-22], W1
004EF8  E00401     CP0.B W1
004EFA  32FF4E     BRA Z, .L208
004EFC  37FF54     BRA .L231
4908:                              {
4909:                                  newInterfaceInfo->pCurrentSetting   = newSettingInfo;
004D98  97B06F     MOV [W15-20], W0
004D9A  980420     MOV W0, [W8+4]
4910:                              }
4911:              
4912:                              // Skip over the rest of the Interface Descriptor
4913:                              index += bLength;
004D9C  FB858B     ZE W11, W11
004D9E  45050B     ADD W10, W11, W10
004DA6  FB858B     ZE W11, W11
004DA8  45050B     ADD W10, W11, W10
4914:                              ptr = &pCurrentConfigurationDescriptor[index];
004DA0  807D29     MOV pCurrentConfigurationDescriptor, W9
004DA2  44858A     ADD W9, W10, W11
004DA4  370004     BRA .L192
004DAA  807D29     MOV pCurrentConfigurationDescriptor, W9
004DAC  44858A     ADD W9, W10, W11
4915:              
4916:                              // Find the Endpoint Descriptors.  There might be Class and Vendor descriptors in here
4917:                              currentEndpoint = 0;
004DB6  EB4680     CLR.B W13
004E62  EB4680     CLR.B W13
004EFE  EB4680     CLR.B W13
004F00  37FFB8     BRA .L210
4918:                              while (!error && (index < wTotalLength) && (currentEndpoint < bNumEndpoints))
004DAE  560F8A     SUB W12, W10, [W15]
004DB0  360058     BRA LEU, .L213
004DB2  E0040E     CP0.B W14
004DB4  3200A4     BRA Z, .L214
004E52  E00401     CP0.B W1
004E54  3A000A     BRA NZ, .L191
004E56  560F8A     SUB W12, W10, [W15]
004E58  360007     BRA LEU, .L215
004E5A  574F8D     SUB.B W14, W13, [W15]
004E5C  3EFFAD     BRA GTU, .L198
004E5E  EB4080     CLR.B W1
004E60  370004     BRA .L191
004E64  78408D     MOV.B W13, W1
004E66  370001     BRA .L191
004E68  EB4080     CLR.B W1
4919:                              {
4920:                                  bLength = *ptr++;
004DB8  78441B     MOV.B [W11], W8
4921:                                  bDescriptorType = *ptr++;
4922:              
4923:                                  if (bDescriptorType != USB_DESCRIPTOR_ENDPOINT)
004DBA  B3C051     MOV.B #0x5, W1
004DBC  10CFDB     SUBR.B W1, [++W11], [W15]
004DBE  320004     BRA Z, .L193
4924:                                  {
4925:                                      // Skip over the rest of the Descriptor
4926:                                      index += bLength;
004DC0  FB8408     ZE W8, W8
004DC2  450508     ADD W10, W8, W10
4927:                                      ptr = &pCurrentConfigurationDescriptor[index];
004DC4  44858A     ADD W9, W10, W11
004DC6  370047     BRA .L194
4928:                                  }
4929:                                  else
4930:                                  {
4931:                                      // Create an entry for the new endpoint.
4932:                                      if ((newEndpointInfo = (USB_ENDPOINT_INFO *)USB_MALLOC( sizeof(USB_ENDPOINT_INFO) )) == NULL)
004DC8  200220     MOV #0x22, W0
004DCA  07DB43     RCALL 0x452
4933:                                      {
4934:                                          // Out of memory
4935:                                          error = true;
4936:                                      }
4937:                                      newEndpointInfo->bEndpointAddress           = *ptr++;
004DD6  78415B     MOV.B [++W11], W2
004DD8  985822     MOV.B W2, [W0+26]
004DDA  78010B     MOV W11, W2
4938:                                      newEndpointInfo->bmAttributes.val           = *ptr++;
004DDC  7841D2     MOV.B [++W2], W3
004DDE  985833     MOV.B W3, [W0+27]
4939:                                      newEndpointInfo->wMaxPacketSize             = *ptr++;
004DE0  FB81D2     ZE [++W2], W3
004DE2  980043     MOV W3, [W0+8]
4940:                                      newEndpointInfo->wMaxPacketSize            += (*ptr++) << 8;
004DE4  FB8252     ZE [++W2], W4
004DE6  DD2248     SL W4, #8, W4
004DE8  420183     ADD W4, W3, W3
004DEA  980043     MOV W3, [W0+8]
4941:                                      newEndpointInfo->wInterval                  = *ptr++;
004DEC  904192     MOV.B [W2+1], W3
004DEE  FB8183     ZE W3, W3
004DF0  980023     MOV W3, [W0+4]
4942:                                      newEndpointInfo->status.val                 = 0x00;
004DF2  EB0100     CLR W2
004DF4  980012     MOV W2, [W0+2]
4943:                                      newEndpointInfo->status.bfUseDTS            = 1;
004DF6  900210     MOV [W0+2], W4
004DF8  A0A004     BSET W4, #10
004DFA  980014     MOV W4, [W0+2]
4944:                                      newEndpointInfo->status.bfTransferComplete  = 1;  // Initialize to success to allow preprocessing loops.
004DFC  900210     MOV [W0+2], W4
004DFE  A09004     BSET W4, #9
004E00  980014     MOV W4, [W0+2]
4945:                                      newEndpointInfo->dataCount                  = 0;  // Initialize to 0 since we set bfTransferComplete.
004E02  B82260     MUL.UU W4, #0, W4
004E04  980804     MOV W4, [W0+16]
004E06  980815     MOV W5, [W0+18]
4946:                                      newEndpointInfo->transferState              = TSTATE_IDLE;
004E08  985802     MOV.B W2, [W0+24]
4947:                                      newEndpointInfo->clientDriver               = ClientDriver;
004E0A  97E2CF     MOV.B [W15-28], W5
004E0C  985815     MOV.B W5, [W0+25]
4948:              
4949:                                      // Special setup for isochronous endpoints.
4950:                                      if (newEndpointInfo->bmAttributes.bfTransferType == USB_TRANSFER_TYPE_ISOCHRONOUS)
004E0E  900950     MOV [W0+26], W2
004E10  203004     MOV #0x300, W4
004E12  610104     AND W2, W4, W2
004E14  201005     MOV #0x100, W5
004E16  510F85     SUB W2, W5, [W15]
004E18  3A0011     BRA NZ, .L195
4951:                                      {
4952:                                          // Validate and convert the interval to the number of frames.  The value must
4953:                                          // be between 1 and 16, and the frames is 2^(bInterval-1).
4954:                                          if (newEndpointInfo->wInterval == 0) newEndpointInfo->wInterval = 1;
004E1A  E00003     CP0 W3
004E1C  3A0003     BRA NZ, .L196
004E1E  200012     MOV #0x1, W2
004E20  980022     MOV W2, [W0+4]
004E22  370004     BRA .L197
4955:                                          if (newEndpointInfo->wInterval > 16) newEndpointInfo->wInterval = 16;
004E24  518FF0     SUB W3, #0x10, [W15]
004E26  360002     BRA LEU, .L197
004E28  200102     MOV #0x10, W2
004E2A  980022     MOV W2, [W0+4]
4956:                                          newEndpointInfo->wInterval = 1 << (newEndpointInfo->wInterval-1);
004E2C  900120     MOV [W0+4], W2
004E2E  E90102     DEC W2, W2
004E30  200013     MOV #0x1, W3
004E32  DD1902     SL W3, W2, W2
004E34  980022     MOV W2, [W0+4]
4957:              
4958:                                          // Disable DTS
4959:                                          newEndpointInfo->status.bfUseDTS = 0;
004E36  900110     MOV [W0+2], W2
004E38  A1A002     BCLR W2, #10
004E3A  980012     MOV W2, [W0+2]
4960:                                      }
4961:              
4962:                                      // Initialize interval count
4963:                                      newEndpointInfo->wIntervalCount = newEndpointInfo->wInterval;
004E3C  900120     MOV [W0+4], W2
004E3E  980032     MOV W2, [W0+6]
4964:              
4965:                                      // Put the new endpoint in the list.
4966:                                      newEndpointInfo->next           = newSettingInfo->pEndpointList;
004E40  97B1EF     MOV [W15-20], W3
004E42  9001A3     MOV [W3+4], W3
004E44  780803     MOV W3, [W0]
4967:                                      newSettingInfo->pEndpointList   = newEndpointInfo;
004E46  97B26F     MOV [W15-20], W4
004E48  980220     MOV W0, [W4+4]
4968:              
4969:                                      // When multiple devices are supported, check the available
4970:                                      // bandwidth here to make sure that we can support this
4971:                                      // endpoint.
4972:              
4973:                                      // Get ready for the next endpoint.
4974:                                      currentEndpoint++;
004E4A  E8468D     INC.B W13, W13
4975:                                      index += bLength;
004E4C  FB8408     ZE W8, W8
004E4E  450508     ADD W10, W8, W10
4976:                                      ptr = &pCurrentConfigurationDescriptor[index];
004E50  44858A     ADD W9, W10, W11
4977:                                  }
4978:                              }
4979:                          }
4980:              
4981:                          // Ensure that we found all the endpoints for this interface.
4982:                          if (currentEndpoint != bNumEndpoints)
004E6A  56CF8E     SUB.B W13, W14, [W15]
004E6C  3A0007     BRA NZ, .L216
4983:                          {
4984:                              error = true;
004E7E  B3C011     MOV.B #0x1, W1
004E80  370001     BRA .L178
004E82  97BC8F     MOV [W15-16], W9
4985:                          }
4986:                      }
4987:                  }
4988:              
4989:                  // Ensure that we found all the interfaces in this configuration.
4990:                  // This is a nice check, but some devices have errors where they have a
4991:                  // different number of interfaces than they report they have!
4992:              //    if (currentInterface != bNumInterfaces)
4993:              //    {
4994:              //        error = true;
4995:              //    }
4996:              
4997:                  if (pTempInterfaceList == NULL)
004E86  E00009     CP0 W9
004E88  320026     BRA Z, .L200
4998:                  {
4999:                      // We could find no supported interfaces.
5000:              #if defined (DEBUG_ENABLE)
5001:                      DEBUG_PutString( "HOST: No supported interfaces.\r\n" );
5002:              #endif
5003:              
5004:                      error = true;
5005:                  }
5006:              
5007:                  if (error)
004E8A  E00401     CP0.B W1
004E8C  32001C     BRA Z, .L201
004E8E  370001     BRA .L226
5008:                  {
5009:                      // Destroy whatever list of interfaces, settings, and endpoints we created.
5010:                      // The "new" variables point to the current node we are trying to remove.
5011:                      while (pTempInterfaceList != NULL)
004EBE  E0000A     CP0 W10
004EC0  3AFFE7     BRA NZ, .L218
5012:                      {
5013:                          newInterfaceInfo = pTempInterfaceList;
5014:                          pTempInterfaceList = pTempInterfaceList->next;
004E90  78048A     MOV W10, W9
004E92  780519     MOV [W9], W10
5015:              
5016:                          while (newInterfaceInfo->pInterfaceSettings != NULL)
004E94  900419     MOV [W9+2], W8
004E96  E00008     CP0 W8
004E98  320010     BRA Z, .L202
004EB4  900419     MOV [W9+2], W8
004EB6  E00008     CP0 W8
004EB8  3AFFF0     BRA NZ, .L219
5017:                          {
5018:                              newSettingInfo = newInterfaceInfo->pInterfaceSettings;
5019:                              newInterfaceInfo->pInterfaceSettings = newInterfaceInfo->pInterfaceSettings->next;
004E9A  780298     MOV [W8], W5
004E9C  980495     MOV W5, [W9+2]
5020:              
5021:                              while (newSettingInfo->pEndpointList != NULL)
004E9E  900028     MOV [W8+4], W0
004EA0  E00000     CP0 W0
004EA2  320006     BRA Z, .L203
004EAA  900028     MOV [W8+4], W0
004EAC  E00000     CP0 W0
004EAE  3AFFFA     BRA NZ, .L220
5022:                              {
5023:                                  newEndpointInfo = newSettingInfo->pEndpointList;
5024:                                  newSettingInfo->pEndpointList = newSettingInfo->pEndpointList->next;
004EA4  780090     MOV [W0], W1
004EA6  980421     MOV W1, [W8+4]
5025:              
5026:                                  USB_FREE_AND_CLEAR( newEndpointInfo );
004EA8  07DA6F     RCALL 0x388
5027:                              }
5028:              
5029:                              USB_FREE_AND_CLEAR( newSettingInfo );
004EB0  780008     MOV W8, W0
004EB2  07DA6A     RCALL 0x388
5030:                          }
5031:              
5032:                          USB_FREE_AND_CLEAR( newInterfaceInfo );
004EBA  780009     MOV W9, W0
004EBC  07DA65     RCALL 0x388
5033:                      }
5034:                      return false;
004E84  EB4000     CLR.B W0
004EC2  EB4000     CLR.B W0
004EC4  370008     BRA .L200
5035:                  }
5036:                  else
5037:                  {
5038:                      // Set configuration.
5039:                      usbDeviceInfo.currentConfiguration      = currentConfiguration;
004EC6  2095E0     MOV #0x95E, W0
004EC8  97E90F     MOV.B [W15-24], W2
004ECA  784802     MOV.B W2, [W0]
5040:                      usbDeviceInfo.currentConfigurationPower = bMaxPower;
004ECC  97E99F     MOV.B [W15-23], W3
004ECE  FB8003     ZE W3, W0
004ED0  884B30     MOV W0, 0x966
5041:              
5042:                      // Success!
5043:              #if defined (DEBUG_ENABLE)
5044:                      DEBUG_PutString( "HOST: Parse Descriptor success\r\n" );
5045:              #endif
5046:              
5047:                      usbDeviceInfo.pInterfaceList = pTempInterfaceList;
004ED2  884B59     MOV W9, 0x96A
5048:                      return true;
004ED4  B3C010     MOV.B #0x1, W0
5049:                  }
5050:              }
004ED6  78074F     MOV [--W15], W14
004ED8  BE064F     MOV.D [--W15], W12
004EDA  BE054F     MOV.D [--W15], W10
004EDC  BE044F     MOV.D [--W15], W8
004EDE  B1010F     SUB #0x10, W15
004EE0  060000     RETURN
004EE2  97BC0F     MOV [W15-16], W8
004EE4  37FF50     BRA .L207
004EE6  900298     MOV [W8+2], W5
004EE8  97B26F     MOV [W15-20], W4
004EEA  780A05     MOV W5, [W4]
004EEC  97E82F     MOV.B [W15-22], W0
004EEE  984220     MOV.B W0, [W4+2]
004EF0  EB0000     CLR W0
004EF2  980220     MOV W0, [W4+4]
004EF4  980414     MOV W4, [W8+2]
004EF6  97E8AF     MOV.B [W15-22], W1
004EF8  E00401     CP0.B W1
004EFA  32FF4E     BRA Z, .L208
004EFC  37FF54     BRA .L231
004EFE  EB4680     CLR.B W13
004F00  37FFB8     BRA .L210
5051:              
5052:              
5053:              /****************************************************************************
5054:                Function:
5055:                  void _USB_ResetDATA0( uint8_t endpoint )
5056:              
5057:                Description:
5058:                  This function resets DATA0 for the specified endpoint.  If the
5059:                  specified endpoint is 0, it resets DATA0 for all endpoints.
5060:              
5061:                Precondition:
5062:                  None
5063:              
5064:                Parameters:
5065:                  uint8_t endpoint   - Endpoint number to reset.
5066:              
5067:              
5068:                Returns:
5069:                  None
5070:              
5071:                Remarks:
5072:                  None
5073:                ***************************************************************************/
5074:              
5075:              void _USB_ResetDATA0( uint8_t endpoint )
5076:              {
5077:                  USB_ENDPOINT_INFO   *pEndpoint;
5078:              
5079:                  if (endpoint == 0)
00579E  E00400     CP0.B W0
0057A0  3A0016     BRA NZ, .L371, .LBE5
5080:                  {
5081:                      // Reset DATA0 for all endpoints.
5082:                      USB_INTERFACE_INFO          *pInterface;
5083:                      USB_INTERFACE_SETTING_INFO  *pSetting;
5084:              
5085:                      pInterface = usbDeviceInfo.pInterfaceList;
0057A2  804B53     MOV 0x96A, W3
5086:                      while (pInterface)
0057A4  E00003     CP0 W3
0057A6  320019     BRA Z, .L370
0057C8  E00003     CP0 W3
0057CA  3AFFEE     BRA NZ, .L378
0057CC  370006     BRA .L370
5087:                      {
5088:                          pSetting = pInterface->pInterfaceSettings;
0057A8  900113     MOV [W3+2], W2
5089:                          while (pSetting)
0057AA  E00002     CP0 W2
0057AC  32000C     BRA Z, .L373
0057C2  E00002     CP0 W2
0057C4  3AFFF4     BRA NZ, .L379
5090:                          {
5091:                              pEndpoint = pSetting->pEndpointList;
0057AE  900022     MOV [W2+4], W0
5092:                              while (pEndpoint)
0057B0  E00000     CP0 W0
0057B2  320006     BRA Z, .L374
0057BC  E00000     CP0 W0
0057BE  3AFFFA     BRA NZ, .L380
5093:                              {
5094:                                  pEndpoint->status.bfNextDATA01 = 0;
0057B4  900090     MOV [W0+2], W1
0057B6  A1B001     BCLR W1, #11
0057B8  980011     MOV W1, [W0+2]
5095:                                  pEndpoint = pEndpoint->next;
0057BA  780010     MOV [W0], W0
5096:                              }
5097:                              pSetting = pSetting->next;
0057C0  780112     MOV [W2], W2
5098:                          }
5099:                          pInterface = pInterface->next;
0057C6  780193     MOV [W3], W3
5100:                      }
5101:                  }
5102:                  else
5103:                  {
5104:                      pEndpoint = _USB_FindEndpoint( endpoint );
0057CE  07F765     RCALL _USB_FindEndpoint
5105:                      if (pEndpoint != NULL)
0057D0  E00000     CP0 W0
0057D2  320003     BRA Z, .L370
5106:                      {
5107:                          pEndpoint->status.bfNextDATA01 = 0;
0057D4  900090     MOV [W0+2], W1
0057D6  A1B001     BCLR W1, #11
0057D8  980011     MOV W1, [W0+2]
5108:                      }
5109:                  }
5110:              }
0057DA  060000     RETURN
5111:              
5112:              
5113:              /****************************************************************************
5114:                Function:
5115:                  void _USB_SendToken( uint8_t endpoint, uint8_t tokenType )
5116:              
5117:                Description:
5118:                  This function sets up the endpoint control register and sends the token.
5119:              
5120:                Precondition:
5121:                  None
5122:              
5123:                Parameters:
5124:                  uint8_t endpoint   - Endpoint number
5125:                  uint8_t tokenType  - Token to send
5126:              
5127:                Returns:
5128:                  None
5129:              
5130:                Remarks:
5131:                  If the device is low speed, the transfer must be set to low speed.  If
5132:                  the endpoint is isochronous, handshaking must be disabled.
5133:                ***************************************************************************/
5134:              
5135:              void _USB_SendToken( uint8_t endpoint, uint8_t tokenType )
5136:              {
5137:                  uint8_t    temp;
5138:              
5139:                  // Disable retries, disable control transfers, enable Rx and Tx and handshaking.
5140:                  temp = 0x5D;
0058EC  B3C5D2     MOV.B #0x5D, W2
5141:              
5142:                  // Enable low speed transfer if the device is low speed.
5143:                  if (usbDeviceInfo.flags.bfIsLowSpeed)
0058E4  804B73     MOV 0x96E, W3
0058E8  A30803     BTST.Z W3, #0
0058EA  3A0001     BRA NZ, .L416
5144:                  {
5145:                      temp |= 0x80;   // Set LSPD
0058E6  B3CDD2     MOV.B #0xDD, W2
5146:                  }
5147:              
5148:                  // Enable control transfers if necessary.
5149:                  if (pCurrentEndpoint->bmAttributes.bfTransferType == USB_TRANSFER_TYPE_CONTROL)
0058EE  807D73     MOV pCurrentEndpoint, W3
0058F0  900A53     MOV [W3+26], W4
0058F2  B23004     AND #0x300, W4
0058F4  3A0001     BRA NZ, .L417
5150:                  {
5151:                      temp &= 0xEF;   // Clear EPCONDIS
0058F6  A14402     BCLR.B W2, #4
5152:                  }
5153:              
5154:                  // Disable handshaking for isochronous endpoints.
5155:                  if (pCurrentEndpoint->bmAttributes.bfTransferType == USB_TRANSFER_TYPE_ISOCHRONOUS)
0058F8  900A53     MOV [W3+26], W4
0058FA  B23004     AND #0x300, W4
0058FC  201003     MOV #0x100, W3
0058FE  520F83     SUB W4, W3, [W15]
005900  3A0001     BRA NZ, .L418
5156:                  {
5157:                      temp &= 0xFE;   // Clear EPHSHK
005902  A10402     BCLR.B W2, #0
5158:                  }
5159:              
5160:                  U1EP0 = temp;
005904  FB8102     ZE W2, W2
005906  882552     MOV W2, U1EP0
5161:              
5162:                  U1ADDR = usbDeviceInfo.deviceAddressAndSpeed;
005908  209602     MOV #0x960, W2
00590A  FB8112     ZE [W2], W2
00590C  8824B2     MOV W2, U1ADDR
5163:                  U1TOK = (tokenType << 4) | (endpoint & 0x7F);
00590E  FB8081     ZE W1, W1
005910  DD08C4     SL W1, #4, W1
005912  B207F0     AND #0x7F, W0
005914  700001     IOR W0, W1, W0
005916  8824F0     MOV W0, U1TOK
5164:              
5165:                  // Lock out anyone from writing another token until this one has finished.
5166:              //    U1CONbits.TOKBUSY = 1;
5167:                  usbBusInfo.flags.bfTokenAlreadyWritten = 1;
005918  A88FB0     BSET usbBusInfo, #4
5168:              }
00591A  060000     RETURN
5169:              
5170:              
5171:              /****************************************************************************
5172:                Function:
5173:                  void _USB_SetBDT( uint8_t token )
5174:              
5175:                Description:
5176:                  This function sets up the BDT for the transfer.  The function handles the
5177:                  different ping-pong modes.
5178:              
5179:                Precondition:
5180:                  pCurrentEndpoint must point to the current endpoint being serviced.
5181:              
5182:                Parameters:
5183:                  uint8_t token  - Token for the transfer.  That way we can tell which
5184:                                  ping-pong buffer and which data pointer to use.  Valid
5185:                                  values are:
5186:                                      * USB_TOKEN_SETUP
5187:                                      * USB_TOKEN_IN
5188:                                      * USB_TOKEN_OUT
5189:              
5190:                Returns:
5191:                  None
5192:              
5193:                Remarks:
5194:                  None
5195:                ***************************************************************************/
5196:              
5197:              void _USB_SetBDT( uint8_t token )
5198:              {
00591C  BE9F88     MOV.D W8, [W15++]
5199:                  uint16_t                currentPacketSize;
5200:                  BDT_ENTRY           *pBDT;
5201:              
5202:                  if (token == USB_TOKEN_IN)
00591E  504FE9     SUB.B W0, #0x9, [W15]
005920  3A000F     BRA NZ, .L421
5203:                  {
5204:                      // Find the BDT we need to use.
5205:                      #if (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)
5206:                          pBDT = BDT_IN;
00592A  5080E4     SUB W1, #0x4, W1
5207:                          if (usbDeviceInfo.flags.bfPingPongIn)
005922  804B72     MOV 0x96E, W2
005926  A34802     BTST.Z W2, #4
005928  3A0001     BRA NZ, .L422
5208:                          {
5209:                              pBDT = BDT_IN_ODD;
005924  20A041     MOV #0xA04, W1
5210:                          }
5211:                      #else
5212:                          pBDT = BDT_IN;
5213:                      #endif
5214:              
5215:                      // Set up ping-pong for the next transfer
5216:                      #if (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)
5217:                          usbDeviceInfo.flags.bfPingPongIn = ~usbDeviceInfo.flags.bfPingPongIn;
00592C  2096E2     MOV #0x96E, W2
00592E  780192     MOV [W2], W3
005930  DE19C4     LSR W3, #4, W3
005932  EA8183     COM W3, W3
005934  6181E1     AND W3, #0x1, W3
005936  DD19C4     SL W3, #4, W3
005938  780212     MOV [W2], W4
00593A  A14004     BCLR W4, #4
00593C  720903     IOR W4, W3, [W2]
00593E  370023     BRA .L423
5218:                      #endif
5219:                  }
5220:                  else  // USB_TOKEN_OUT or USB_TOKEN_SETUP
5221:                  {
5222:                      // Find the BDT we need to use.
5223:                      #if (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG) || (USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY)
5224:                          pBDT = BDT_OUT;
005948  5080E4     SUB W1, #0x4, W1
5225:                          if (usbDeviceInfo.flags.bfPingPongOut)
005940  804B72     MOV 0x96E, W2
005944  A35802     BTST.Z W2, #5
005946  3A0001     BRA NZ, .L424
5226:                          {
5227:                              pBDT = BDT_OUT_ODD;
005942  20A0C1     MOV #0xA0C, W1
5228:                          }
5229:                      #else
5230:                          pBDT = BDT_OUT;
5231:                      #endif
5232:              
5233:                      // Set up ping-pong for the next transfer
5234:                      #if (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG) || (USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY)
5235:                          usbDeviceInfo.flags.bfPingPongOut = ~usbDeviceInfo.flags.bfPingPongOut;
00594A  2096E2     MOV #0x96E, W2
00594C  780192     MOV [W2], W3
00594E  DE19C5     LSR W3, #5, W3
005950  EA8183     COM W3, W3
005952  6181E1     AND W3, #0x1, W3
005954  DD19C5     SL W3, #5, W3
005956  780212     MOV [W2], W4
005958  A15004     BCLR W4, #5
00595A  720903     IOR W4, W3, [W2]
5236:                      #endif
5237:                  }
5238:              
5239:                  // Determine how much data we'll transfer in this packet.
5240:                  if (token == USB_TOKEN_SETUP)
00595C  504FED     SUB.B W0, #0xD, [W15]
00595E  3A0013     BRA NZ, .L423
5241:                  {
5242:                      if ((pCurrentEndpoint->dataCountMaxSETUP - pCurrentEndpoint->dataCount) > pCurrentEndpoint->wMaxPacketSize)
005960  807D72     MOV pCurrentEndpoint, W2
005962  900372     MOV [W2+14], W6
005964  900C02     MOV [W2+16], W8
005966  900C92     MOV [W2+18], W9
005968  900242     MOV [W2+8], W4
00596A  EB0380     CLR W7
00596C  530308     SUB W6, W8, W6
00596E  5B8389     SUBB W7, W9, W7
005970  EB0280     CLR W5
005972  530F84     SUB W6, W4, [W15]
005974  5B8F85     SUBB W7, W5, [W15]
005976  360002     BRA LEU, .L425
5243:                      {
5244:                          currentPacketSize = pCurrentEndpoint->wMaxPacketSize;
005978  900042     MOV [W2+8], W0
00597A  370026     BRA .L426
5245:                      }
5246:                      else
5247:                      {
5248:                          currentPacketSize = pCurrentEndpoint->dataCountMaxSETUP - pCurrentEndpoint->dataCount;
00597C  900072     MOV [W2+14], W0
00597E  900A02     MOV [W2+16], W4
005980  900A92     MOV [W2+18], W5
005982  500004     SUB W0, W4, W0
005984  370021     BRA .L426
5249:                      }
5250:                  }
5251:                  else
5252:                  {
5253:                      if (pCurrentEndpoint->bmAttributes.bfTransferType == USB_TRANSFER_TYPE_ISOCHRONOUS)
005986  807D72     MOV pCurrentEndpoint, W2
005988  900A52     MOV [W2+26], W4
00598A  B23004     AND #0x300, W4
00598C  201003     MOV #0x100, W3
00598E  520F83     SUB W4, W3, [W15]
005990  3A0008     BRA NZ, .L427
5254:                      {
5255:                          if (token == USB_TOKEN_IN)
005992  504FE9     SUB.B W0, #0x9, [W15]
005994  3A0002     BRA NZ, .L428
5256:                          {
5257:                              /* For an IN token, get the maximum packet size. */
5258:                              currentPacketSize = pCurrentEndpoint->wMaxPacketSize;
005996  900042     MOV [W2+8], W0
005998  370041     BRA .L429
5259:                          }
5260:                          else
5261:                          {
5262:                              /* For an OUT token, send the amount of data that the user has
5263:                               * provided. */
5264:                              currentPacketSize = pCurrentEndpoint->dataCount;
00599A  900A02     MOV [W2+16], W4
00599C  900A92     MOV [W2+18], W5
00599E  780004     MOV W4, W0
0059A0  37003D     BRA .L429
5265:                          }
5266:                      }
5267:                      else
5268:                      {
5269:                          if ((pCurrentEndpoint->dataCountMax - pCurrentEndpoint->dataCount) > pCurrentEndpoint->wMaxPacketSize)
0059A2  900452     MOV [W2+10], W8
0059A4  9004E2     MOV [W2+12], W9
0059A6  900B02     MOV [W2+16], W6
0059A8  900B92     MOV [W2+18], W7
0059AA  900242     MOV [W2+8], W4
0059AC  540306     SUB W8, W6, W6
0059AE  5C8387     SUBB W9, W7, W7
0059B0  EB0280     CLR W5
0059B2  530F84     SUB W6, W4, [W15]
0059B4  5B8F85     SUBB W7, W5, [W15]
0059B6  360002     BRA LEU, .L430
5270:                          {
5271:                              currentPacketSize = pCurrentEndpoint->wMaxPacketSize;
0059B8  900042     MOV [W2+8], W0
0059BA  370030     BRA .L429
5272:                          }
5273:                          else
5274:                          {
5275:                              currentPacketSize = pCurrentEndpoint->dataCountMax - pCurrentEndpoint->dataCount;
0059BC  900352     MOV [W2+10], W6
0059BE  9003E2     MOV [W2+12], W7
0059C0  900A02     MOV [W2+16], W4
0059C2  900A92     MOV [W2+18], W5
0059C4  530004     SUB W6, W4, W0
0059C6  37002A     BRA .L429
5276:                          }
5277:                      }
5278:                  }
5279:              
5280:                  // Load up the BDT address.
5281:                  if (token == USB_TOKEN_SETUP)
5282:                  {
5283:                      #if defined(__C30__) || defined(__PIC32__) || defined __XC16__
5284:                          pBDT->ADR  = ConvertToPhysicalAddress(pCurrentEndpoint->pUserDataSETUP);
0059C8  900922     MOV [W2+20], W2
0059CA  980092     MOV W2, [W1+2]
0059CC  37000E     BRA .L431
5285:                      #else
5286:                          #error Cannot set BDT address.
5287:                      #endif
5288:                  }
5289:                  else
5290:                  {
5291:                      #if defined(__C30__) || defined __XC16__
5292:                          if (pCurrentEndpoint->bmAttributes.bfTransferType == USB_TRANSFER_TYPE_ISOCHRONOUS)
005A1C  900A52     MOV [W2+26], W4
005A1E  B23004     AND #0x300, W4
005A20  201003     MOV #0x100, W3
005A22  520F83     SUB W4, W3, [W15]
005A24  3AFFDD     BRA NZ, .L436
005A26  37FFD3     BRA .L437
5293:                          {
5294:                              pBDT->ADR  = ConvertToPhysicalAddress(((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->buffers[((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->currentBufferUSB].pBuffer);
0059CE  900A32     MOV [W2+22], W4
0059D0  900932     MOV [W2+22], W2
0059D2  904112     MOV.B [W2+1], W2
0059D4  FB8102     ZE W2, W2
0059D6  E80102     INC W2, W2
0059D8  B91166     MUL.SU W2, #6, W2
0059DA  790264     MOV [W4+W2], W4
0059DC  980094     MOV W4, [W1+2]
0059DE  370005     BRA .L431
5295:                          }
5296:                          else
5297:                          {
5298:                              pBDT->ADR  = ConvertToPhysicalAddress((uint16_t)pCurrentEndpoint->pUserData + (uint16_t)pCurrentEndpoint->dataCount);
0059E0  900A32     MOV [W2+22], W4
0059E2  900992     MOV [W2+18], W3
0059E4  900902     MOV [W2+16], W2
0059E6  420102     ADD W4, W2, W2
0059E8  980092     MOV W2, [W1+2]
5299:                          }
5300:                      #elif defined(__PIC32__)
5301:                          if (pCurrentEndpoint->bmAttributes.bfTransferType == USB_TRANSFER_TYPE_ISOCHRONOUS)
5302:                          {
5303:                              pBDT->ADR  = ConvertToPhysicalAddress(((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->buffers[((ISOCHRONOUS_DATA *)(pCurrentEndpoint->pUserData))->currentBufferUSB].pBuffer);
5304:                          }
5305:                          else
5306:                          {
5307:                              pBDT->ADR  = ConvertToPhysicalAddress((uint32_t)pCurrentEndpoint->pUserData + (uint32_t)pCurrentEndpoint->dataCount);
5308:                          }
5309:                      #else
5310:                          #error Cannot set BDT address.
5311:                      #endif
5312:                  }
5313:              
5314:                  // Load up the BDT status register.
5315:                  pBDT->STAT.Val      = 0;
0059EA  EB4100     CLR.B W2
0059EC  984092     MOV.B W2, [W1+1]
5316:                  pBDT->count         = currentPacketSize;
0059EE  B23FF0     AND #0x3FF, W0
0059F0  2FC002     MOV #0xFC00, W2
0059F2  610111     AND W2, [W1], W2
0059F4  700002     IOR W0, W2, W0
0059F6  780880     MOV W0, [W1]
5317:                  pBDT->STAT.DTS      = pCurrentEndpoint->status.bfNextDATA01;
0059F8  807D72     MOV pCurrentEndpoint, W2
0059FA  900192     MOV [W2+2], W3
0059FC  DE19CB     LSR W3, #11, W3
0059FE  6181E1     AND W3, #0x1, W3
005A00  DD19CE     SL W3, #14, W3
005A02  A1E000     BCLR W0, #14
005A04  718000     IOR W3, W0, W0
005A06  780880     MOV W0, [W1]
5318:                  pBDT->STAT.DTSEN    = pCurrentEndpoint->status.bfUseDTS;
005A08  900112     MOV [W2+2], W2
005A0A  DE114A     LSR W2, #10, W2
005A0C  610161     AND W2, #0x1, W2
005A0E  DD114B     SL W2, #11, W2
005A10  A1B000     BCLR W0, #11
005A12  710000     IOR W2, W0, W0
5319:              
5320:                  // Transfer the BD to the USB OTG module.
5321:                  pBDT->STAT.UOWN     = 1;
005A14  A0F000     BSET W0, #15
005A16  780880     MOV W0, [W1]
5322:              }
005A18  BE044F     MOV.D [--W15], W8
005A1A  060000     RETURN
005A1C  900A52     MOV [W2+26], W4
005A1E  B23004     AND #0x300, W4
005A20  201003     MOV #0x100, W3
005A22  520F83     SUB W4, W3, [W15]
005A24  3AFFDD     BRA NZ, .L436
005A26  37FFD3     BRA .L437
5323:              
5324:              
5325:              /****************************************************************************
5326:                Function:
5327:                  bool _USB_TransferInProgress( void )
5328:              
5329:                Description:
5330:                  This function checks to see if any read or write transfers are in
5331:                  progress.
5332:              
5333:                Precondition:
5334:                  None
5335:              
5336:                Parameters:
5337:                  None - None
5338:              
5339:                Returns:
5340:                  true    - At least one read or write transfer is occurring.
5341:                  false   - No read or write transfers are occurring.
5342:              
5343:                Remarks:
5344:                  None
5345:                ***************************************************************************/
5346:              
5347:              bool _USB_TransferInProgress( void )
5348:              {
5349:                  USB_ENDPOINT_INFO           *pEndpoint;
5350:                  USB_INTERFACE_INFO          *pInterface;
5351:                  USB_INTERFACE_SETTING_INFO  *pSetting;
5352:              
5353:                  // Check EP0.
5354:                  if (!usbDeviceInfo.pEndpoint0->status.bfTransferComplete)
0061F4  804B60     MOV 0x96C, W0
0061F6  900090     MOV [W0+2], W1
0061FA  A39801     BTST.Z W1, #9
0061FC  32001F     BRA Z, .L559
5355:                  {
5356:                      return true;
0061F8  B3C010     MOV.B #0x1, W0
5357:                  }
5358:              
5359:                  // Check all of the other endpoints.
5360:                  pInterface = usbDeviceInfo.pInterfaceList;
0061FE  804B53     MOV 0x96A, W3
5361:                  while (pInterface)
006202  E00003     CP0 W3
006204  32001B     BRA Z, .L559
00622E  E00003     CP0 W3
006230  3AFFEA     BRA NZ, .L571
5362:                  {
5363:                      pSetting = pInterface->pInterfaceSettings;
006206  900113     MOV [W3+2], W2
5364:                      while (pSetting)
006208  E00002     CP0 W2
00620A  320010     BRA Z, .L560
006228  E00002     CP0 W2
00622A  3AFFF0     BRA NZ, .L572
5365:                      {
5366:                          pEndpoint = pSetting->pEndpointList;
00620C  900022     MOV [W2+4], W0
5367:                          while (pEndpoint)
00620E  E00000     CP0 W0
006210  32000A     BRA Z, .L561
006222  E00000     CP0 W0
006224  3AFFFA     BRA NZ, .L564
5368:                          {
5369:                              if (!pEndpoint->status.bfTransferComplete)
006212  900090     MOV [W0+2], W1
006214  A39801     BTST.Z W1, #9
006216  3A0004     BRA NZ, .L576
006218  37000E     BRA .L577
00621A  900090     MOV [W0+2], W1
00621C  A39801     BTST.Z W1, #9
00621E  32000D     BRA Z, .L570
5370:                              {
5371:                                  return true;
006236  B3C010     MOV.B #0x1, W0
006238  370001     BRA .L559
00623A  B3C010     MOV.B #0x1, W0
5372:                              }
5373:                              pEndpoint = pEndpoint->next;
006220  780010     MOV [W0], W0
5374:                          }
5375:                          pSetting = pSetting->next;
006226  780112     MOV [W2], W2
5376:                      }
5377:                      pInterface = pInterface->next;
00622C  780193     MOV [W3], W3
5378:                  }
5379:              
5380:                  return false;
006200  EB4000     CLR.B W0
006232  EB4000     CLR.B W0
006234  370003     BRA .L559
5381:              }
00623C  060000     RETURN
5382:              
5383:              
5384:              // *****************************************************************************
5385:              // *****************************************************************************
5386:              // Section: Interrupt Handlers
5387:              // *****************************************************************************
5388:              // *****************************************************************************
5389:              
5390:              /****************************************************************************
5391:                Function:
5392:                  void _USB1Interrupt( void )
5393:              
5394:                Summary:
5395:                  This is the interrupt service routine for the USB interrupt.
5396:              
5397:                Description:
5398:                  This is the interrupt service routine for the USB interrupt.  The
5399:                  following cases are serviced:
5400:                       * Device Attach
5401:                       * Device Detach
5402:                       * One millisecond Timer
5403:                       * Start of Frame
5404:                       * Transfer Done
5405:                       * USB Error
5406:              
5407:                Precondition:
5408:                  In TRNIF handling, pCurrentEndpoint is still pointing to the last
5409:                  endpoint to which a token was sent.
5410:              
5411:                Parameters:
5412:                  None - None
5413:              
5414:                Returns:
5415:                  None
5416:              
5417:                Remarks:
5418:                  None
5419:                ***************************************************************************/
5420:              #define U1STAT_TX_MASK                      0x08    // U1STAT bit mask for Tx/Rx indication
5421:              #define U1STAT_ODD_MASK                     0x04    // U1STAT bit mask for even/odd buffer bank
5422:              
5423:              void USB_HostInterruptHandler(void)
5424:              {
5425:              
5426:                  #if defined( __C30__) || defined __XC16__
5427:                      _USB1IF = 0;
006276  A9C08E     BCLR IFS5, #6
5428:                  #elif defined( __PIC32__)
5429:                      _ClearUSBIF();
5430:                  #else
5431:                      #error Cannot clear USB interrupt.
5432:                  #endif
5433:              
5434:                  // -------------------------------------------------------------------------
5435:                  // One Millisecond Timer ISR
5436:              
5437:                  if (U1OTGIEbits.T1MSECIE && U1OTGIRbits.T1MSECIF)
006278  ABC482     BTST U1OTGIE, #6
00627A  32000E     BRA Z, .L584
00627C  ABC480     BTST U1OTGIR, #6
00627E  32000C     BRA Z, .L584
5438:                  {
5439:                      // The interrupt is cleared by writing a '1' to it.
5440:                      U1OTGIR = USB_INTERRUPT_T1MSECIF;
006280  200400     MOV #0x40, W0
006282  882400     MOV W0, U1OTGIR
5441:              
5442:                      #if defined(USB_ENABLE_1MS_EVENT) && defined(USB_HOST_APP_DATA_EVENT_HANDLER)
5443:                          msec_count++;
5444:              
5445:                          //Notify ping all client drivers of 1MSEC event (address, event, data, sizeof_data)
5446:                          _USB_NotifyAllDataClients(0, EVENT_1MS, (void*)&msec_count, 0);
5447:                      #endif
5448:              
5449:              #if defined (DEBUG_ENABLE)
5450:                      DEBUG_PutChar('~');
5451:              #endif
5452:              
5453:                      #ifdef  USB_SUPPORT_OTG
5454:                          if (USBOTGGetSRPTimeOutFlag())
5455:                          {
5456:                              if (USBOTGIsSRPTimeOutExpired())
5457:                              {
5458:                                  USB_OTGEventHandler(0,OTG_EVENT_SRP_FAILED,0,0);
5459:                              }
5460:              
5461:                          }
5462:              
5463:                          else if (USBOTGGetHNPTimeOutFlag())
5464:                          {
5465:                              if (USBOTGIsHNPTimeOutExpired())
5466:                              {
5467:                                  USB_OTGEventHandler(0,OTG_EVENT_HNP_FAILED,0,0);
5468:                              }
5469:              
5470:                          }
5471:              
5472:                          else
5473:                          {
5474:                              if(numTimerInterrupts != 0)
5475:                              {
5476:                                  numTimerInterrupts--;
5477:              
5478:                                  if (numTimerInterrupts == 0)
5479:                                  {
5480:                                      //If we aren't using the 1ms events, then turn of the interrupt to
5481:                                      // save CPU time
5482:                                      #if !defined(USB_ENABLE_1MS_EVENT)
5483:                                          // Turn off the timer interrupt.
5484:                                          U1OTGIEbits.T1MSECIE = 0;
5485:                                      #endif
5486:              
5487:                                      if((usbHostState & STATE_MASK) != STATE_DETACHED)
5488:                                      {
5489:                                          // Advance to the next state.  We can do this here, because the only time
5490:                                          // we'll get a timer interrupt is while we are in one of the holding states.
5491:                                          _USB_SetNextSubSubState();
5492:                                      }
5493:                                  }
5494:                              }
5495:                          }
5496:                       #else
5497:              
5498:                          if(numTimerInterrupts != 0)
006284  E20FAA     CP0 numTimerInterrupts
006286  320008     BRA Z, .L584
5499:                          {
5500:                              numTimerInterrupts--;
006288  ED2FAA     DEC numTimerInterrupts
5501:              
5502:                              if (numTimerInterrupts == 0)
00628A  E20FAA     CP0 numTimerInterrupts
00628C  3A0005     BRA NZ, .L584
5503:                              {
5504:                                  //If we aren't using the 1ms events, then turn of the interrupt to
5505:                                  // save CPU time
5506:                                  #if !defined(USB_ENABLE_1MS_EVENT)
5507:                                      // Turn off the timer interrupt.
5508:                                      U1OTGIEbits.T1MSECIE = 0;
00628E  A9C482     BCLR U1OTGIE, #6
5509:                                  #endif
5510:              
5511:                                  if((usbHostState & STATE_MASK) != STATE_DETACHED)
006290  20F000     MOV #0xF00, W0
006292  B60FAC     AND usbHostState, WREG
006294  320001     BRA Z, .L584
5512:                                  {
5513:                                      // Advance to the next state.  We can do this here, because the only time
5514:                                      // we'll get a timer interrupt is while we are in one of the holding states.
5515:                                      _USB_SetNextSubSubState();
006296  EC2FAC     INC usbHostState
5516:                                  }
5517:                              }
5518:                          }
5519:                       #endif
5520:                  }
5521:              
5522:                  // -------------------------------------------------------------------------
5523:                  // Attach ISR
5524:              
5525:                  // The attach interrupt is level, not edge, triggered.  So make sure we have it enabled.
5526:                  if (U1IEbits.ATTACHIE && U1IRbits.ATTACHIF)
006298  ABC48C     BTST U1IE, #6
00629A  32000A     BRA Z, .L585
00629C  ABC48A     BTST U1IR, #6
00629E  320008     BRA Z, .L585
5527:                  {
5528:              #if defined (DEBUG_ENABLE)
5529:                      DEBUG_PutChar( '[' );
5530:              #endif
5531:              
5532:                      // The attach interrupt is level, not edge, triggered.  If we clear it, it just
5533:                      // comes right back.  So clear the enable instead
5534:                      U1IEbits.ATTACHIE   = 0;
0062A0  A9C48C     BCLR U1IE, #6
5535:                      U1IR                = USB_INTERRUPT_ATTACH;
0062A2  200400     MOV #0x40, W0
0062A4  882450     MOV W0, U1IR
5536:              
5537:                      if (usbHostState == (STATE_DETACHED | SUBSTATE_WAIT_FOR_DEVICE))
0062A6  500070     SUB W0, #0x10, W0
0062A8  E30FAC     CP usbHostState
0062AA  3A0002     BRA NZ, .L585
5538:                      {
5539:                          usbOverrideHostState = STATE_ATTACHED;
0062AC  201000     MOV #0x100, W0
0062AE  887D40     MOV W0, usbOverrideHostState
5540:                      }
5541:              
5542:                      #ifdef  USB_SUPPORT_OTG
5543:                          //If HNP Related Attach, Process Connect Event
5544:                          USB_OTGEventHandler(0, OTG_EVENT_CONNECT, 0, 0 );
5545:              
5546:                          //If SRP Related A side D+ High, Process D+ High Event
5547:                          USB_OTGEventHandler (0, OTG_EVENT_SRP_DPLUS_HIGH, 0, 0 );
5548:              
5549:                          //If SRP Related B side Attach
5550:                          USB_OTGEventHandler (0, OTG_EVENT_SRP_CONNECT, 0, 0 );
5551:                      #endif
5552:                  }
5553:              
5554:                  // -------------------------------------------------------------------------
5555:                  // Detach ISR
5556:              
5557:                  if (U1IEbits.DETACHIE && U1IRbits.DETACHIF)
0062B0  AB048C     BTST U1IE, #0
0062B2  320006     BRA Z, .L586
0062B4  AB048A     BTST U1IR, #0
0062B6  320004     BRA Z, .L586
5558:                  {
5559:              #if defined (DEBUG_ENABLE)
5560:                      DEBUG_PutChar( ']' );
5561:              #endif
5562:              
5563:                      U1IR                    = USB_INTERRUPT_DETACH;
0062B8  200010     MOV #0x1, W0
0062BA  882450     MOV W0, U1IR
5564:                      U1IEbits.DETACHIE       = 0;
0062BC  A9048C     BCLR U1IE, #0
5565:                      usbOverrideHostState    = STATE_DETACHED;
0062BE  EF2FA8     CLR usbOverrideHostState
5566:              
5567:                      #ifdef  USB_SUPPORT_OTG
5568:                          //If HNP Related Detach Detected, Process Disconnect Event
5569:                          USB_OTGEventHandler (0, OTG_EVENT_DISCONNECT, 0, 0 );
5570:              
5571:                          //If SRP Related D+ Low and SRP Is Active, Process D+ Low Event
5572:                          USB_OTGEventHandler (0, OTG_EVENT_SRP_DPLUS_LOW, 0, 0 );
5573:              
5574:                          //Disable HNP, Detach Interrupt Could've Triggered From Cable Being Unplugged
5575:                          USBOTGDisableHnp();
5576:                      #endif
5577:                  }
5578:              
5579:                  #ifdef USB_SUPPORT_OTG
5580:              
5581:                      // -------------------------------------------------------------------------
5582:                      //ID Pin Change ISR
5583:                      if (U1OTGIRbits.IDIF && U1OTGIEbits.IDIE)
5584:                      {
5585:                           USBOTGInitialize();
5586:              
5587:                           //Clear Interrupt Flag
5588:                           U1OTGIR = 0x80;
5589:                      }
5590:              
5591:                      // -------------------------------------------------------------------------
5592:                      //VB_SESS_END ISR
5593:                      if (U1OTGIRbits.SESENDIF && U1OTGIEbits.SESENDIE)
5594:                      {
5595:                          //If B side Host And Cable Was Detached Then
5596:                          if (U1OTGSTATbits.ID == CABLE_B_SIDE && USBOTGCurrentRoleIs() == ROLE_HOST)
5597:                          {
5598:                              //Reinitialize
5599:                              USBOTGInitialize();
5600:                          }
5601:              
5602:                          //Clear Interrupt Flag
5603:                          U1OTGIR = 0x04;
5604:                      }
5605:              
5606:                      // -------------------------------------------------------------------------
5607:                      //VA_SESS_VLD ISR
5608:                      if (U1OTGIRbits.SESVDIF && U1OTGIEbits.SESVDIE)
5609:                      {
5610:                          //If A side Host and SRP Is Active Then
5611:                          if (USBOTGDefaultRoleIs() == ROLE_HOST && USBOTGSrpIsActive())
5612:                          {
5613:                              //If VBUS > VA_SESS_VLD Then
5614:                              if (U1OTGSTATbits.SESVD == 1)
5615:                              {
5616:                                  //Process SRP VBUS High Event
5617:                                  USB_OTGEventHandler (0, OTG_EVENT_SRP_VBUS_HIGH, 0, 0 );
5618:                              }
5619:              
5620:                              //If VBUS < VA_SESS_VLD Then
5621:                              else
5622:                              {
5623:                                   //Process SRP Low Event
5624:                                  USB_OTGEventHandler (0, OTG_EVENT_SRP_VBUS_LOW, 0, 0 );
5625:                              }
5626:                          }
5627:              
5628:                          U1OTGIR = 0x08;
5629:                      }
5630:              
5631:                      // -------------------------------------------------------------------------
5632:                      //Resume Signaling for Remote Wakeup
5633:                      if (U1IRbits.RESUMEIF && U1IEbits.RESUMEIE)
5634:                      {
5635:                          //Process SRP VBUS High Event
5636:                          USB_OTGEventHandler (0, OTG_EVENT_RESUME_SIGNALING,0, 0 );
5637:              
5638:                          //Clear Resume Interrupt Flag
5639:                          U1IR = 0x20;
5640:                      }
5641:                  #endif
5642:              
5643:              
5644:                  // -------------------------------------------------------------------------
5645:                  // Transfer Done ISR - only process if there was no error
5646:              
5647:                  if ((U1IEbits.TRNIE && U1IRbits.TRNIF) &&
0062C0  AB648C     BTST U1IE, #3
0062C2  320127     BRA Z, .L587, .LBE27
0062C4  AB648A     BTST U1IR, #3
0062C6  320125     BRA Z, .L587, .LBE27
0062C8  AB248C     BTST U1IE, #1
0062CA  320008     BRA Z, .L588, .LBB27
5648:                      (!(U1IEbits.UERRIE && U1IRbits.UERRIF) || (pCurrentEndpoint->bmAttributes.bfTransferType == USB_TRANSFER_TYPE_ISOCHRONOUS)))
0062CC  AB248A     BTST U1IR, #1
0062CE  320006     BRA Z, .L588, .LBB27
0062D0  807D70     MOV pCurrentEndpoint, W0
0062D2  9008D0     MOV [W0+26], W1
0062D4  B23001     AND #0x300, W1
0062D6  201000     MOV #0x100, W0
0062D8  508F80     SUB W1, W0, [W15]
0062DA  3A011B     BRA NZ, .L587, .LBE27
5649:                  {
5650:                      #if defined(__C30__) || defined __XC16__
5651:                          U1STATBITS          copyU1STATbits;
5652:                      #elif defined(__PIC32__)
5653:                          __U1STATbits_t      copyU1STATbits;
5654:                      #else
5655:                          #error Need structure name for copyU1STATbits.
5656:                      #endif
5657:                      uint16_t                    packetSize;
5658:                      BDT_ENTRY               *pBDT;
5659:              
5660:              #if defined (DEBUG_ENABLE)
5661:                      DEBUG_PutChar( '!' );
5662:              #endif
5663:              
5664:                      // The previous token has finished, so clear the way for writing a new one.
5665:                      usbBusInfo.flags.bfTokenAlreadyWritten = 0;
0062DC  A98FB0     BCLR usbBusInfo, #4
5666:              
5667:                      copyU1STATbits = U1STATbits;    // Read the status register before clearing the flag.
0062DE  802492     MOV U1STAT, W2
5668:              
5669:                      U1IR = USB_INTERRUPT_TRANSFER;  // Clear the interrupt by writing a '1' to the flag.
0062E0  200080     MOV #0x8, W0
0062E2  882450     MOV W0, U1IR
5670:              
5671:                      // In host mode, U1STAT does NOT reflect the endpoint.  It is really the last updated
5672:                      // BDT, which, in host mode, is always 0.  To get the endpoint, we either need to look
5673:                      // at U1TOK, or trust that pCurrentEndpoint is still accurate.
5674:                      if ((pCurrentEndpoint->bEndpointAddress & 0x0F) == (U1TOK & 0x0F))
0062E4  807D70     MOV pCurrentEndpoint, W0
0062E6  9058A0     MOV.B [W0+26], W1
0062E8  FB8081     ZE W1, W1
0062EA  8024F3     MOV U1TOK, W3
0062EC  698081     XOR W3, W1, W1
0062EE  6080EF     AND W1, #0xF, W1
0062F0  3A010F     BRA NZ, .L589
5675:                      {
5676:                          if (copyU1STATbits.DIR)     // TX
0062F2  780082     MOV W2, W1
0062F4  A33801     BTST.Z W1, #3
0062F6  320005     BRA Z, .L590
5677:                          {
5678:                              // We are processing OUT or SETUP packets.
5679:                              // Set up the BDT pointer for the transaction we just received.
5680:                              #if (USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)
5681:                                  pBDT = BDT_OUT;
0062FE  510164     SUB W2, #0x4, W2
006300  370004     BRA .L591
5682:                                  if (copyU1STATbits.PPBI) // Odd
0062FA  A32801     BTST.Z W1, #2
0062FC  3A0006     BRA NZ, .L591
5683:                                  {
5684:                                      pBDT = BDT_OUT_ODD;
0062F8  20A0C2     MOV #0xA0C, W2
5685:                                  }
5686:                              #elif (USB_PING_PONG_MODE == USB_PING_PONG__NO_PING_PONG) || (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0)
5687:                                  pBDT = BDT_OUT;
5688:                              #endif
5689:                          }
5690:                          else
5691:                          {
5692:                              // We are processing IN packets.
5693:                              // Set up the BDT pointer for the transaction we just received.
5694:                              #if (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)
5695:                                  pBDT = BDT_IN;
006308  510164     SUB W2, #0x4, W2
5696:                                  if (copyU1STATbits.PPBI) // Odd
006304  A32801     BTST.Z W1, #2
006306  3A0001     BRA NZ, .L591
5697:                                  {
5698:                                      pBDT = BDT_IN_ODD;
006302  20A042     MOV #0xA04, W2
5699:                                  }
5700:                              #else
5701:                                  pBDT = BDT_IN;
5702:                              #endif
5703:                          }
5704:              
5705:                          if (pBDT->STAT.PID == PID_ACK)
00630A  23C001     MOV #0x3C00, W1
00630C  608092     AND W1, [W2], W1
00630E  208003     MOV #0x800, W3
006310  508F83     SUB W1, W3, [W15]
006312  3A0046     BRA NZ, .L592
5706:                          {
5707:                              // We will only get this PID from an OUT or SETUP packet.
5708:              
5709:                              // Update the count of bytes tranferred.  (If there was an error, this count will be 0.)
5710:                              // The Byte Count is NOT 0 if a NAK occurs.  Therefore, we can only update the
5711:                              // count when an ACK, DATA0, or DATA1 is received.
5712:                              packetSize                  = pBDT->count;
006314  203FF1     MOV #0x3FF, W1
006316  608092     AND W1, [W2], W1
5713:                              pCurrentEndpoint->dataCount += packetSize;
006318  900900     MOV [W0+16], W2
00631A  900990     MOV [W0+18], W3
00631C  408102     ADD W1, W2, W2
00631E  4981E0     ADDC W3, #0x0, W3
006320  980802     MOV W2, [W0+16]
006322  980813     MOV W3, [W0+18]
5714:              
5715:                              // Set the NAK retries for the next transaction;
5716:                              pCurrentEndpoint->countNAKs = 0;
006324  807D70     MOV pCurrentEndpoint, W0
006326  EB0100     CLR W2
006328  980872     MOV W2, [W0+30]
5717:              
5718:                              // Toggle DTS for the next transfer.
5719:                              pCurrentEndpoint->status.bfNextDATA01 ^= 0x01;
00632A  900110     MOV [W0+2], W2
00632C  DE114B     LSR W2, #11, W2
00632E  EA8102     COM W2, W2
006330  610161     AND W2, #0x1, W2
006332  DD114B     SL W2, #11, W2
006334  900190     MOV [W0+2], W3
006336  A1B003     BCLR W3, #11
006338  710103     IOR W2, W3, W2
00633A  980012     MOV W2, [W0+2]
5720:              
5721:                              if ((pCurrentEndpoint->transferState == (TSTATE_CONTROL_NO_DATA | TSUBSTATE_CONTROL_NO_DATA_SETUP)) ||
00633C  807D70     MOV pCurrentEndpoint, W0
00633E  905900     MOV.B [W0+24], W2
006340  514FF0     SUB.B W2, #0x10, [W15]
006342  320008     BRA Z, .L593
006346  B3C202     MOV.B #0x20, W2
006348  51CF82     SUB.B W3, W2, [W15]
00634A  320004     BRA Z, .L593
5722:                                  (pCurrentEndpoint->transferState == (TSTATE_CONTROL_READ    | TSUBSTATE_CONTROL_READ_SETUP)) ||
006344  905980     MOV.B [W0+24], W3
00634E  414170     ADD.B W2, #0x10, W2
006350  51CF82     SUB.B W3, W2, [W15]
006352  3A000F     BRA NZ, .L594
5723:                                  (pCurrentEndpoint->transferState == (TSTATE_CONTROL_WRITE   | TSUBSTATE_CONTROL_WRITE_SETUP)))
00634C  905980     MOV.B [W0+24], W3
5724:                              {
5725:                                  // We are doing SETUP transfers. See if we are done with the SETUP portion.
5726:                                  if (pCurrentEndpoint->dataCount >= pCurrentEndpoint->dataCountMaxSETUP)
006354  900A00     MOV [W0+16], W4
006356  900A90     MOV [W0+18], W5
006358  900170     MOV [W0+14], W2
00635A  EB0180     CLR W3
00635C  520F82     SUB W4, W2, [W15]
00635E  5A8F83     SUBB W5, W3, [W15]
006360  3900D7     BRA NC, .L589
5727:                                  {
5728:                                      // We are done with the SETUP.  Reset the byte count and
5729:                                      // proceed to the next token.
5730:                                      pCurrentEndpoint->dataCount = 0;
006362  B81160     MUL.UU W2, #0, W2
006364  980802     MOV W2, [W0+16]
006366  980813     MOV W3, [W0+18]
5731:                                      _USB_SetNextTransferState();
006368  807D70     MOV pCurrentEndpoint, W0
00636A  905880     MOV.B [W0+24], W1
00636C  E84081     INC.B W1, W1
00636E  985801     MOV.B W1, [W0+24]
006370  3700CF     BRA .L589
5732:                                  }
5733:                              }
5734:                              else
5735:                              {
5736:                                  // We are doing OUT transfers.  See if we've written all the data.
5737:                                  // We've written all the data when we send a short packet or we have
5738:                                  // transferred all the data.  If it's an isochronous transfer, this
5739:                                  // portion is complete, so go to the next state, so we can tell the
5740:                                  // next higher layer that a batch of data has been transferred.
5741:                                  if ((pCurrentEndpoint->bmAttributes.bfTransferType == USB_TRANSFER_TYPE_ISOCHRONOUS) ||
006372  9009D0     MOV [W0+26], W3
006374  B23003     AND #0x300, W3
006376  201002     MOV #0x100, W2
006378  518F82     SUB W3, W2, [W15]
00637A  32000A     BRA Z, .L595
00637E  508F82     SUB W1, W2, [W15]
006380  390007     BRA NC, .L595
5742:                                      (packetSize < pCurrentEndpoint->wMaxPacketSize) ||
00637C  900140     MOV [W0+8], W2
00638A  520F82     SUB W4, W2, [W15]
00638C  5A8F83     SUBB W5, W3, [W15]
00638E  3900C0     BRA NC, .L589
5743:                                      (pCurrentEndpoint->dataCount >= pCurrentEndpoint->dataCountMax))
006382  900A00     MOV [W0+16], W4
006384  900A90     MOV [W0+18], W5
006386  900150     MOV [W0+10], W2
006388  9001E0     MOV [W0+12], W3
5744:                                  {
5745:                                      // We've written all the data. Proceed to the next step.
5746:                                      pCurrentEndpoint->status.bfTransferSuccessful = 1;
006390  900090     MOV [W0+2], W1
006392  A08001     BSET W1, #8
006394  980011     MOV W1, [W0+2]
5747:                                      _USB_SetNextTransferState();
006396  807D70     MOV pCurrentEndpoint, W0
006398  905880     MOV.B [W0+24], W1
00639A  E84081     INC.B W1, W1
00639C  985801     MOV.B W1, [W0+24]
00639E  3700B8     BRA .L589
5748:                                  }
5749:                                  else
5750:                                  {
5751:                                      // We need to process more data.  Keep this endpoint in its current
5752:                                      // transfer state.
5753:                                  }
5754:                              }
5755:                          }
5756:                          else if ((pBDT->STAT.PID == PID_DATA0) || (pBDT->STAT.PID == PID_DATA1))
0063A0  20C003     MOV #0xC00, W3
0063A2  508F83     SUB W1, W3, [W15]
0063A4  320003     BRA Z, .L596
0063A6  22C003     MOV #0x2C00, W3
0063A8  508F83     SUB W1, W3, [W15]
0063AA  3A002C     BRA NZ, .L597
5757:                          {
5758:                              // We will only get these PID's from an IN packet.
5759:              
5760:                              // Update the count of bytes tranferred.  (If there was an error, this count will be 0.)
5761:                              // The Byte Count is NOT 0 if a NAK occurs.  Therefore, we can only update the
5762:                              // count when an ACK, DATA0, or DATA1 is received.
5763:                              packetSize                  = pBDT->count;
0063AC  203FF1     MOV #0x3FF, W1
0063AE  608092     AND W1, [W2], W1
5764:                              pCurrentEndpoint->dataCount += packetSize;
0063B0  900900     MOV [W0+16], W2
0063B2  900990     MOV [W0+18], W3
0063B4  408102     ADD W1, W2, W2
0063B6  4981E0     ADDC W3, #0x0, W3
0063B8  980802     MOV W2, [W0+16]
0063BA  980813     MOV W3, [W0+18]
5765:              
5766:                              // Set the NAK retries for the next transaction;
5767:                              pCurrentEndpoint->countNAKs = 0;
0063BC  807D70     MOV pCurrentEndpoint, W0
0063BE  EB0100     CLR W2
0063C0  980872     MOV W2, [W0+30]
5768:              
5769:                              // Toggle DTS for the next transfer.
5770:                              pCurrentEndpoint->status.bfNextDATA01 ^= 0x01;
0063C2  900110     MOV [W0+2], W2
0063C4  DE114B     LSR W2, #11, W2
0063C6  EA8102     COM W2, W2
0063C8  610161     AND W2, #0x1, W2
0063CA  DD114B     SL W2, #11, W2
0063CC  900190     MOV [W0+2], W3
0063CE  A1B003     BCLR W3, #11
0063D0  710103     IOR W2, W3, W2
0063D2  980012     MOV W2, [W0+2]
5771:              
5772:                              // We are doing IN transfers.  See if we've received all the data.
5773:                              // We've received all the data if it's an isochronous transfer, or when we receive a
5774:                              // short packet or we have transferred all the data.
5775:                              if ((pCurrentEndpoint->bmAttributes.bfTransferType == USB_TRANSFER_TYPE_ISOCHRONOUS) ||
0063D4  807D70     MOV pCurrentEndpoint, W0
0063D6  9009D0     MOV [W0+26], W3
0063D8  B23003     AND #0x300, W3
0063DA  201002     MOV #0x100, W2
0063DC  518F82     SUB W3, W2, [W15]
0063DE  32000A     BRA Z, .L598
0063E2  508F82     SUB W1, W2, [W15]
0063E4  390007     BRA NC, .L598
5776:                                  (packetSize < pCurrentEndpoint->wMaxPacketSize) ||
0063E0  900140     MOV [W0+8], W2
0063EE  520F82     SUB W4, W2, [W15]
0063F0  5A8F83     SUBB W5, W3, [W15]
0063F2  39008E     BRA NC, .L589
5777:                                  (pCurrentEndpoint->dataCount >= pCurrentEndpoint->dataCountMax))
0063E6  900A00     MOV [W0+16], W4
0063E8  900A90     MOV [W0+18], W5
0063EA  900150     MOV [W0+10], W2
0063EC  9001E0     MOV [W0+12], W3
5778:                              {
5779:                                  // If we've received all the data, stop the transfer.  We've received all the
5780:                                  // data when we receive a short or zero-length packet.  If the data length is a
5781:                                  // multiple of wMaxPacketSize, we will get a 0-length packet.
5782:                                  pCurrentEndpoint->status.bfTransferSuccessful = 1;
0063F4  900090     MOV [W0+2], W1
0063F6  A08001     BSET W1, #8
0063F8  980011     MOV W1, [W0+2]
5783:                                  _USB_SetNextTransferState();
0063FA  807D70     MOV pCurrentEndpoint, W0
0063FC  905880     MOV.B [W0+24], W1
0063FE  E84081     INC.B W1, W1
006400  985801     MOV.B W1, [W0+24]
006402  370086     BRA .L589
5784:                              }
5785:                              else
5786:                              {
5787:                                  // We need to process more data.  Keep this endpoint in its current
5788:                                  // transfer state.
5789:                              }
5790:                          }
5791:                          else if (pBDT->STAT.PID == PID_NAK)
006404  228002     MOV #0x2800, W2
006406  508F82     SUB W1, W2, [W15]
006408  3A005A     BRA NZ, .L599
5792:                          {
5793:                              #ifndef ALLOW_MULTIPLE_NAKS_PER_FRAME
5794:                                  pCurrentEndpoint->status.bfLastTransferNAKd = 1;
00640A  900090     MOV [W0+2], W1
00640C  A0C001     BSET W1, #12
00640E  980011     MOV W1, [W0+2]
5795:                              #endif
5796:              
5797:                              pCurrentEndpoint->countNAKs ++;
006410  807D70     MOV pCurrentEndpoint, W0
006412  9008F0     MOV [W0+30], W1
006414  E80081     INC W1, W1
006416  980871     MOV W1, [W0+30]
5798:              
5799:                              switch( pCurrentEndpoint->bmAttributes.bfTransferType )
006418  9008D0     MOV [W0+26], W1
00641A  DE08C8     LSR W1, #8, W1
00641C  6080E3     AND W1, #0x3, W1
00641E  508FE2     SUB W1, #0x2, [W15]
006420  320005     BRA Z, .L602
006422  508FE3     SUB W1, #0x3, [W15]
006424  320027     BRA Z, .L603
006426  508FE1     SUB W1, #0x1, [W15]
006428  3A0013     BRA NZ, .L628
00642A  370041     BRA .L629
5800:                              {
5801:                                  case USB_TRANSFER_TYPE_BULK:
5802:                                      // Bulk IN and OUT transfers are allowed to retry NAK'd
5803:                                      // transactions until a timeout (if enabled) or indefinitely
5804:                                          // (if NAK timeouts disabled).
5805:                                      if (pCurrentEndpoint->status.bfNAKTimeoutEnabled &&
00642C  900090     MOV [W0+2], W1
00642E  A3D801     BTST.Z W1, #13
006430  32006F     BRA Z, .L589
006436  510F81     SUB W2, W1, [W15]
006438  36006B     BRA LEU, .L589
5806:                                          (pCurrentEndpoint->countNAKs > pCurrentEndpoint->timeoutNAKs))
006432  900970     MOV [W0+30], W2
006434  901080     MOV [W0+32], W1
5807:                                      {
5808:                                          pCurrentEndpoint->status.bfError    = 1;
00643A  900090     MOV [W0+2], W1
00643C  A06001     BSET W1, #6
00643E  980011     MOV W1, [W0+2]
5809:                                          pCurrentEndpoint->bErrorCode        = USB_ENDPOINT_NAK_TIMEOUT;
006440  B3C171     MOV.B #0x17, W1
006442  807D70     MOV pCurrentEndpoint, W0
006444  985841     MOV.B W1, [W0+28]
5810:                                          _USB_SetTransferErrorState( pCurrentEndpoint );
006446  807D70     MOV pCurrentEndpoint, W0
006448  905880     MOV.B [W0+24], W1
00644A  B340F1     IOR.B #0xF, W1
00644C  985801     MOV.B W1, [W0+24]
00644E  370060     BRA .L589
5811:                                      }
5812:                                      break;
5813:              
5814:                                  case USB_TRANSFER_TYPE_CONTROL:
5815:                                      // Devices should not NAK the SETUP portion.  If they NAK
5816:                                      // the DATA portion, they are allowed to retry a fixed
5817:                                      // number of times.
5818:                                      if (pCurrentEndpoint->status.bfNAKTimeoutEnabled &&
006450  900090     MOV [W0+2], W1
006452  A3D801     BTST.Z W1, #13
006454  32005D     BRA Z, .L589
00645A  510F81     SUB W2, W1, [W15]
00645C  360059     BRA LEU, .L589
5819:                                          (pCurrentEndpoint->countNAKs > pCurrentEndpoint->timeoutNAKs))
006456  900970     MOV [W0+30], W2
006458  901080     MOV [W0+32], W1
5820:                                      {
5821:                                          pCurrentEndpoint->status.bfError    = 1;
00645E  900090     MOV [W0+2], W1
006460  A06001     BSET W1, #6
006462  980011     MOV W1, [W0+2]
5822:                                          pCurrentEndpoint->bErrorCode        = USB_ENDPOINT_NAK_TIMEOUT;
006464  B3C171     MOV.B #0x17, W1
006466  807D70     MOV pCurrentEndpoint, W0
006468  985841     MOV.B W1, [W0+28]
5823:                                          _USB_SetTransferErrorState( pCurrentEndpoint );
00646A  807D70     MOV pCurrentEndpoint, W0
00646C  905880     MOV.B [W0+24], W1
00646E  B340F1     IOR.B #0xF, W1
006470  985801     MOV.B W1, [W0+24]
006472  37004E     BRA .L589
5824:                                      }
5825:                                      break;
5826:              
5827:                                  case USB_TRANSFER_TYPE_INTERRUPT:
5828:                                      if ((pCurrentEndpoint->bEndpointAddress & 0x80) == 0x00)
006474  9058A0     MOV.B [W0+26], W1
006476  E00401     CP0.B W1
006478  350012     BRA LT, .L604
5829:                                      {
5830:                                          // Interrupt OUT transfers are allowed to retry NAK'd
5831:                                          // transactions until a timeout (if enabled) or indefinitely
5832:                                          // (if NAK timeouts disabled).
5833:                                          if (pCurrentEndpoint->status.bfNAKTimeoutEnabled &&
00647A  900090     MOV [W0+2], W1
00647C  A3D801     BTST.Z W1, #13
00647E  320048     BRA Z, .L589
006484  510F81     SUB W2, W1, [W15]
006486  360044     BRA LEU, .L589
5834:                                              (pCurrentEndpoint->countNAKs > pCurrentEndpoint->timeoutNAKs))
006480  900970     MOV [W0+30], W2
006482  901080     MOV [W0+32], W1
5835:                                          {
5836:                                              pCurrentEndpoint->status.bfError    = 1;
006488  900090     MOV [W0+2], W1
00648A  A06001     BSET W1, #6
00648C  980011     MOV W1, [W0+2]
5837:                                              pCurrentEndpoint->bErrorCode        = USB_ENDPOINT_NAK_TIMEOUT;
00648E  B3C171     MOV.B #0x17, W1
006490  807D70     MOV pCurrentEndpoint, W0
006492  985841     MOV.B W1, [W0+28]
5838:                                              _USB_SetTransferErrorState( pCurrentEndpoint );
006494  807D70     MOV pCurrentEndpoint, W0
006496  905880     MOV.B [W0+24], W1
006498  B340F1     IOR.B #0xF, W1
00649A  985801     MOV.B W1, [W0+24]
00649C  370039     BRA .L589
5839:                                          }
5840:                                      }
5841:                                      else
5842:                                      {
5843:                                          // Interrupt IN transfers terminate with no error.
5844:                                          pCurrentEndpoint->status.bfTransferSuccessful = 1;
00649E  900090     MOV [W0+2], W1
0064A0  A08001     BSET W1, #8
0064A2  980011     MOV W1, [W0+2]
5845:                                          _USB_SetNextTransferState();
0064A4  807D70     MOV pCurrentEndpoint, W0
0064A6  905880     MOV.B [W0+24], W1
0064A8  E84081     INC.B W1, W1
0064AA  985801     MOV.B W1, [W0+24]
0064AC  370031     BRA .L589
5846:                                      }
5847:                                      break;
5848:              
5849:                                  case USB_TRANSFER_TYPE_ISOCHRONOUS:
5850:                                      // Isochronous transfers terminate with no error.
5851:                                      pCurrentEndpoint->status.bfTransferSuccessful = 1;
0064AE  900090     MOV [W0+2], W1
0064B0  A08001     BSET W1, #8
0064B2  980011     MOV W1, [W0+2]
5852:                                      _USB_SetNextTransferState();
0064B4  807D70     MOV pCurrentEndpoint, W0
0064B6  905880     MOV.B [W0+24], W1
0064B8  E84081     INC.B W1, W1
0064BA  985801     MOV.B W1, [W0+24]
5853:                                      break;
0064BC  370029     BRA .L589
5854:                              }
5855:                          }
5856:                          else if (pBDT->STAT.PID == PID_STALL)
0064BE  238002     MOV #0x3800, W2
0064C0  508F82     SUB W1, W2, [W15]
0064C2  3A000B     BRA NZ, .L605
5857:                          {
5858:                              // Device is stalled.  Stop the transfer, and indicate the stall.
5859:                              // The application must clear this if not a control endpoint.
5860:                              // A stall on a control endpoint does not indicate that the
5861:                              // endpoint is halted.
5862:              #if defined (DEBUG_ENABLE)
5863:                              DEBUG_PutChar( '^' );
5864:              #endif
5865:              
5866:                              pCurrentEndpoint->status.bfStalled = 1;
0064C4  900090     MOV [W0+2], W1
0064C6  A05001     BSET W1, #5
0064C8  980011     MOV W1, [W0+2]
5867:                              pCurrentEndpoint->bErrorCode       = USB_ENDPOINT_STALLED;
0064CA  B3C111     MOV.B #0x11, W1
0064CC  807D70     MOV pCurrentEndpoint, W0
0064CE  985841     MOV.B W1, [W0+28]
5868:                              _USB_SetTransferErrorState( pCurrentEndpoint );
0064D0  807D70     MOV pCurrentEndpoint, W0
0064D2  905880     MOV.B [W0+24], W1
0064D4  B340F1     IOR.B #0xF, W1
0064D6  985801     MOV.B W1, [W0+24]
0064D8  37001B     BRA .L589
5869:                          }
5870:                          else
5871:                          {
5872:                              // Module-defined PID - Bus Timeout (0x0) or Data Error (0x0F).  Increment the error count.
5873:                              // NOTE: If DTS is enabled and the packet has the wrong DTS value, a PID of 0x0F is
5874:                              // returned.  The hardware, however, acknowledges the packet, so the device thinks
5875:                              // that the host has received it.  But the data is not actually received, and the application
5876:                              // layer is not informed of the packet.
5877:                              pCurrentEndpoint->status.bfErrorCount++;
0064DA  900090     MOV [W0+2], W1
0064DC  E84081     INC.B W1, W1
0064DE  6080FF     AND W1, #0x1F, W1
0064E0  900190     MOV [W0+2], W3
0064E2  2FFE02     MOV #0xFFE0, W2
0064E4  618102     AND W3, W2, W2
0064E6  708082     IOR W1, W2, W1
0064E8  980011     MOV W1, [W0+2]
5878:              
5879:                              if (pCurrentEndpoint->status.bfErrorCount >= USB_TRANSACTION_RETRY_ATTEMPTS)
0064EA  807D70     MOV pCurrentEndpoint, W0
0064EC  900090     MOV [W0+2], W1
0064EE  6080FF     AND W1, #0x1F, W1
0064F0  508FF3     SUB W1, #0x13, [W15]
0064F2  34000E     BRA LE, .L589
5880:                              {
5881:                                  // We have too many errors.
5882:              
5883:                                  // Stop the transfer and indicate an error.
5884:                                  // The application must clear this.
5885:                                  pCurrentEndpoint->status.bfError    = 1;
0064F4  900090     MOV [W0+2], W1
0064F6  A06001     BSET W1, #6
0064F8  980011     MOV W1, [W0+2]
5886:                                  pCurrentEndpoint->bErrorCode        = USB_ENDPOINT_ERROR_ILLEGAL_PID;
0064FA  B3C131     MOV.B #0x13, W1
0064FC  807D70     MOV pCurrentEndpoint, W0
0064FE  985841     MOV.B W1, [W0+28]
5887:                                  _USB_SetTransferErrorState( pCurrentEndpoint );
006500  807D70     MOV pCurrentEndpoint, W0
006502  905880     MOV.B [W0+24], W1
006504  B340F1     IOR.B #0xF, W1
006506  985801     MOV.B W1, [W0+24]
5888:              
5889:                                  // Avoid the error interrupt code, because we are going to
5890:                                  // find another token to send.
5891:                                  U1EIR = 0xFF;
006508  200FF0     MOV #0xFF, W0
00650A  882470     MOV W0, U1EIR
5892:                                  U1IR  = USB_INTERRUPT_ERROR;
00650C  200020     MOV #0x2, W0
00650E  882450     MOV W0, U1IR
5893:                              }
5894:                              else
5895:                              {
5896:                                  // Fall through.  This will automatically cause the transfer
5897:                                  // to be retried.
5898:                              }
5899:                          }
5900:                      }
5901:                      else
5902:                      {
5903:                          // We have a mismatch between the endpoint we were expecting and the one that we got.
5904:                          // The user may be trying to select a new configuration.  Discard the transaction.
5905:                      }
5906:              
5907:                      _USB_FindNextToken();
006510  07FA8B     RCALL _USB_FindNextToken
5908:                  } // U1IRbits.TRNIF
5909:              
5910:              
5911:                  // -------------------------------------------------------------------------
5912:                  // Start-of-Frame ISR
5913:              
5914:                  if (U1IEbits.SOFIE && U1IRbits.SOFIF)
006512  AB448C     BTST U1IE, #2
006514  32002A     BRA Z, .L606, .LBE28
006516  AB448A     BTST U1IR, #2
006518  320028     BRA Z, .L606, .LBE28
5915:                  {
5916:                      USB_ENDPOINT_INFO           *pEndpoint;
5917:                      USB_INTERFACE_INFO          *pInterface;
5918:              
5919:                      #if defined(USB_ENABLE_SOF_EVENT) && defined(USB_HOST_APP_DATA_EVENT_HANDLER)
5920:                          //Notify ping all client drivers of SOF event (address, event, data, sizeof_data)
5921:                          _USB_NotifyDataClients(0, EVENT_SOF, NULL, 0);
5922:                      #endif
5923:              
5924:                      U1IR = USB_INTERRUPT_SOF; // Clear the interrupt by writing a '1' to the flag.
00651A  200040     MOV #0x4, W0
00651C  882450     MOV W0, U1IR
5925:              
5926:                      pInterface = usbDeviceInfo.pInterfaceList;
00651E  804B54     MOV 0x96A, W4
5927:                      while (pInterface)
006520  E00004     CP0 W4
006522  32001D     BRA Z, .L607
00655A  E00004     CP0 W4
00655C  3AFFE5     BRA NZ, .L624
5928:                      {
5929:                          if (pInterface->pCurrentSetting)
006528  900024     MOV [W4+4], W0
00652A  E00000     CP0 W0
00652C  320015     BRA Z, .L608
5930:                          {
5931:                              pEndpoint = pInterface->pCurrentSetting->pEndpointList;
00652E  900020     MOV [W0+4], W0
5932:                              while (pEndpoint)
006530  E00000     CP0 W0
006532  320012     BRA Z, .L608
006554  E00000     CP0 W0
006556  3AFFEE     BRA NZ, .L625
5933:                              {
5934:                                  // Decrement the interval count of all active interrupt and isochronous endpoints.
5935:                                  if ((pEndpoint->bmAttributes.bfTransferType == USB_TRANSFER_TYPE_INTERRUPT) ||
006524  203002     MOV #0x300, W2
006526  201003     MOV #0x100, W3
006534  9008D0     MOV [W0+26], W1
006536  608082     AND W1, W2, W1
006538  508F82     SUB W1, W2, [W15]
00653A  320002     BRA Z, .L609
00653C  508F83     SUB W1, W3, [W15]
00653E  3A0006     BRA NZ, .L610
5936:                                      (pEndpoint->bmAttributes.bfTransferType == USB_TRANSFER_TYPE_ISOCHRONOUS))
5937:                                  {
5938:                                      if (pEndpoint->wIntervalCount != 0)
006540  9000B0     MOV [W0+6], W1
006542  E00001     CP0 W1
006544  320003     BRA Z, .L610
5939:                                      {
5940:                                          pEndpoint->wIntervalCount--;
006546  9000B0     MOV [W0+6], W1
006548  E90081     DEC W1, W1
00654A  980031     MOV W1, [W0+6]
5941:                                      }
5942:                                  }
5943:              
5944:                                  #ifndef ALLOW_MULTIPLE_NAKS_PER_FRAME
5945:                                      pEndpoint->status.bfLastTransferNAKd = 0;
00654C  900090     MOV [W0+2], W1
00654E  A1C001     BCLR W1, #12
006550  980011     MOV W1, [W0+2]
5946:                                  #endif
5947:              
5948:                                  pEndpoint = pEndpoint->next;
006552  780010     MOV [W0], W0
5949:                              }
5950:                          }
5951:              
5952:                          pInterface = pInterface->next;
006558  780214     MOV [W4], W4
5953:                      }
5954:              
5955:                      usbBusInfo.flags.bfControlTransfersDone     = 0;
00655E  A90FB0     BCLR usbBusInfo, #0
5956:                      usbBusInfo.flags.bfInterruptTransfersDone   = 0;
006560  A92FB0     BCLR usbBusInfo, #1
5957:                      usbBusInfo.flags.bfIsochronousTransfersDone = 0;
006562  A94FB0     BCLR usbBusInfo, #2
5958:                      usbBusInfo.flags.bfBulkTransfersDone        = 0;
006564  A96FB0     BCLR usbBusInfo, #3
5959:                      //usbBusInfo.dBytesSentInFrame                = 0;
5960:                      usbBusInfo.lastBulkTransaction              = 0;
006566  EF6FB2     CLR.B 0xFB2
5961:              
5962:                      _USB_FindNextToken();
006568  07FA5F     RCALL _USB_FindNextToken
5963:                  }
5964:              
5965:                  // -------------------------------------------------------------------------
5966:                  // USB Error ISR
5967:              
5968:                  if (U1IEbits.UERRIE && U1IRbits.UERRIF)
00656A  AB248C     BTST U1IE, #1
00656C  320044     BRA Z, .L583
00656E  AB248A     BTST U1IR, #1
006570  320042     BRA Z, .L583
5969:                  {
5970:              #if defined (DEBUG_ENABLE)
5971:                      DEBUG_PutChar('#');
5972:                      DEBUG_PutHexUINT8( U1EIR );
5973:              #endif
5974:              
5975:                      // The previous token has finished, so clear the way for writing a new one.
5976:                      usbBusInfo.flags.bfTokenAlreadyWritten = 0;
006572  A98FB0     BCLR usbBusInfo, #4
5977:              
5978:                      // If we are doing isochronous transfers, ignore the error.
5979:                      if (pCurrentEndpoint->bmAttributes.bfTransferType == USB_TRANSFER_TYPE_ISOCHRONOUS)
006574  807D70     MOV pCurrentEndpoint, W0
006576  900950     MOV [W0+26], W2
006578  B23002     AND #0x300, W2
00657A  201001     MOV #0x100, W1
00657C  510F81     SUB W2, W1, [W15]
00657E  320037     BRA Z, .L614
5980:                      {
5981:              //            pCurrentEndpoint->status.bfTransferSuccessful = 1;
5982:              //            _USB_SetNextTransferState();
5983:                      }
5984:                      else
5985:                      {
5986:                          // Increment the error count.
5987:                          pCurrentEndpoint->status.bfErrorCount++;
006580  900090     MOV [W0+2], W1
006582  E84081     INC.B W1, W1
006584  6080FF     AND W1, #0x1F, W1
006586  900190     MOV [W0+2], W3
006588  2FFE02     MOV #0xFFE0, W2
00658A  618102     AND W3, W2, W2
00658C  708082     IOR W1, W2, W1
00658E  980011     MOV W1, [W0+2]
5988:              
5989:                          if (pCurrentEndpoint->status.bfErrorCount >= USB_TRANSACTION_RETRY_ATTEMPTS)
006590  807D70     MOV pCurrentEndpoint, W0
006592  900090     MOV [W0+2], W1
006594  6080FF     AND W1, #0x1F, W1
006596  508FF3     SUB W1, #0x13, [W15]
006598  34002A     BRA LE, .L614
5990:                          {
5991:                              // We have too many errors.
5992:              
5993:                              // Check U1EIR for the appropriate error codes to return
5994:                              if (U1EIRbits.BTSEF)
00659A  ABE48E     BTST U1EIR, #7
00659C  320002     BRA Z, .L615
5995:                                  pCurrentEndpoint->bErrorCode = USB_ENDPOINT_ERROR_BIT_STUFF;
00659E  B3C201     MOV.B #0x20, W1
0065A0  985841     MOV.B W1, [W0+28]
5996:                              if (U1EIRbits.DMAEF)
0065A2  ABA48E     BTST U1EIR, #5
0065A4  320003     BRA Z, .L616
5997:                                  pCurrentEndpoint->bErrorCode = USB_ENDPOINT_ERROR_DMA;
0065A6  B3C211     MOV.B #0x21, W1
0065A8  807D70     MOV pCurrentEndpoint, W0
0065AA  985841     MOV.B W1, [W0+28]
5998:                              if (U1EIRbits.BTOEF)
0065AC  AB848E     BTST U1EIR, #4
0065AE  320003     BRA Z, .L617
5999:                                  pCurrentEndpoint->bErrorCode = USB_ENDPOINT_ERROR_TIMEOUT;
0065B0  B3C221     MOV.B #0x22, W1
0065B2  807D70     MOV pCurrentEndpoint, W0
0065B4  985841     MOV.B W1, [W0+28]
6000:                              if (U1EIRbits.DFN8EF)
0065B6  AB648E     BTST U1EIR, #3
0065B8  320003     BRA Z, .L618
6001:                                  pCurrentEndpoint->bErrorCode = USB_ENDPOINT_ERROR_DATA_FIELD;
0065BA  B3C231     MOV.B #0x23, W1
0065BC  807D70     MOV pCurrentEndpoint, W0
0065BE  985841     MOV.B W1, [W0+28]
6002:                              if (U1EIRbits.CRC16EF)
0065C0  AB448E     BTST U1EIR, #2
0065C2  320003     BRA Z, .L619
6003:                                  pCurrentEndpoint->bErrorCode = USB_ENDPOINT_ERROR_CRC16;
0065C4  B3C241     MOV.B #0x24, W1
0065C6  807D70     MOV pCurrentEndpoint, W0
0065C8  985841     MOV.B W1, [W0+28]
6004:                              if (U1EIRbits.EOFEF)
0065CA  AB248E     BTST U1EIR, #1
0065CC  320003     BRA Z, .L620
6005:                                  pCurrentEndpoint->bErrorCode = USB_ENDPOINT_ERROR_END_OF_FRAME;
0065CE  B3C251     MOV.B #0x25, W1
0065D0  807D70     MOV pCurrentEndpoint, W0
0065D2  985841     MOV.B W1, [W0+28]
6006:                              if (U1EIRbits.PIDEF)
0065D4  AB048E     BTST U1EIR, #0
0065D6  320003     BRA Z, .L621
6007:                                  pCurrentEndpoint->bErrorCode = USB_ENDPOINT_ERROR_PID_CHECK;
0065D8  B3C261     MOV.B #0x26, W1
0065DA  807D70     MOV pCurrentEndpoint, W0
0065DC  985841     MOV.B W1, [W0+28]
6008:                              #if defined(__PIC32__)
6009:                              if (U1EIRbits.BMXEF)
6010:                                  pCurrentEndpoint->bErrorCode = USB_ENDPOINT_ERROR_BMX;
6011:                              #endif
6012:              
6013:                              pCurrentEndpoint->status.bfError    = 1;
0065DE  807D70     MOV pCurrentEndpoint, W0
0065E0  900090     MOV [W0+2], W1
0065E2  A06001     BSET W1, #6
0065E4  980011     MOV W1, [W0+2]
6014:              
6015:                              _USB_SetTransferErrorState( pCurrentEndpoint );
0065E6  807D70     MOV pCurrentEndpoint, W0
0065E8  905880     MOV.B [W0+24], W1
0065EA  B340F1     IOR.B #0xF, W1
0065EC  985801     MOV.B W1, [W0+24]
6016:                          }
6017:                      }
6018:              
6019:                      U1EIR = 0xFF;   // Clear the interrupts by writing '1' to the flags.
0065EE  200FF0     MOV #0xFF, W0
0065F0  882470     MOV W0, U1EIR
6020:                      U1IR = USB_INTERRUPT_ERROR; // Clear the interrupt by writing a '1' to the flag.
0065F2  200020     MOV #0x2, W0
0065F4  882450     MOV W0, U1IR
6021:                  }
6022:              }
0065F6  060000     RETURN
6023:              
6024:              
6025:              /*************************************************************************
6026:               * EOF usb_host.c
6027:               */
6028:              
---  /home/sladekm/MPLABXProjects/USB_Device_Host_MIDI.X/usb/src/usb_events.c  --------------------------
1:                 /*******************************************************************************
2:                 Copyright 2016 Microchip Technology Inc. (www.microchip.com)
3:                 
4:                 Licensed under the Apache License, Version 2.0 (the "License");
5:                 you may not use this file except in compliance with the License.
6:                 You may obtain a copy of the License at
7:                 
8:                     http://www.apache.org/licenses/LICENSE-2.0
9:                 
10:                Unless required by applicable law or agreed to in writing, software
11:                distributed under the License is distributed on an "AS IS" BASIS,
12:                WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
13:                See the License for the specific language governing permissions and
14:                limitations under the License.
15:                
16:                To request to license the code under the MLA license (www.microchip.com/mla_license), 
17:                please contact mla_licensing@microchip.com
18:                *******************************************************************************/
19:                
20:                /** INCLUDES *******************************************************/
21:                #include "inc/system.h"
22:                
23:                #include "app_device_audio_midi.h"
24:                #include "app_led_usb_status.h"
25:                
26:                #include "usb_device.h"
27:                #include "usb_device_midi.h"
28:                
29:                
30:                bool USER_USB_CALLBACK_EVENT_HANDLER(USB_EVENT event, void *pdata, uint16_t size)
31:                {
32:                    switch( (int) event )
007238  500FE1     SUB W0, #0x1, [W15]
00723A  320005     BRA Z, .L3
00723C  200731     MOV #0x73, W1
00723E  500F81     SUB W0, W1, [W15]
007240  3A0003     BRA NZ, .L2
33:                    {
34:                        case EVENT_TRANSFER:
35:                            break;
36:                
37:                        case EVENT_SOF:
38:                            /* We are using the SOF as a timer to time the LED indicator.  Call
39:                             * the LED update function here. */
40:                //            APP_LEDUpdateUSBStatus();
41:                            APP_DeviceAudioMIDISOFHandler();
007242  07FF2B     RCALL APP_DeviceAudioMIDISOFHandler
42:                            break;
007244  370001     BRA .L2
43:                
44:                        case EVENT_SUSPEND:
45:                            /* Update the LED status for the suspend event. */
46:                //            APP_LEDUpdateUSBStatus();
47:                            break;
48:                
49:                        case EVENT_RESUME:
50:                            /* Update the LED status for the resume event. */
51:                //            APP_LEDUpdateUSBStatus();
52:                            break;
53:                
54:                        case EVENT_CONFIGURED:
55:                            /* When the device is configured, we can (re)initialize the demo
56:                             * code. */
57:                            APP_DeviceAudioMIDIInitialize();
007246  07FF14     RCALL APP_DeviceAudioMIDIInitialize
58:                            break;
59:                
60:                        case EVENT_SET_DESCRIPTOR:
61:                            break;
62:                
63:                        case EVENT_EP0_REQUEST:
64:                            break;
65:                
66:                        case EVENT_BUS_ERROR:
67:                            break;
68:                
69:                        case EVENT_TRANSFER_TERMINATED:
70:                            break;
71:                
72:                        default:
73:                            break;
74:                    }
75:                    return true;
76:                }
007248  B3C010     MOV.B #0x1, W0
00724A  060000     RETURN
77:                
78:                /*******************************************************************************
79:                 End of File
80:                */
---  /home/sladekm/MPLABXProjects/USB_Device_Host_MIDI.X/usb/src/usb_device.c  --------------------------
1:                 // DOM-IGNORE-BEGIN
2:                 /*******************************************************************************
3:                 Copyright 2015 Microchip Technology Inc. (www.microchip.com)
4:                 
5:                 Licensed under the Apache License, Version 2.0 (the "License");
6:                 you may not use this file except in compliance with the License.
7:                 You may obtain a copy of the License at
8:                 
9:                     http://www.apache.org/licenses/LICENSE-2.0
10:                
11:                Unless required by applicable law or agreed to in writing, software
12:                distributed under the License is distributed on an "AS IS" BASIS,
13:                WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
14:                See the License for the specific language governing permissions and
15:                limitations under the License.
16:                
17:                To request to license the code under the MLA license (www.microchip.com/mla_license),
18:                please contact mla_licensing@microchip.com
19:                *******************************************************************************/
20:                //DOM-IGNORE-END
21:                
22:                /*******************************************************************************
23:                  USB Device Layer
24:                
25:                  Company:
26:                    Microchip Technology Inc.
27:                
28:                  File Name:
29:                    usb_device.c
30:                
31:                  Summary:
32:                   Provides basic USB device functionality, including enumeration and USB
33:                   chapter 9 required behavior.
34:                
35:                  Description:
36:                   Provides basic USB device functionality, including enumeration and USB
37:                   chapter 9 required behavior.
38:                *******************************************************************************/
39:                
40:                // *****************************************************************************
41:                // *****************************************************************************
42:                // Section: Included Files
43:                // *****************************************************************************
44:                // *****************************************************************************
45:                #include <xc.h>
46:                
47:                #include <stdint.h>
48:                #include <stddef.h>
49:                #include <string.h>
50:                
51:                #include "usb_device_config.h"
52:                
53:                #include "usb.h"
54:                #include "usb_ch9.h"
55:                #include "usb_device.h"
56:                #include "usb_device_local.h"
57:                
58:                #ifndef uintptr_t
59:                    #if  defined(__XC8__) || defined(__XC16__)
60:                        #define uintptr_t uint16_t
61:                    #elif defined (__XC32__)
62:                        #define uintptr_t uint32_t
63:                    #endif
64:                #endif
65:                
66:                #if defined(USB_USE_MSD)
67:                    #include "usb_device_msd.h"
68:                #endif
69:                
70:                // *****************************************************************************
71:                // *****************************************************************************
72:                // Section: File Scope or Global Constants
73:                // *****************************************************************************
74:                // *****************************************************************************
75:                #if !defined(USE_USB_BUS_SENSE_IO)
76:                    //Assume the +5V VBUS is always present (like it would be in a bus powered
77:                    //only application), unless USE_USB_BUS_SENSE_IO and USB_BUS_SENSE have
78:                    //been properly defined elsewhere in the project.
79:                    #undef USB_BUS_SENSE
80:                    #define USB_BUS_SENSE 1
81:                #endif
82:                
83:                #if defined(USB_DEVICE_DISABLE_DTS_CHECKING)
84:                    #define _DTS_CHECKING_ENABLED 0
85:                #else
86:                    #define _DTS_CHECKING_ENABLED _DTSEN
87:                #endif
88:                
89:                #if !defined(self_power)
90:                    //Assume the application is always bus powered, unless self_power has been
91:                    //defined elsewhere in the project
92:                    #define self_power 0    //0 = bus powered
93:                #endif
94:                
95:                #if !defined(USB_MAX_NUM_CONFIG_DSC)
96:                    //Assume the application only implements one configuration descriptor,
97:                    //unless otherwise specified elsewhere in the project
98:                    #define USB_MAX_NUM_CONFIG_DSC      1
99:                #endif
100:               
101:               #if defined(__XC8)
102:                   //Suppress expected/harmless compiler warning message about unused RAM variables
103:                   //and certain function pointer usage.
104:                   //Certain variables and function pointers are not used if you don't use all
105:                   //of the USB stack APIs.  However, these variables should not be
106:                   //removed (since they are still used/needed in some applications, and this
107:                   //is a common file shared by many projects, some of which rely on the "unused"
108:                   //variables/function pointers).
109:                   #pragma warning disable 1090
110:                   #if __XC8_VERSION > 1300
111:                       #pragma warning disable 1471
112:                   #endif
113:               #endif
114:               
115:               // *****************************************************************************
116:               // *****************************************************************************
117:               // Section: File Scope Data Types
118:               // *****************************************************************************
119:               // *****************************************************************************
120:               typedef union
121:               {
122:                   uint8_t Val;
123:                   struct __PACKED
124:                   {
125:                       unsigned b0:1;
126:                       unsigned b1:1;
127:                       unsigned b2:1;
128:                       unsigned b3:1;
129:                       unsigned b4:1;
130:                       unsigned b5:1;
131:                       unsigned b6:1;
132:                       unsigned b7:1;
133:                   } bits;
134:               } uint8_t_VAL, uint8_t_BITS;
135:               
136:               // *****************************************************************************
137:               // *****************************************************************************
138:               // Section: Variables
139:               // *****************************************************************************
140:               // *****************************************************************************
141:               USB_VOLATILE USB_DEVICE_STATE USBDeviceState;
142:               USB_VOLATILE uint8_t USBActiveConfiguration;
143:               USB_VOLATILE uint8_t USBAlternateInterface[USB_MAX_NUM_INT];
144:               volatile BDT_ENTRY *pBDTEntryEP0OutCurrent;
145:               volatile BDT_ENTRY *pBDTEntryEP0OutNext;
146:               volatile BDT_ENTRY *pBDTEntryOut[USB_MAX_EP_NUMBER+1];
147:               volatile BDT_ENTRY *pBDTEntryIn[USB_MAX_EP_NUMBER+1];
148:               USB_VOLATILE uint8_t shortPacketStatus;
149:               USB_VOLATILE uint8_t controlTransferState;
150:               USB_VOLATILE IN_PIPE inPipes[1];
151:               USB_VOLATILE OUT_PIPE outPipes[1];
152:               USB_VOLATILE uint8_t *pDst;
153:               USB_VOLATILE bool RemoteWakeup;
154:               USB_VOLATILE bool USBBusIsSuspended;
155:               USB_VOLATILE USTAT_FIELDS USTATcopy;
156:               USB_VOLATILE uint8_t endpoint_number;
157:               USB_VOLATILE bool BothEP0OutUOWNsSet;
158:               USB_VOLATILE EP_STATUS ep_data_in[USB_MAX_EP_NUMBER+1];
159:               USB_VOLATILE EP_STATUS ep_data_out[USB_MAX_EP_NUMBER+1];
160:               USB_VOLATILE uint8_t USBStatusStageTimeoutCounter;
161:               volatile bool USBDeferStatusStagePacket;
162:               volatile bool USBStatusStageEnabledFlag1;
163:               volatile bool USBStatusStageEnabledFlag2;
164:               volatile bool USBDeferINDataStagePackets;
165:               volatile bool USBDeferOUTDataStagePackets;
166:               USB_VOLATILE uint32_t USB1msTickCount;
167:               USB_VOLATILE uint8_t USBTicksSinceSuspendEnd;
168:               
169:               /** USB FIXED LOCATION VARIABLES ***********************************/
170:               #if defined(COMPILER_MPLAB_C18)
171:                   #pragma udata USB_BDT=USB_BDT_ADDRESS
172:               #endif
173:               
174:               volatile BDT_ENTRY BDT[BDT_NUM_ENTRIES] BDT_BASE_ADDR_TAG;
175:               
176:               /********************************************************************
177:                * EP0 Buffer Space
178:                *******************************************************************/
179:               volatile CTRL_TRF_SETUP SetupPkt CTRL_TRF_SETUP_ADDR_TAG;
180:               volatile uint8_t CtrlTrfData[USB_EP0_BUFF_SIZE] CTRL_TRF_DATA_ADDR_TAG;
181:               
182:               /********************************************************************
183:                * non-EP0 Buffer Space
184:                *******************************************************************/
185:               #if defined(USB_USE_MSD)
186:                   //Check if the MSD application specific USB endpoint buffer placement address
187:                   //macros have already been defined or not (ex: in a processor specific header)
188:                   //The msd_cbw and msd_csw buffers must be USB module accessible (and therefore
189:                   //must be at a certain address range on certain microcontrollers).
190:                   #if !defined(MSD_CBW_ADDR_TAG)
191:                       //Not previously defined.  Assume in this case all microcontroller RAM is
192:                       //USB module accessible, and therefore, no specific address tag value is needed.
193:                       #define MSD_CBW_ADDR_TAG
194:                       #define MSD_CSW_ADDR_TAG
195:                   #endif
196:               	volatile USB_MSD_CBW msd_cbw MSD_CBW_ADDR_TAG;  //Must be located in USB module accessible RAM
197:               	volatile USB_MSD_CSW msd_csw MSD_CSW_ADDR_TAG;  //Must be located in USB module accessible RAM
198:               
199:                   #if defined(__18CXX) || defined(__XC8)
200:                       #if(__XC8_VERSION < 2000)
201:                       volatile char msd_buffer[512] @ MSD_BUFFER_ADDRESS;
202:                       #else
203:                           volatile char msd_buffer[512] __at(MSD_BUFFER_ADDRESS);
204:                       #endif
205:                   #else
206:                       volatile char msd_buffer[512];
207:               	#endif
208:               #endif
209:               
210:               //Depricated in v2.2 - will be removed in a future revision
211:               #if !defined(USB_USER_DEVICE_DESCRIPTOR)
212:                   //Device descriptor
213:                   extern const USB_DEVICE_DESCRIPTOR device_dsc;
214:               #else
215:                   USB_USER_DEVICE_DESCRIPTOR_INCLUDE;
216:               #endif
217:               
218:               #if !defined(USB_USER_CONFIG_DESCRIPTOR)
219:                   //Array of configuration descriptors
220:                   extern const uint8_t *const USB_CD_Ptr[];
221:               #else
222:                   USB_USER_CONFIG_DESCRIPTOR_INCLUDE;
223:               #endif
224:               
225:               extern const uint8_t *const USB_SD_Ptr[];
226:               
227:               
228:               // *****************************************************************************
229:               // *****************************************************************************
230:               // Section: Private and External Prototypes
231:               // *****************************************************************************
232:               // *****************************************************************************
233:               extern bool USER_USB_CALLBACK_EVENT_HANDLER(USB_EVENT event, void *pdata, uint16_t size);
234:               
235:               static void USBCtrlEPService(void);
236:               static void USBCtrlTrfSetupHandler(void);
237:               static void USBCtrlTrfInHandler(void);
238:               static void USBCheckStdRequest(void);
239:               static void USBStdGetDscHandler(void);
240:               static void USBCtrlEPServiceComplete(void);
241:               static void USBCtrlTrfTxService(void);
242:               static void USBCtrlTrfRxService(void);
243:               static void USBStdSetCfgHandler(void);
244:               static void USBStdGetStatusHandler(void);
245:               static void USBStdFeatureReqHandler(void);
246:               static void USBCtrlTrfOutHandler(void);
247:               static void USBConfigureEndpoint(uint8_t EPNum, uint8_t direction);
248:               static void USBWakeFromSuspend(void);
249:               static void USBSuspend(void);
250:               static void USBStallHandler(void);
251:               
252:               // *****************************************************************************
253:               // *****************************************************************************
254:               // Section: Macros or Functions
255:               // *****************************************************************************
256:               // *****************************************************************************
257:               
258:               /**************************************************************************
259:                   Function:
260:                       void USBDeviceInit(void)
261:               
262:                   Description:
263:                       This function initializes the device stack it in the default state. The
264:                       USB module will be completely reset including all of the internal
265:                       variables, registers, and interrupt flags.
266:               
267:                   Precondition:
268:                       This function must be called before any of the other USB Device
269:                       functions can be called, including USBDeviceTasks().
270:               
271:                   Parameters:
272:                       None
273:               
274:                   Return Values:
275:                       None
276:               
277:                   Remarks:
278:                       None
279:               
280:                 ***************************************************************************/
281:               void USBDeviceInit(void)
282:               {
283:                   uint8_t i;
284:               
285:                   USBDisableInterrupts();
006AB2  A9C09E     BCLR IEC5, #6
286:               
287:                   //Make sure that if a GPIO output driver exists on VBUS, that it is
288:                   //tri-stated to avoid potential contention with the host
289:                   USB_HAL_VBUSTristate();
290:               
291:                   // Clear all USB error flags
292:                   USBClearInterruptRegister(U1EIR);
006AB4  EB8000     SETM W0
006AB6  882470     MOV W0, U1EIR
293:               
294:                   // Clears all USB interrupts
295:                   USBClearInterruptRegister(U1IR);
006AB8  882450     MOV W0, U1IR
296:               
297:                   //Clear all of the endpoint control registers
298:                   U1EP0 = 0;
006ABA  EF24AA     CLR U1EP0
299:               
300:                   DisableNonZeroEndpoints(USB_MAX_EP_NUMBER);
006ABC  EF24AC     CLR U1EP1
301:               
302:                   SetConfigurationOptions();
006ABE  200020     MOV #0x2, W0
006AC0  882530     MOV W0, U1CNFG1
006AC2  EF24A8     CLR U1CNFG2
006AC4  A94486     BCLR U1OTGCON, #2
006AC6  2009F0     MOV #0x9F, W0
006AC8  882480     MOV W0, U1EIE
006ACA  882460     MOV W0, U1IE
006ACC  A8C482     BSET U1OTGIE, #6
303:               
304:                   //power up the module (if not already powered)
305:                   USBPowerModule();
006ACE  A80488     BSET U1PWRC, #0
306:               
307:                   //set the address of the BDT (if applicable)
308:                   USBSetBDTAddress(BDT);
006AD0  20A000     MOV #0xA00, W0
006AD2  DE00C8     LSR W0, #8, W1
006AD4  8824C1     MOV W1, U1BDTP1
309:               
310:                   //Clear all of the BDT entries
311:                   for(i = 0; i < (sizeof(BDT)/sizeof(BDT_ENTRY)); i++)
312:                   {
313:                       BDT[i].Val = 0x00;
006AD6  EB0800     CLR [W0]
006AD8  781030     MOV [W0++], [W0--]
006ADA  B80060     MUL.UU W0, #0, W0
006ADC  885020     MOV W0, 0xA04
006ADE  885031     MOV W1, 0xA06
006AE0  885040     MOV W0, 0xA08
006AE2  885051     MOV W1, 0xA0A
006AE4  885060     MOV W0, 0xA0C
006AE6  885071     MOV W1, 0xA0E
006AE8  885080     MOV W0, 0xA10
006AEA  885091     MOV W1, 0xA12
006AEC  8850A0     MOV W0, 0xA14
006AEE  8850B1     MOV W1, 0xA16
006AF0  8850C0     MOV W0, 0xA18
006AF2  8850D1     MOV W1, 0xA1A
006AF4  8850E0     MOV W0, 0xA1C
006AF6  8850F1     MOV W1, 0xA1E
314:                   }
315:               
316:                   // Assert reset request to all of the Ping Pong buffer pointers
317:                   USBPingPongBufferReset = 1;
006AF8  A82494     BSET U1CON, #1
318:               
319:                   // Reset to default address
320:                   U1ADDR = 0x00;
006AFA  EF2496     CLR U1ADDR
321:               
322:                   // Make sure packet processing is enabled
323:                   USBPacketDisable = 0;
006AFC  A9A494     BCLR U1CON, #5
324:               
325:                   //Stop trying to reset ping pong buffer pointers
326:                   USBPingPongBufferReset = 0;
006AFE  A92494     BCLR U1CON, #1
327:               
328:                   // Flush any pending transactions
329:                   do
330:                   {
331:                       USBClearInterruptFlag(USBTransactionCompleteIFReg,USBTransactionCompleteIFBitNum);
006B00  200080     MOV #0x8, W0
006B02  882450     MOV W0, U1IR
332:                       //Initialize USB stack software state variables
333:                       inPipes[0].info.Val = 0;
334:                       outPipes[0].info.Val = 0;
335:                       outPipes[0].wCount.Val = 0;
336:                   }while(USBTransactionCompleteIF == 1);
006B04  AB648A     BTST U1IR, #3
006B06  3AFFFD     BRA NZ, .L83
006B08  EB4000     CLR.B W0
006B0A  20A221     MOV #0xA22, W1
006B0C  784880     MOV.B W0, [W1]
006B0E  20A281     MOV #0xA28, W1
006B10  FB8100     ZE W0, W2
006B12  780882     MOV W2, [W1]
006B14  E88081     INC2 W1, W1
006B16  2FF002     MOV #0xFF00, W2
006B18  610891     AND W2, [W1], [W1]
337:               
338:                   //Set flags to true, so the USBCtrlEPAllowStatusStage() function knows not to
339:                   //try and arm a status stage, even before the first control transfer starts.
340:                   USBStatusStageEnabledFlag1 = true;
006B1A  B3C013     MOV.B #0x1, W3
006B1C  20F9E2     MOV #0xF9E, W2
006B1E  784903     MOV.B W3, [W2]
341:                   USBStatusStageEnabledFlag2 = true;
006B20  20F9F2     MOV #0xF9F, W2
006B22  784903     MOV.B W3, [W2]
342:                   //Initialize other flags
343:                   USBDeferINDataStagePackets = false;
006B24  EF6F80     CLR.B USBDeferINDataStagePackets
344:                   USBDeferOUTDataStagePackets = false;
006B26  EF6F7E     CLR.B USBDeferOUTDataStagePackets
345:                   USBBusIsSuspended = false;
006B28  EF6F82     CLR.B USBBusIsSuspended
346:               
347:                   //Initialize all pBDTEntryIn[] and pBDTEntryOut[]
348:                   //pointers to NULL, so they don't get used inadvertently.
349:                   for(i = 0; i < (uint8_t)(USB_MAX_EP_NUMBER+1u); i++)
350:                   {
351:                       pBDTEntryIn[i] = 0u;
006B34  EF2F8E     CLR 0xF8E
352:                       pBDTEntryOut[i] = 0u;
006B2A  EF2F88     CLR pBDTEntryOut
006B36  EF2F8A     CLR 0xF8A
353:                       ep_data_in[i].Val = 0u;
006B2C  20A2E1     MOV #0xA2E, W1
006B2E  784880     MOV.B W0, [W1]
006B38  20A2F1     MOV #0xA2F, W1
006B3A  784880     MOV.B W0, [W1]
354:                       ep_data_out[i].Val = 0u;
006B30  20A301     MOV #0xA30, W1
006B32  784880     MOV.B W0, [W1]
006B3C  20A311     MOV #0xA31, W1
006B3E  784880     MOV.B W0, [W1]
355:                   }
356:               
357:                   //Get ready for the first packet
358:                   pBDTEntryIn[0] = (volatile BDT_ENTRY*)&BDT[EP0_IN_EVEN];
006B40  20A080     MOV #0xA08, W0
006B42  887C60     MOV W0, pBDTEntryIn
359:                   // Initialize EP0 as a Ctrl EP
360:                   U1EP0 = EP_CTRL|USB_HANDSHAKE_ENABLED;
006B44  2000D0     MOV #0xD, W0
006B46  882550     MOV W0, U1EP0
361:               	//Prepare for the first SETUP on EP0 OUT
362:                   BDT[EP0_OUT_EVEN].ADR = ConvertToPhysicalAddress(&SetupPkt);
006B48  20A320     MOV #0xA32, W0
006B4A  885010     MOV W0, 0xA02
363:                   BDT[EP0_OUT_EVEN].CNT = USB_EP0_BUFF_SIZE;
006B4C  B3C081     MOV.B #0x8, W1
006B4E  20A000     MOV #0xA00, W0
006B50  784801     MOV.B W1, [W0]
364:                   BDT[EP0_OUT_EVEN].STAT.Val = _DAT0|_BSTALL;
006B52  E80000     INC W0, W0
006B54  B3C041     MOV.B #0x4, W1
006B56  784801     MOV.B W1, [W0]
365:                   BDT[EP0_OUT_EVEN].STAT.Val |= _USIE;
006B58  A07410     BSET.B [W0], #7
366:               
367:                   // Clear active configuration
368:                   USBActiveConfiguration = 0;
006B5A  EF6F86     CLR.B USBActiveConfiguration
369:               
370:                   USB1msTickCount = 0;            //Keeps track of total number of milliseconds since calling USBDeviceInit() when first initializing the USB module/stack code.
006B5C  EF2FA0     CLR USB1msTickCount
006B5E  EF2FA2     CLR 0xFA2
371:                   USBTicksSinceSuspendEnd = 0;    //Keeps track of the number of milliseconds since a suspend condition has ended.
006B60  EF6F87     CLR.B USBTicksSinceSuspendEnd
372:               
373:                   //Indicate that we are now in the detached state
374:                   USBDeviceState = DETACHED_STATE;
006B62  EF2F84     CLR USBDeviceState
375:               }
006B64  060000     RETURN
376:               
377:               
378:               
379:               /**************************************************************************
380:                 Function:
381:                       void USBDeviceTasks(void)
382:               
383:                 Summary:
384:                   This function is the main state machine/transaction handler of the USB
385:                   device side stack.  When the USB stack is operated in "USB_POLLING" mode
386:                   (usb_config.h user option) the USBDeviceTasks() function should be called
387:                   periodically to receive and transmit packets through the stack. This
388:                   function also takes care of control transfers associated with the USB
389:                   enumeration process, and detecting various USB events (such as suspend).
390:                   This function should be called at least once every 1.8ms during the USB
391:                   enumeration process. After the enumeration process is complete (which can
392:                   be determined when USBGetDeviceState() returns CONFIGURED_STATE), the
393:                   USBDeviceTasks() handler may be called the faster of: either once
394:                   every 9.8ms, or as often as needed to make sure that the hardware USTAT
395:                   FIFO never gets full.  A good rule of thumb is to call USBDeviceTasks() at
396:                   a minimum rate of either the frequency that USBTransferOnePacket() gets
397:                   called, or, once/1.8ms, whichever is faster.  See the inline code comments
398:                   near the top of usb_device.c for more details about minimum timing
399:                   requirements when calling USBDeviceTasks().
400:               
401:                   When the USB stack is operated in "USB_INTERRUPT" mode, it is not necessary
402:                   to call USBDeviceTasks() from the main loop context.  In the USB_INTERRUPT
403:                   mode, the USBDeviceTasks() handler only needs to execute when a USB
404:                   interrupt occurs, and therefore only needs to be called from the interrupt
405:                   context.
406:               
407:                 Description:
408:                   This function is the main state machine/transaction handler of the USB
409:                   device side stack.  When the USB stack is operated in "USB_POLLING" mode
410:                   (usb_config.h user option) the USBDeviceTasks() function should be called
411:                   periodically to receive and transmit packets through the stack. This
412:                   function also takes care of control transfers associated with the USB
413:                   enumeration process, and detecting various USB events (such as suspend).
414:                   This function should be called at least once every 1.8ms during the USB
415:                   enumeration process. After the enumeration process is complete (which can
416:                   be determined when USBGetDeviceState() returns CONFIGURED_STATE), the
417:                   USBDeviceTasks() handler may be called the faster of: either once
418:                   every 9.8ms, or as often as needed to make sure that the hardware USTAT
419:                   FIFO never gets full.  A good rule of thumb is to call USBDeviceTasks() at
420:                   a minimum rate of either the frequency that USBTransferOnePacket() gets
421:                   called, or, once/1.8ms, whichever is faster.  See the inline code comments
422:                   near the top of usb_device.c for more details about minimum timing
423:                   requirements when calling USBDeviceTasks().
424:               
425:                   When the USB stack is operated in "USB_INTERRUPT" mode, it is not necessary
426:                   to call USBDeviceTasks() from the main loop context.  In the USB_INTERRUPT
427:                   mode, the USBDeviceTasks() handler only needs to execute when a USB
428:                   interrupt occurs, and therefore only needs to be called from the interrupt
429:                   context.
430:               
431:                   Typical usage:
432:                   <code>
433:                   void main(void)
434:                   {
435:                       USBDeviceInit();
436:                       while(1)
437:                       {
438:                           USBDeviceTasks(); //Takes care of enumeration and other USB events
439:                           if((USBGetDeviceState() \< CONFIGURED_STATE) ||
440:                              (USBIsDeviceSuspended() == true))
441:                           {
442:                               //Either the device is not configured or we are suspended,
443:                               // so we don't want to execute any USB related application code
444:                               continue;   //go back to the top of the while loop
445:                           }
446:                           else
447:                           {
448:                               //Otherwise we are free to run USB and non-USB related user
449:                               //application code.
450:                               UserApplication();
451:                           }
452:                       }
453:                   }
454:                   </code>
455:               
456:                 Precondition:
457:                   Make sure the USBDeviceInit() function has been called prior to calling
458:                   USBDeviceTasks() for the first time.
459:                 Remarks:
460:                   USBDeviceTasks() does not need to be called while in the USB suspend mode,
461:                   if the user application firmware in the USBCBSuspend() callback function
462:                   enables the ACTVIF USB interrupt source and put the microcontroller into
463:                   sleep mode.  If the application firmware decides not to sleep the
464:                   microcontroller core during USB suspend (ex: continues running at full
465:                   frequency, or clock switches to a lower frequency), then the USBDeviceTasks()
466:                   function must still be called periodically, at a rate frequent enough to
467:                   ensure the 10ms resume recovery interval USB specification is met.  Assuming
468:                   a worst case primary oscillator and PLL start up time of less than 5ms, then
469:                   USBDeviceTasks() should be called once every 5ms in this scenario.
470:               
471:                   When the USB cable is detached, or the USB host is not actively powering
472:                   the VBUS line to +5V nominal, the application firmware does not always have
473:                   to call USBDeviceTasks() frequently, as no USB activity will be taking
474:                   place.  However, if USBDeviceTasks() is not called regularly, some
475:                   alternative means of promptly detecting when VBUS is powered (indicating
476:                   host attachment), or not powered (host powered down or USB cable unplugged)
477:                   is still needed.  For self or dual self/bus powered USB applications, see
478:                   the USBDeviceAttach() and USBDeviceDetach() API documentation for additional
479:                   considerations.
480:                   ***************************************************************************/
481:               void USBDeviceTasks(void)
482:               {
006F38  BE9F88     MOV.D W8, [W15++]
006F3A  781F8A     MOV W10, [W15++]
483:                   uint8_t i;
484:               
485:                   #ifdef USB_SUPPORT_OTG
486:                       //SRP Time Out Check
487:                       if (USBOTGSRPIsReady())
488:                       {
489:                           if (USBT1MSECIF && USBT1MSECIE)
490:                           {
491:                               if (USBOTGGetSRPTimeOutFlag())
492:                               {
493:                                   if (USBOTGIsSRPTimeOutExpired())
494:                                   {
495:                                       USB_OTGEventHandler(0,OTG_EVENT_SRP_FAILED,0,0);
496:                                   }
497:                               }
498:               
499:                               //Clear Interrupt Flag
500:                               USBClearInterruptFlag(USBT1MSECIFReg,USBT1MSECIFBitNum);
501:                           }
502:                       }
503:                   #endif
504:               
505:                   #if defined(USB_POLLING)
506:                   //If the interrupt option is selected then the customer is required
507:                   //  to notify the stack when the device is attached or removed from the
508:                   //  bus by calling the USBDeviceAttach() and USBDeviceDetach() functions.
509:                   if (USB_BUS_SENSE != 1)
510:                   {
511:                        // Disable module & detach from bus
512:                        U1CON = 0;
513:               
514:                        // Mask all USB interrupts
515:                        U1IE = 0;
516:               
517:                        //Move to the detached state
518:                        USBDeviceState = DETACHED_STATE;
519:               
520:                        #ifdef  USB_SUPPORT_OTG
521:                            //Disable D+ Pullup
522:                            U1OTGCONbits.DPPULUP = 0;
523:               
524:                            //Disable HNP
525:                            USBOTGDisableHnp();
526:               
527:                            //Deactivate HNP
528:                            USBOTGDeactivateHnp();
529:               
530:                            //If ID Pin Changed State
531:                            if (USBIDIF && USBIDIE)
532:                            {
533:                                //Re-detect & Initialize
534:                                 USBOTGInitialize();
535:               
536:                                 //Clear ID Interrupt Flag
537:                                 USBClearInterruptFlag(USBIDIFReg,USBIDIFBitNum);
538:                            }
539:                        #endif
540:               
541:                        #if defined __C30__ || defined __XC16__
542:                            //USBClearInterruptFlag(U1OTGIR, 3);
543:                        #endif
544:                           //return so that we don't go through the rest of
545:                           //the state machine
546:                        USBClearUSBInterrupt();
547:                        return;
548:                   }
549:               
550:               	#ifdef USB_SUPPORT_OTG
551:                   //If Session Is Started Then
552:                   else
553:               	{
554:                       //If SRP Is Ready
555:                       if (USBOTGSRPIsReady())
556:                       {
557:                           //Clear SRPReady
558:                           USBOTGClearSRPReady();
559:               
560:                           //Clear SRP Timeout Flag
561:                           USBOTGClearSRPTimeOutFlag();
562:               
563:                           //Indicate Session Started
564:                           UART2PrintString( "\r\n***** USB OTG B Event - Session Started  *****\r\n" );
565:                       }
566:                   }
567:               	#endif	//#ifdef USB_SUPPORT_OTG
568:               
569:                   //if we are in the detached state
570:                   if(USBDeviceState == DETACHED_STATE)
006F3C  807C20     MOV USBDeviceState, W0
006F3E  E00000     CP0 W0
006F40  3A0012     BRA NZ, .L134
571:                   {
572:               	    //Initialize register to known value
573:                       U1CON = 0;
006F42  EF2494     CLR U1CON
574:               
575:                       // Mask all USB interrupts
576:                       U1IE = 0;
006F44  EF248C     CLR U1IE
577:               
578:                       //Enable/set things like: pull ups, full/low-speed mode,
579:                       //set the ping pong mode, and set internal transceiver
580:                       SetConfigurationOptions();
006F46  200020     MOV #0x2, W0
006F48  882530     MOV W0, U1CNFG1
006F4A  EF24A8     CLR U1CNFG2
006F4C  A94486     BCLR U1OTGCON, #2
006F4E  2009F0     MOV #0x9F, W0
006F50  882480     MOV W0, U1EIE
006F52  882460     MOV W0, U1IE
006F54  A8C482     BSET U1OTGIE, #6
581:               
582:                       // Enable module & attach to bus
583:                       while(!U1CONbits.USBEN){U1CONbits.USBEN = 1;}
006F56  AB0494     BTST U1CON, #0
006F58  3A0003     BRA NZ, .L135
006F5A  A80494     BSET U1CON, #0
006F5C  AB0494     BTST U1CON, #0
006F5E  32FFFD     BRA Z, .L159
584:               
585:                       //moved to the attached state
586:                       USBDeviceState = ATTACHED_STATE;
006F60  200010     MOV #0x1, W0
006F62  887C20     MOV W0, USBDeviceState
006F64  370002     BRA .L137
587:               
588:                       #ifdef  USB_SUPPORT_OTG
589:                           U1OTGCON |= USB_OTG_DPLUS_ENABLE | USB_OTG_ENABLE;
590:                       #endif
591:                   }
592:               	#endif  //#if defined(USB_POLLING)
593:               
594:                   if(USBDeviceState == ATTACHED_STATE)
006F66  500FE1     SUB W0, #0x1, [W15]
006F68  3A0008     BRA NZ, .L138
595:                   {
596:                       /*
597:                        * After enabling the USB module, it takes some time for the
598:                        * voltage on the D+ or D- line to rise high enough to get out
599:                        * of the SE0 condition. The USB Reset interrupt should not be
600:                        * unmasked until the SE0 condition is cleared. This helps
601:                        * prevent the firmware from misinterpreting this unique event
602:                        * as a USB bus reset from the USB host.
603:                        */
604:               
605:                       if(!USBSE0Event)
006F6A  ABC494     BTST U1CON, #6
006F6C  3A0006     BRA NZ, .L138
606:                       {
607:                           //We recently attached, make sure we are in a clean state
608:                           #if defined(__dsPIC33E__) || defined(_PIC24E__) || defined(__PIC32MM__)
609:                               U1IR = 0xFFEF;  //Preserve IDLEIF info, so we can detect suspend
610:                                               //during attach de-bounce interval
611:                           #else
612:                               USBClearInterruptRegister(U1IR);
006F6E  EFA48A     SETM U1IR
613:                           #endif
614:               
615:                           #if defined(USB_POLLING)
616:                               U1IE=0;                        // Mask all USB interrupts
006F70  EF248C     CLR U1IE
617:                           #endif
618:                           USBResetIE = 1;             // Unmask RESET interrupt
006F72  A8048C     BSET U1IE, #0
619:                           USBIdleIE = 1;             // Unmask IDLE interrupt
006F74  A8848C     BSET U1IE, #4
620:                           USBDeviceState = POWERED_STATE;
006F76  200020     MOV #0x2, W0
006F78  887C20     MOV W0, USBDeviceState
621:                       }
622:                   }
623:               
624:                   #ifdef  USB_SUPPORT_OTG
625:                       //If ID Pin Changed State
626:                       if (USBIDIF && USBIDIE)
627:                       {
628:                           //Re-detect & Initialize
629:                           USBOTGInitialize();
630:               
631:                           USBClearInterruptFlag(USBIDIFReg,USBIDIFBitNum);
632:                       }
633:                   #endif
634:               
635:                   /*
636:                    * Task A: Service USB Activity Interrupt
637:                    */
638:                   if(USBActivityIF && USBActivityIE)
006F7A  AB8480     BTST U1OTGIR, #4
006F7C  320005     BRA Z, .L139
006F7E  AB8482     BTST U1OTGIE, #4
006F80  320003     BRA Z, .L139
639:                   {
640:                       USBClearInterruptFlag(USBActivityIFReg,USBActivityIFBitNum);
006F82  200100     MOV #0x10, W0
006F84  882400     MOV W0, U1OTGIR
641:                       #if defined(USB_SUPPORT_OTG)
642:                           U1OTGIR = 0x10;
643:                       #else
644:                           USBWakeFromSuspend();
006F86  07FC5B     RCALL _USBWakeFromSuspend, .LFE21, .LFB17
645:                       #endif
646:                   }
647:               
648:                   /*
649:                    * Pointless to continue servicing if the device is in suspend mode.
650:                    */
651:                   if(USBSuspendControl==1)
006F88  AB2488     BTST U1PWRC, #1
006F8A  320002     BRA Z, .L140
652:                   {
653:                       USBClearUSBInterrupt();
006F8C  A9C08E     BCLR IFS5, #6
654:                       return;
006F8E  37006A     BRA .L133
655:                   }
656:               
657:                   /*
658:                    * Task B: Service USB Bus Reset Interrupt.
659:                    * When bus reset is received during suspend, ACTVIF will be set first,
660:                    * once the UCONbits.SUSPND is clear, then the URSTIF bit will be asserted.
661:                    * This is why URSTIF is checked after ACTVIF.
662:                    *
663:                    * The USB reset flag is masked when the USB state is in
664:                    * DETACHED_STATE or ATTACHED_STATE, and therefore cannot
665:                    * cause a USB reset event during these two states.
666:                    */
667:                   if(USBResetIF && USBResetIE)
006F90  AB048A     BTST U1IR, #0
006F92  320007     BRA Z, .L142
006F94  AB048C     BTST U1IE, #0
006F96  320005     BRA Z, .L142
668:                   {
669:                       USBDeviceInit();
006F98  07FD8C     RCALL USBDeviceInit
670:               
671:                       //Re-enable the interrupts since the USBDeviceInit() function will
672:                       //  disable them.  This will do nothing in a polling setup
673:                       USBUnmaskInterrupts();
674:               
675:                       USBDeviceState = DEFAULT_STATE;
006F9A  200040     MOV #0x4, W0
006F9C  887C20     MOV W0, USBDeviceState
676:               
677:                       #ifdef USB_SUPPORT_OTG
678:                            //Disable HNP
679:                            USBOTGDisableHnp();
680:               
681:                            //Deactivate HNP
682:                            USBOTGDeactivateHnp();
683:                       #endif
684:               
685:                       USBClearInterruptFlag(USBResetIFReg,USBResetIFBitNum);
006F9E  200010     MOV #0x1, W0
006FA0  882450     MOV W0, U1IR
686:                   }
687:               
688:                   /*
689:                    * Task C: Service other USB interrupts
690:                    */
691:                   if(USBIdleIF && USBIdleIE)
006FA2  AB848A     BTST U1IR, #4
006FA4  320003     BRA Z, .L143
006FA6  AB848C     BTST U1IE, #4
006FA8  320001     BRA Z, .L143
692:                   {
693:                       #ifdef  USB_SUPPORT_OTG
694:                           //If Suspended, Try to switch to Host
695:                           USBOTGSelectRole(ROLE_HOST);
696:                           USBClearInterruptFlag(USBIdleIFReg,USBIdleIFBitNum);
697:                       #else
698:                           USBSuspend();
006FAA  07FC53     RCALL _USBSuspend, .LFE17, .LFB16
699:                       #endif
700:                   }
701:               
702:                   #if defined(__XC16__) || defined(__C30__) || defined(__XC32__)
703:                       //Check if a 1ms interval has elapsed.
704:                       if(USBT1MSECIF)
006FAC  ABC480     BTST U1OTGIR, #6
006FAE  320003     BRA Z, .L144
705:                       {
706:                           USBClearInterruptFlag(USBT1MSECIFReg, USBT1MSECIFBitNum);
006FB0  200400     MOV #0x40, W0
006FB2  882400     MOV W0, U1OTGIR
707:                           USBIncrement1msInternalTimers();
006FB4  07FFB4     RCALL USBIncrement1msInternalTimers
708:                       }
709:                   #endif
710:               
711:                   //Start-of-Frame Interrupt
712:                   if(USBSOFIF)
006FB6  AB448A     BTST U1IR, #2
006FB8  32000E     BRA Z, .L145
713:                   {
714:                       //Call the user SOF event callback if enabled.
715:                       if(USBSOFIE)
006FBA  AB448C     BTST U1IE, #2
006FBC  320004     BRA Z, .L146
716:                       {
717:                           USB_SOF_HANDLER(EVENT_SOF,0,1);
006FBE  200012     MOV #0x1, W2
006FC0  EB0080     CLR W1
006FC2  200730     MOV #0x73, W0
006FC4  070139     RCALL USER_USB_CALLBACK_EVENT_HANDLER
718:                       }
719:                       USBClearInterruptFlag(USBSOFIFReg,USBSOFIFBitNum);
006FC6  200040     MOV #0x4, W0
006FC8  882450     MOV W0, U1IR
720:               
721:                       #if defined(__XC8__) || defined(__C18__)
722:                           USBIncrement1msInternalTimers();
723:                       #endif
724:               
725:                       #if defined(USB_ENABLE_STATUS_STAGE_TIMEOUTS)
726:                           //Supporting this feature requires a 1ms time base for keeping track of the timeout interval.
727:                           #if(USB_SPEED_OPTION == USB_LOW_SPEED)
728:                               #warning "Double click this message.  See inline code comments."
729:                               //The "USB_ENABLE_STATUS_STAGE_TIMEOUTS" feature is optional and is
730:                               //not strictly needed in all applications (ex: those that never call
731:                               //USBDeferStatusStage() and don't use host to device (OUT) control
732:                               //transfers with data stage).
733:                               //However, if this feature is enabled and used in a low speed application,
734:                               //it is required for the application code to periodically call the
735:                               //USBIncrement1msInternalTimers() function at a nominally 1ms rate.
736:                           #endif
737:               
738:                           //Decrement our status stage counter.
739:                           if(USBStatusStageTimeoutCounter != 0u)
006FCA  BFCF9D     MOV.B USBStatusStageTimeoutCounter, WREG
006FCC  320003     BRA Z, .L147
740:                           {
741:                               USBStatusStageTimeoutCounter--;
006FCE  E94000     DEC.B W0, W0
006FD0  B7EF9D     MOV.B WREG, USBStatusStageTimeoutCounter
742:                           }
743:                           //Check if too much time has elapsed since progress was made in
744:                           //processing the control transfer, without arming the status stage.
745:                           //If so, auto-arm the status stage to ensure that the control
746:                           //transfer can [eventually] complete, within the timing limits
747:                           //dictated by section 9.2.6 of the official USB 2.0 specifications.
748:                           if(USBStatusStageTimeoutCounter == 0)
006FD2  3A0001     BRA NZ, .L145
749:                           {
750:                               USBCtrlEPAllowStatusStage();    //Does nothing if the status stage was already armed.
006FD4  07FE4B     RCALL USBCtrlEPAllowStatusStage
751:                           }
752:                       #endif
753:                   }
754:               
755:                   if(USBStallIF && USBStallIE)
006FD6  ABE48A     BTST U1IR, #7
006FD8  320003     BRA Z, .L148
006FDA  ABE48C     BTST U1IE, #7
006FDC  320001     BRA Z, .L148
756:                   {
757:                       USBStallHandler();
006FDE  07FBD0     RCALL _USBStallHandler, .LFE14, .LFB15
758:                   }
759:               
760:                   if(USBErrorIF && USBErrorIE)
006FE0  AB248A     BTST U1IR, #1
006FE2  320009     BRA Z, .L149
006FE4  AB248C     BTST U1IE, #1
006FE6  320007     BRA Z, .L149
761:                   {
762:                       USB_ERROR_HANDLER(EVENT_BUS_ERROR,0,1);
006FE8  200012     MOV #0x1, W2
006FEA  EB0080     CLR W1
006FEC  27FFF0     MOV #0x7FFF, W0
006FEE  070124     RCALL USER_USB_CALLBACK_EVENT_HANDLER
763:                       USBClearInterruptRegister(U1EIR);               // This clears UERRIF
006FF0  EFA48E     SETM U1EIR
764:               
765:                       //On PIC18, clearing the source of the error will automatically clear
766:                       //  the interrupt flag.  On other devices the interrupt flag must be
767:                       //  manually cleared.
768:                       #if defined(__C32__) || defined(__C30__) || defined __XC16__
769:                           USBClearInterruptFlag( USBErrorIFReg, USBErrorIFBitNum );
006FF2  200020     MOV #0x2, W0
006FF4  882450     MOV W0, U1IR
770:                       #endif
771:                   }
772:               
773:                   /*
774:                    * Pointless to continue servicing if the host has not sent a bus reset.
775:                    * Once bus reset is received, the device transitions into the DEFAULT
776:                    * state and is ready for communication.
777:                    */
778:                   if(USBDeviceState < DEFAULT_STATE)
006FF6  807C20     MOV USBDeviceState, W0
006FF8  500FE3     SUB W0, #0x3, [W15]
006FFA  3E0002     BRA GTU, .L150
779:                   {
780:                       USBClearUSBInterrupt();
006FFC  A9C08E     BCLR IFS5, #6
781:                       return;
006FFE  370032     BRA .L133
782:                   }
783:               
784:                   /*
785:                    * Task D: Servicing USB Transaction Complete Interrupt
786:                    */
787:                   if(USBTransactionCompleteIE)
007000  AB648C     BTST U1IE, #3
007002  32002F     BRA Z, .L151
788:                   {
789:                       for(i = 0; i < 4u; i++)	//Drain or deplete the USAT FIFO entries.  If the USB FIFO ever gets full, USB bandwidth
007060  3AFFD5     BRA NZ, .L157
790:                       {						//utilization can be compromised, and the device won't be able to receive SETUP packets.
791:                            if(USBTransactionCompleteIF)
007004  B3C048     MOV.B #0x4, W8
007006  AB648A     BTST U1IR, #3
007008  3A0004     BRA NZ, .L152
00700A  37002B     BRA .L151
00700C  AB648A     BTST U1IR, #3
00700E  3A0003     BRA NZ, .L161
007010  370028     BRA .L151
792:                           {
793:                               //Save and extract USTAT register info.  Will use this info later.
794:                               USTATcopy.Val = U1STAT;
007016  802491     MOV U1STAT, W1
007018  20F9A0     MOV #0xF9A, W0
00701A  784801     MOV.B W1, [W0]
795:                               endpoint_number = USBHALGetLastEndpoint(USTATcopy);
00701C  FB8101     ZE W1, W2
00701E  DE1144     LSR W2, #4, W2
007020  784002     MOV.B W2, W0
007022  784202     MOV.B W2, W4
007024  20F9B3     MOV #0xF9B, W3
007026  784984     MOV.B W4, [W3]
796:               
797:                               USBClearInterruptFlag(USBTransactionCompleteIFReg,USBTransactionCompleteIFBitNum);
007028  200082     MOV #0x8, W2
00702A  882452     MOV W2, U1IR
798:               
799:                               //Keep track of the hardware ping pong state for endpoints other
800:                               //than EP0, if ping pong buffering is enabled.
801:                               #if (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)
802:                               if(USBHALGetLastDirection(USTATcopy) == OUT_FROM_HOST)
00702C  A33801     BTST.Z W1, #3
00702E  3A0008     BRA NZ, .L153
803:                               {
804:                                   ep_data_out[endpoint_number].bits.ping_pong_state ^= 1;
007012  20A309     MOV #0xA30, W9
007030  FB8080     ZE W0, W1
007032  78C169     MOV.B [W9+W1], W2
007034  6141E1     AND.B W2, #0x1, W3
007036  A20403     BTG.B W3, #0
007038  A10402     BCLR.B W2, #0
00703A  714103     IOR.B W2, W3, W2
00703C  78F482     MOV.B W2, [W9+W1]
00703E  370007     BRA .L154
805:                               }
806:                               else
807:                               {
808:                                   ep_data_in[endpoint_number].bits.ping_pong_state ^= 1;
007014  20A2EA     MOV #0xA2E, W10
007040  FB8080     ZE W0, W1
007042  78C16A     MOV.B [W10+W1], W2
007044  6141E1     AND.B W2, #0x1, W3
007046  A20403     BTG.B W3, #0
007048  A10402     BCLR.B W2, #0
00704A  714103     IOR.B W2, W3, W2
00704C  78F502     MOV.B W2, [W10+W1]
809:                               }
810:                               #endif
811:               
812:                               //USBCtrlEPService only services transactions over EP0.
813:                               //It ignores all other EP transactions.
814:                               if(endpoint_number == 0)
00704E  E00400     CP0.B W0
007050  3A0002     BRA NZ, .L155
815:                               {
816:                                   USBCtrlEPService();
007052  07FF45     RCALL _USBCtrlEPService, .LFE19, .LFB18
007054  370004     BRA .L156
817:                               }
818:                               else
819:                               {
820:                                   USB_TRANSFER_COMPLETE_HANDLER(EVENT_TRANSFER, (uint8_t*)&USTATcopy.Val, 0);
007056  EB0100     CLR W2
007058  20F9A1     MOV #0xF9A, W1
00705A  200720     MOV #0x72, W0
00705C  0700ED     RCALL USER_USB_CALLBACK_EVENT_HANDLER
00705E  E94408     DEC.B W8, W8
821:                               }
822:                           }//end if(USBTransactionCompleteIF)
823:                           else
824:                           {
825:                               break;	//USTAT FIFO must be empty.
826:                           }
827:                       }//end for()
828:                   }//end if(USBTransactionCompleteIE)
829:               
830:                   USBClearUSBInterrupt();
007062  A9C08E     BCLR IFS5, #6
831:               }//end of USBDeviceTasks()
007064  78054F     MOV [--W15], W10
007066  BE044F     MOV.D [--W15], W8
007068  060000     RETURN
832:               
833:               /*******************************************************************************
834:                 Function:
835:                       void USBEnableEndpoint(uint8_t ep, uint8_t options)
836:               
837:                 Summary:
838:                   This function will enable the specified endpoint with the specified
839:                   options
840:                 Description:
841:                   This function will enable the specified endpoint with the specified
842:                   options.
843:               
844:                   Typical Usage:
845:                   <code>
846:                   void USBCBInitEP(void)
847:                   {
848:                       USBEnableEndpoint(MSD_DATA_IN_EP,USB_IN_ENABLED|USB_OUT_ENABLED|USB_HANDSHAKE_ENABLED|USB_DISALLOW_SETUP);
849:                       USBMSDInit();
850:                   }
851:                   </code>
852:               
853:                   In the above example endpoint number MSD_DATA_IN_EP is being configured
854:                   for both IN and OUT traffic with handshaking enabled. Also since
855:                   MSD_DATA_IN_EP is not endpoint 0 (MSD does not allow this), then we can
856:                   explicitly disable SETUP packets on this endpoint.
857:                 Conditions:
858:                   None
859:                 Input:
860:                   uint8_t ep -       the endpoint to be configured
861:                   uint8_t options -  optional settings for the endpoint. The options should
862:                                   be ORed together to form a single options string. The
863:                                   available optional settings for the endpoint. The
864:                                   options should be ORed together to form a single options
865:                                   string. The available options are the following\:
866:                                   * USB_HANDSHAKE_ENABLED enables USB handshaking (ACK,
867:                                     NAK)
868:                                   * USB_HANDSHAKE_DISABLED disables USB handshaking (ACK,
869:                                     NAK)
870:                                   * USB_OUT_ENABLED enables the out direction
871:                                   * USB_OUT_DISABLED disables the out direction
872:                                   * USB_IN_ENABLED enables the in direction
873:                                   * USB_IN_DISABLED disables the in direction
874:                                   * USB_ALLOW_SETUP enables control transfers
875:                                   * USB_DISALLOW_SETUP disables control transfers
876:                                   * USB_STALL_ENDPOINT STALLs this endpoint
877:                 Return:
878:                   None
879:                 Remarks:
880:                   None
881:                 *****************************************************************************/
882:               void USBEnableEndpoint(uint8_t ep, uint8_t options)
883:               {
006B66  BE9F88     MOV.D W8, [W15++]
006B68  781F8A     MOV W10, [W15++]
006B6A  784500     MOV.B W0, W10
006B6C  784481     MOV.B W1, W9
884:                   unsigned char* p;
885:               
886:                   //Use USBConfigureEndpoint() to set up the pBDTEntryIn/Out[ep] pointer and
887:                   //starting DTS state in the BDT entry.
888:                   if(options & USB_OUT_ENABLED)
006B6E  FB8409     ZE W9, W8
006B70  A33808     BTST.Z W8, #3
006B72  320003     BRA Z, .L86
889:                   {
890:                       USBConfigureEndpoint(ep, OUT_FROM_HOST);
006B74  EB4080     CLR.B W1
006B76  78400A     MOV.B W10, W0
006B78  07FD3F     RCALL _USBConfigureEndpoint, .Ltext0, .LFB8, .Letext0, .LFE36
891:                   }
892:                   if(options & USB_IN_ENABLED)
006B7A  A32808     BTST.Z W8, #2
006B7C  320003     BRA Z, .L87
893:                   {
894:                       USBConfigureEndpoint(ep, IN_TO_HOST);
006B7E  B3C011     MOV.B #0x1, W1
006B80  78400A     MOV.B W10, W0
006B82  07FD3A     RCALL _USBConfigureEndpoint, .Ltext0, .LFB8, .Letext0, .LFE36
895:                   }
896:               
897:                   //Update the relevant UEPx register to actually enable the endpoint with
898:                   //the specified options (ex: handshaking enabled, control transfers allowed,
899:                   //etc.)
900:                   #if defined(__C32__)
901:                       p = (unsigned char*)(&U1EP0+(4*ep));
902:                   #else
903:                       p = (unsigned char*)(&U1EP0+ep);
006B84  FB850A     ZE W10, W10
904:                   #endif
905:                   *p = options;
006B86  45050A     ADD W10, W10, W10
006B88  204AA0     MOV #0x4AA, W0
006B8A  7D7009     MOV.B W9, [W0+W10]
906:               }
006B8C  78054F     MOV [--W15], W10
006B8E  BE044F     MOV.D [--W15], W8
006B90  060000     RETURN
907:               
908:               
909:               /*************************************************************************
910:                 Function:
911:                   USB_HANDLE USBTransferOnePacket(uint8_t ep, uint8_t dir, uint8_t* data, uint8_t len)
912:               
913:                 Summary:
914:                   Transfers a single packet (one transaction) of data on the USB bus.
915:               
916:                 Description:
917:                   The USBTransferOnePacket() function prepares a USB endpoint
918:                   so that it may send data to the host (an IN transaction), or
919:                   receive data from the host (an OUT transaction).  The
920:                   USBTransferOnePacket() function can be used both to receive	and
921:                   send data to the host.  This function is the primary API function
922:                   provided by the USB stack firmware for sending or receiving application
923:                   data over the USB port.
924:               
925:                   The USBTransferOnePacket() is intended for use with all application
926:                   endpoints.  It is not used for sending or receiving application data
927:                   through endpoint 0 by using control transfers.  Separate API
928:                   functions, such as USBEP0Receive(), USBEP0SendRAMPtr(), and
929:                   USBEP0SendROMPtr() are provided for this purpose.
930:               
931:                   The	USBTransferOnePacket() writes to the Buffer Descriptor Table (BDT)
932:                   entry associated with an endpoint buffer, and sets the UOWN bit, which
933:                   prepares the USB hardware to allow the transaction to complete.  The
934:                   application firmware can use the USBHandleBusy() macro to check the
935:                   status of the transaction, to see if the data has been successfully
936:                   transmitted yet.
937:               
938:               
939:                   Typical Usage
940:                   <code>
941:                   //make sure that the we are in the configured state
942:                   if(USBGetDeviceState() == CONFIGURED_STATE)
943:                   {
944:                       //make sure that the last transaction isn't busy by checking the handle
945:                       if(!USBHandleBusy(USBInHandle))
946:                       {
947:               	        //Write the new data that we wish to send to the host to the INPacket[] array
948:               	        INPacket[0] = USEFUL_APPLICATION_VALUE1;
949:               	        INPacket[1] = USEFUL_APPLICATION_VALUE2;
950:               	        //INPacket[2] = ... (fill in the rest of the packet data)
951:               
952:                           //Send the data contained in the INPacket[] array through endpoint "EP_NUM"
953:                           USBInHandle = USBTransferOnePacket(EP_NUM,IN_TO_HOST,(uint8_t*)&INPacket[0],sizeof(INPacket));
954:                       }
955:                   }
956:                   </code>
957:               
958:                 Conditions:
959:                   Before calling USBTransferOnePacket(), the following should be true.
960:                   1.  The USB stack has already been initialized (USBDeviceInit() was called).
961:                   2.  A transaction is not already pending on the specified endpoint.  This
962:                       is done by checking the previous request using the USBHandleBusy()
963:                       macro (see the typical usage example).
964:                   3.  The host has already sent a set configuration request and the
965:                       enumeration process is complete.
966:                       This can be checked by verifying that the USBGetDeviceState()
967:                       macro returns "CONFIGURED_STATE", prior to calling
968:                       USBTransferOnePacket().
969:               
970:                 Input:
971:                   uint8_t ep - The endpoint number that the data will be transmitted or
972:               	          received on
973:                   uint8_t dir - The direction of the transfer
974:                              This value is either OUT_FROM_HOST or IN_TO_HOST
975:                   uint8_t* data - For IN transactions: pointer to the RAM buffer containing
976:                                the data to be sent to the host.  For OUT transactions: pointer
977:                                to the RAM buffer that the received data should get written to.
978:                  uint8_t len - Length of the data needing to be sent (for IN transactions).
979:                             For OUT transactions, the len parameter should normally be set
980:                             to the endpoint size specified in the endpoint descriptor.
981:               
982:                 Return Values:
983:                   USB_HANDLE - handle to the transfer.  The handle is a pointer to
984:                                the BDT entry associated with this transaction.  The
985:                                status of the transaction (ex: if it is complete or still
986:                                pending) can be checked using the USBHandleBusy() macro
987:                                and supplying the USB_HANDLE provided by
988:                                USBTransferOnePacket().
989:               
990:                 Remarks:
991:                   If calling the USBTransferOnePacket() function from within the USBCBInitEP()
992:                   callback function, the set configuration is still being processed and the
993:                   USBDeviceState may not be == CONFIGURED_STATE yet.  In this	special case,
994:                   the USBTransferOnePacket() may still be called, but make sure that the
995:                   endpoint has been enabled and initialized by the USBEnableEndpoint()
996:                   function first.
997:               
998:                 *************************************************************************/
999:               USB_HANDLE USBTransferOnePacket(uint8_t ep,uint8_t dir,uint8_t* data,uint8_t len)
1000:              {
1001:                  volatile BDT_ENTRY* handle;
1002:              
1003:                  //If the direction is IN
1004:                  if(dir != 0)
006B92  E00401     CP0.B W1
006B94  320005     BRA Z, .L89
1005:                  {
1006:                      //point to the IN BDT of the specified endpoint
1007:                      handle = pBDTEntryIn[ep];
006B96  FB8200     ZE W0, W4
006B98  420204     ADD W4, W4, W4
006B9A  20F8C5     MOV #0xF8C, W5
006B9C  7A0265     MOV [W5+W4], W4
006B9E  370004     BRA .L90
1008:                  }
1009:                  else
1010:                  {
1011:                      //else point to the OUT BDT of the specified endpoint
1012:                      handle = pBDTEntryOut[ep];
006BA0  FB8200     ZE W0, W4
006BA2  420204     ADD W4, W4, W4
006BA4  20F885     MOV #0xF88, W5
006BA6  7A0265     MOV [W5+W4], W4
1013:                  }
1014:              
1015:                  //Error checking code.  Make sure the handle (pBDTEntryIn[ep] or
1016:                  //pBDTEntryOut[ep]) is initialized before using it.
1017:                  if(handle == 0)
006BAA  E00004     CP0 W4
006BAC  32001A     BRA Z, .L91
1018:                  {
1019:                      return 0;
006BA8  EB0280     CLR W5
1020:                  }
1021:              
1022:                  //Toggle the DTS bit if required
1023:                  #if (USB_PING_PONG_MODE == USB_PING_PONG__NO_PING_PONG)
1024:                      handle->STAT.Val ^= _DTSMASK;
1025:                  #elif (USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY)
1026:                      if(ep != 0)
1027:                      {
1028:                          handle->STAT.Val ^= _DTSMASK;
1029:                      }
1030:                  #endif
1031:              
1032:                  //Set the data pointer, data length, and enable the endpoint
1033:                  handle->ADR = ConvertToPhysicalAddress(data);
006BAE  980212     MOV W2, [W4+2]
1034:                  handle->CNT = len;
006BB0  784A03     MOV.B W3, [W4]
1035:                  handle->STAT.Val &= _DTSMASK;
006BB2  904114     MOV.B [W4+1], W2
006BB4  B24402     AND.B #0x40, W2
006BB6  984212     MOV.B W2, [W4+1]
1036:                  handle->STAT.Val |= (_DTSEN & _DTS_CHECKING_ENABLED);
006BB8  904114     MOV.B [W4+1], W2
006BBA  A03402     BSET.B W2, #3
006BBC  984212     MOV.B W2, [W4+1]
1037:                  handle->STAT.Val |= _USIE;
006BBE  904114     MOV.B [W4+1], W2
006BC0  A07402     BSET.B W2, #7
006BC2  984212     MOV.B W2, [W4+1]
1038:              
1039:                  //Point to the next buffer for ping pong purposes.
1040:                  if(dir != OUT_FROM_HOST)
006BC4  E00401     CP0.B W1
006BC6  320007     BRA Z, .L92
1041:                  {
1042:                      //toggle over the to the next buffer for an IN endpoint
1043:                      pBDTEntryIn[ep] = (BDT_ENTRY*)(((uintptr_t)pBDTEntryIn[ep]) ^ USB_NEXT_PING_PONG);
006BC8  FB8000     ZE W0, W0
006BCA  400000     ADD W0, W0, W0
006BCC  20F8C1     MOV #0xF8C, W1
006BCE  408000     ADD W1, W0, W0
006BD0  A22010     BTG [W0], #2
1044:                  }
1045:                  else
1046:                  {
1047:                      //toggle over the to the next buffer for an OUT endpoint
1048:                      pBDTEntryOut[ep] = (BDT_ENTRY*)(((uintptr_t)pBDTEntryOut[ep]) ^ USB_NEXT_PING_PONG);
006BD6  FB8000     ZE W0, W0
006BD8  400000     ADD W0, W0, W0
006BDA  20F881     MOV #0xF88, W1
006BDC  408000     ADD W1, W0, W0
006BDE  A22010     BTG [W0], #2
1049:                  }
1050:                  return (USB_HANDLE)handle;
006BD2  780284     MOV W4, W5
006BD4  370006     BRA .L91
006BE0  780284     MOV W4, W5
1051:              }
006BE2  780005     MOV W5, W0
006BE4  060000     RETURN
1052:              
1053:              
1054:              /********************************************************************
1055:                  Function:
1056:                      void USBStallEndpoint(uint8_t ep, uint8_t dir)
1057:              
1058:                  Summary:
1059:                       Configures the specified endpoint to send STALL to the host, the next
1060:                       time the host tries to access the endpoint.
1061:              
1062:                  PreCondition:
1063:                      None
1064:              
1065:                  Parameters:
1066:                      uint8_t ep - The endpoint number that should be configured to send STALL.
1067:                      uint8_t dir - The direction of the endpoint to STALL, either
1068:                                 IN_TO_HOST or OUT_FROM_HOST.
1069:              
1070:                  Return Values:
1071:                      None
1072:              
1073:                  Remarks:
1074:                      None
1075:              
1076:               *******************************************************************/
1077:              void USBStallEndpoint(uint8_t ep, uint8_t dir)
1078:              {
1079:                  BDT_ENTRY *p;
1080:              
1081:                  if(ep == 0)
006BE6  E00400     CP0.B W0
006BE8  3A0014     BRA NZ, .L95
1082:                  {
1083:                      //For control endpoints (ex: EP0), we need to STALL both IN and OUT
1084:                      //endpoints.  EP0 OUT must also be prepared to receive the next SETUP
1085:                      //packet that will arrive.
1086:                      pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
006BEA  B3C081     MOV.B #0x8, W1
006BEC  807CA0     MOV pBDTEntryEP0OutNext, W0
006BEE  784801     MOV.B W1, [W0]
1087:                      pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
006BF0  807CA0     MOV pBDTEntryEP0OutNext, W0
006BF2  20A321     MOV #0xA32, W1
006BF4  980011     MOV W1, [W0+2]
1088:                      pBDTEntryEP0OutNext->STAT.Val = _DAT0|(_DTSEN & _DTS_CHECKING_ENABLED)|_BSTALL;
006BF6  B3C0C1     MOV.B #0xC, W1
006BF8  984011     MOV.B W1, [W0+1]
1089:                      pBDTEntryEP0OutNext->STAT.Val |= _USIE;
006BFA  807CA0     MOV pBDTEntryEP0OutNext, W0
006BFC  904090     MOV.B [W0+1], W1
006BFE  A07401     BSET.B W1, #7
006C00  984011     MOV.B W1, [W0+1]
1090:                      pBDTEntryIn[0]->STAT.Val = _BSTALL;
006C02  B3C041     MOV.B #0x4, W1
006C04  807C60     MOV pBDTEntryIn, W0
006C06  984011     MOV.B W1, [W0+1]
1091:                      pBDTEntryIn[0]->STAT.Val |= _USIE;
006C08  807C60     MOV pBDTEntryIn, W0
006C0A  904090     MOV.B [W0+1], W1
006C0C  A07401     BSET.B W1, #7
006C0E  984011     MOV.B W1, [W0+1]
006C10  370010     BRA .L94
1092:              
1093:                  }
1094:                  else
1095:                  {
1096:                      p = (BDT_ENTRY*)(&BDT[EP(ep,dir,0)]);
006C12  FB8081     ZE W1, W1
006C14  FB8000     ZE W0, W0
006C16  400000     ADD W0, W0, W0
006C18  408000     ADD W1, W0, W0
006C1A  DD0043     SL W0, #3, W0
006C1C  20A002     MOV #0xA00, W2
006C1E  400182     ADD W0, W2, W3
1097:                      p->STAT.Val |= _BSTALL;
1098:                      p->STAT.Val |= _USIE;
006C20  904213     MOV.B [W3+1], W4
006C22  B3C841     MOV.B #0x84, W1
006C24  724201     IOR.B W4, W1, W4
006C26  984194     MOV.B W4, [W3+1]
1099:              
1100:                      //If the device is in FULL or ALL_BUT_EP0 ping pong modes
1101:                      //then stall that entry as well
1102:                      #if (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG) || (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0)
1103:                      p = (BDT_ENTRY*)(&BDT[EP(ep,dir,1)]);
006C28  400064     ADD W0, #0x4, W0
006C2A  400002     ADD W0, W2, W0
1104:                      p->STAT.Val |= _BSTALL;
1105:                      p->STAT.Val |= _USIE;
006C2C  904110     MOV.B [W0+1], W2
006C2E  714081     IOR.B W2, W1, W1
006C30  984011     MOV.B W1, [W0+1]
1106:                      #endif
1107:                  }
1108:              }
006C32  060000     RETURN
1109:              
1110:              /**************************************************************************
1111:                  Function:
1112:                      void USBCancelIO(uint8_t endpoint)
1113:              
1114:                  Description:
1115:                      This function cancels the transfers pending on the specified endpoint.
1116:                      This function can only be used after a SETUP packet is received and
1117:                      before that setup packet is handled.  This is the time period in which
1118:                      the EVENT_EP0_REQUEST is thrown, before the event handler function
1119:                      returns to the stack.
1120:              
1121:                  Precondition:
1122:              
1123:                  Parameters:
1124:                      uint8_t endpoint - the endpoint number you wish to cancel the transfers for
1125:              
1126:                  Return Values:
1127:                      None
1128:              
1129:                  Remarks:
1130:                      None
1131:              
1132:                **************************************************************************/
1133:              void USBCancelIO(uint8_t endpoint)
1134:              {
1135:                  if(USBPacketDisable == 1)
006C34  ABA494     BTST U1CON, #5
006C36  320019     BRA Z, .L97
1136:                  {
1137:                  	//The PKTDIS bit is currently set right now.  It is therefore "safe"
1138:                  	//to mess with the BDT right now.
1139:                  	pBDTEntryIn[endpoint]->Val &= _DTSMASK;	//Makes UOWN = 0 (_UCPU mode).  Deactivates endpoint.  Only sends NAKs.
006C38  FB8000     ZE W0, W0
006C3A  400000     ADD W0, W0, W0
006C3C  20F8C1     MOV #0xF8C, W1
006C3E  408000     ADD W1, W0, W0
006C40  780090     MOV [W0], W1
006C42  BE0311     MOV.D [W1], W6
006C44  200404     MOV #0x40, W4
006C46  200005     MOV #0x0, W5
006C48  620306     AND W4, W6, W6
006C4A  EB0380     CLR W7
006C4C  BE8886     MOV.D W6, [W1]
1140:                  	pBDTEntryIn[endpoint]->Val ^= _DTSMASK;	//Toggle the DTS bit.  This packet didn't get sent yet, and the next call to USBTransferOnePacket() will re-toggle the DTS bit back to the original (correct) value.
006C4E  780090     MOV [W0], W1
006C50  BE0311     MOV.D [W1], W6
006C52  6B1884     XOR W6, W4, [W1++]
006C54  6B9085     XOR W7, W5, [W1--]
1141:              
1142:                  	//Need to do additional handling if ping-pong buffering is being used
1143:                      #if ((USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG) || (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0))
1144:                      //Point to the next buffer for ping pong purposes.  UOWN getting cleared
1145:                      //(either due to SIE clearing it after a transaction, or the firmware
1146:                      //clearing it) makes hardware ping pong pointer advance.
1147:                      pBDTEntryIn[endpoint] = (BDT_ENTRY*)(((uintptr_t)pBDTEntryIn[endpoint]) ^ USB_NEXT_PING_PONG);
006C56  780090     MOV [W0], W1
006C58  A22001     BTG W1, #2
006C5A  780801     MOV W1, [W0]
1148:              
1149:                  	pBDTEntryIn[endpoint]->STAT.Val &= _DTSMASK;
006C5C  904191     MOV.B [W1+1], W3
006C5E  B24403     AND.B #0x40, W3
006C60  984093     MOV.B W3, [W1+1]
1150:                  	pBDTEntryIn[endpoint]->STAT.Val ^= _DTSMASK;
006C62  780010     MOV [W0], W0
006C64  904090     MOV.B [W0+1], W1
006C66  68C104     XOR.B W1, W4, W2
006C68  984012     MOV.B W2, [W0+1]
1151:                      #endif
1152:                  }
1153:              }
006C6A  060000     RETURN
1154:              
1155:              /**************************************************************************
1156:                  Function:
1157:                      void USBDeviceDetach(void)
1158:              
1159:                  Summary:
1160:                      This function configures the USB module to "soft detach" itself from
1161:                      the USB host.
1162:              
1163:                  Description:
1164:                      This function configures the USB module to perform a "soft detach"
1165:                      operation, by disabling the D+ (or D-) ~1.5k pull up resistor, which
1166:                      lets the host know the device is present and attached.  This will make
1167:                      the host think that the device has been unplugged.  This is potentially
1168:                      useful, as it allows the USB device to force the host to re-enumerate
1169:                      the device (on the firmware has re-enabled the USB module/pull up, by
1170:                      calling USBDeviceAttach(), to "soft re-attach" to the host).
1171:              
1172:                  Precondition:
1173:                      Should only be called when USB_INTERRUPT is defined.  See remarks
1174:                      section if USB_POLLING mode option is being used (usb_config.h option).
1175:              
1176:                      Additionally, this function should only be called from the main() loop
1177:                      context.  Do not call this function from within an interrupt handler, as
1178:                      this function may modify global interrupt enable bits and settings.
1179:              
1180:                  Parameters:
1181:                      None
1182:              
1183:                  Return Values:
1184:                      None
1185:              
1186:                  Remarks:
1187:                      If the application firmware calls USBDeviceDetach(), it is strongly
1188:                      recommended that the firmware wait at least >= 80ms before calling
1189:                      USBDeviceAttach().  If the firmware performs a soft detach, and then
1190:                      re-attaches too soon (ex: after a few micro seconds for instance), some
1191:                      hosts may interpret this as an unexpected "glitch" rather than as a
1192:                      physical removal/re-attachment of the USB device.  In this case the host
1193:                      may simply ignore the event without re-enumerating the device.  To
1194:                      ensure that the host properly detects and processes the device soft
1195:                      detach/re-attach, it is recommended to make sure the device remains
1196:                      detached long enough to mimic a real human controlled USB
1197:                      unplug/re-attach event (ex: after calling USBDeviceDetach(), do not
1198:                      call USBDeviceAttach() for at least 80+ms, preferably longer.
1199:              
1200:                      Neither the USBDeviceDetach() or USBDeviceAttach() functions are blocking
1201:                      or take long to execute.  It is the application firmwares
1202:                      responsibility for adding the 80+ms delay, when using these API
1203:                      functions.
1204:              
1205:                      Note: The Windows plug and play event handler processing is fairly
1206:                      slow, especially in certain versions of Windows, and for certain USB
1207:                      device classes.  It has been observed that some device classes need to
1208:                      provide even more USB detach dwell interval (before calling
1209:                      USBDeviceAttach()), in order to work correctly after re-enumeration.
1210:                      If the USB device is a CDC class device, it is recommended to wait
1211:                      at least 1.5 seconds or longer, before soft re-attaching to the host,
1212:                      to provide the plug and play event handler enough time to finish
1213:                      processing the removal event, before the re-attach occurs.
1214:              
1215:                      If the application is using the USB_POLLING mode option, then the
1216:                      USBDeviceDetach() and USBDeviceAttach() functions are not available.
1217:                      In this mode, the USB stack relies on the "#define USE_USB_BUS_SENSE_IO"
1218:                      and "#define USB_BUS_SENSE" options in the
1219:                      HardwareProfile  [platform name].h file.
1220:              
1221:                      When using the USB_POLLING mode option, and the
1222:                      "#define USE_USB_BUS_SENSE_IO" definition has been commented out, then
1223:                      the USB stack assumes that it should always enable the USB module at
1224:                      pretty much all times.  Basically, anytime the application firmware
1225:                      calls USBDeviceTasks(), the firmware will automatically enable the USB
1226:                      module.  This mode would typically be selected if the application was
1227:                      designed to be a purely bus powered device.  In this case, the
1228:                      application is powered from the +5V VBUS supply from the USB port, so
1229:                      it is correct and sensible in this type of application to power up and
1230:                      turn on the USB module, at anytime that the microcontroller is
1231:                      powered (which implies the USB cable is attached and the host is also
1232:                      powered).
1233:              
1234:                      In a self powered application, the USB stack is designed with the
1235:                      intention that the user will enable the "#define USE_USB_BUS_SENSE_IO"
1236:                      option in the HardwareProfile  [platform name].h file.  When this
1237:                      option is defined, then the USBDeviceTasks() function will automatically
1238:                      check the I/O pin port value of the designated pin (based on the
1239:                      #define USB_BUS_SENSE option in the HardwareProfile  [platform name].h
1240:                      file), every time the application calls USBDeviceTasks().  If the
1241:                      USBDeviceTasks() function is executed and finds that the pin defined by
1242:                      the #define USB_BUS_SENSE is in a logic low state, then it will
1243:                      automatically disable the USB module and tri-state the D+ and D- pins.
1244:                      If however the USBDeviceTasks() function is executed and finds the pin
1245:                      defined by the #define USB_BUS_SENSE is in a logic high state, then it
1246:                      will automatically enable the USB module, if it has not already been
1247:                      enabled.
1248:              
1249:                **************************************************************************/
1250:              #if defined(USB_INTERRUPT)
1251:              void USBDeviceDetach(void)
1252:              {
1253:                  //If the interrupt option is selected then the customer is required
1254:                  //  to notify the stack when the device is attached or removed from the
1255:                  //  bus by calling the USBDeviceAttach() and USBDeviceDetach() functions.
1256:              #ifdef USB_SUPPORT_OTG
1257:                  if (USB_BUS_SENSE != 1)
1258:              #endif
1259:                  {
1260:                       // Disable module & detach from bus
1261:                       U1CON = 0;
1262:              
1263:                       // Mask all USB interrupts
1264:                       U1IE = 0;
1265:              
1266:                       //Move to the detached state
1267:                       USBDeviceState = DETACHED_STATE;
1268:              
1269:                       #ifdef  USB_SUPPORT_OTG
1270:                           //Disable D+ Pull-up
1271:                           U1OTGCONbits.DPPULUP = 0;
1272:              
1273:                           //Disable HNP
1274:                           USBOTGDisableHnp();
1275:              
1276:                           //Deactivate HNP
1277:                           USBOTGDeactivateHnp();
1278:              
1279:                           //If ID Pin Changed State
1280:                           if (USBIDIF && USBIDIE)
1281:                           {
1282:                               //Re-detect & Initialize
1283:                                USBOTGInitialize();
1284:              
1285:                                //Clear ID Interrupt Flag
1286:                                USBClearInterruptFlag(USBIDIFReg,USBIDIFBitNum);
1287:                           }
1288:                       #endif
1289:              
1290:                       #if defined __C30__ || defined __XC16__
1291:                           //USBClearInterruptFlag(U1OTGIR, 3);
1292:                       #endif
1293:                          //return so that we don't go through the rest of
1294:                          //the state machine
1295:                        return;
1296:                  }
1297:              
1298:              #ifdef USB_SUPPORT_OTG
1299:                  //If Session Is Started Then
1300:                 else
1301:                 {
1302:                      //If SRP Is Ready
1303:                      if (USBOTGSRPIsReady())
1304:                      {
1305:                          //Clear SRPReady
1306:                          USBOTGClearSRPReady();
1307:              
1308:                          //Clear SRP Timeout Flag
1309:                          USBOTGClearSRPTimeOutFlag();
1310:              
1311:                          //Indicate Session Started
1312:                          UART2PrintString( "\r\n***** USB OTG B Event - Session Started  *****\r\n" );
1313:                      }
1314:                  }
1315:              #endif
1316:              }
1317:              #endif  //#if defined(USB_INTERRUPT)
1318:              /**************************************************************************
1319:                  Function:
1320:                      void USBDeviceAttach(void)
1321:              
1322:                  Summary:
1323:                      Checks if VBUS is present, and that the USB module is not already
1324:                      initialized, and if so, enables the USB module so as to signal device
1325:                      attachment to the USB host.
1326:              
1327:                  Description:
1328:                      This function indicates to the USB host that the USB device has been
1329:                      attached to the bus.  This function needs to be called in order for the
1330:                      device to start to enumerate on the bus.
1331:              
1332:                  Precondition:
1333:                      Should only be called when USB_INTERRUPT is defined.  Also, should only
1334:                      be called from the main() loop context.  Do not call USBDeviceAttach()
1335:                      from within an interrupt handler, as the USBDeviceAttach() function
1336:                      may modify global interrupt enable bits and settings.
1337:              
1338:                      For normal USB devices:
1339:                      Make sure that if the module was previously on, that it has been turned off
1340:                      for a long time (ex: 100ms+) before calling this function to re-enable the module.
1341:                      If the device turns off the D+ (for full speed) or D- (for low speed) ~1.5k ohm
1342:                      pull up resistor, and then turns it back on very quickly, common hosts will sometimes
1343:                      reject this event, since no human could ever unplug and re-attach a USB device in a
1344:                      microseconds (or nanoseconds) timescale.  The host could simply treat this as some kind
1345:                      of glitch and ignore the event altogether.
1346:                  Parameters:
1347:                      None
1348:              
1349:                  Return Values:
1350:                      None
1351:              
1352:                  Remarks:
1353:              		See also the USBDeviceDetach() API function documentation.
1354:              ****************************************************************************/
1355:              #if defined(USB_INTERRUPT)
1356:              void USBDeviceAttach(void)
1357:              {
1358:                  //if we are in the detached state
1359:                  if(USBDeviceState == DETACHED_STATE)
1360:                  {
1361:                      if(USB_BUS_SENSE == 1)
1362:                      {
1363:                  	    //Initialize registers to known states.
1364:                          U1CON = 0;
1365:              
1366:                          // Mask all USB interrupts
1367:                          U1IE = 0;
1368:              
1369:                          //Configure things like: pull ups, full/low-speed mode,
1370:                          //set the ping pong mode, and set internal transceiver
1371:                          SetConfigurationOptions();
1372:              
1373:                          USBEnableInterrupts();  //Modifies global interrupt settings
1374:              
1375:                          // Enable module & attach to bus
1376:                          while(!U1CONbits.USBEN){U1CONbits.USBEN = 1;}
1377:              
1378:                          //moved to the attached state
1379:                          USBDeviceState = ATTACHED_STATE;
1380:              
1381:                          #ifdef  USB_SUPPORT_OTG
1382:                              U1OTGCON = USB_OTG_DPLUS_ENABLE | USB_OTG_ENABLE;
1383:                          #endif
1384:                      }
1385:                  }
1386:              }
1387:              #endif  //#if defined(USB_INTERRUPT)
1388:              
1389:              
1390:              /*******************************************************************************
1391:                Function: void USBCtrlEPAllowStatusStage(void);
1392:              
1393:                Summary: This function prepares the proper endpoint 0 IN or endpoint 0 OUT
1394:                          (based on the controlTransferState) to allow the status stage packet
1395:                          of a control transfer to complete.  This function gets used
1396:                          internally by the USB stack itself, but it may also be called from
1397:                          the application firmware, IF the application firmware called
1398:                          the USBDeferStatusStage() function during the initial processing
1399:                          of the control transfer request.  In this case, the application
1400:                          must call the USBCtrlEPAllowStatusStage() once, after it has fully
1401:                          completed processing and handling the data stage portion of the
1402:                          request.
1403:              
1404:                          If the application firmware has no need for delaying control
1405:                          transfers, and therefore never calls USBDeferStatusStage(), then the
1406:                          application firmware should not call USBCtrlEPAllowStatusStage().
1407:              
1408:                Description:
1409:              
1410:                Conditions:
1411:                  None
1412:              
1413:                Input:
1414:              
1415:                Return:
1416:              
1417:                Remarks:
1418:                  None
1419:                *****************************************************************************/
1420:              void USBCtrlEPAllowStatusStage(void)
1421:              {
1422:                  //Check and set two flags, prior to actually modifying any BDT entries.
1423:                  //This double checking is necessary to make certain that
1424:                  //USBCtrlEPAllowStatusStage() can be called twice simultaneously (ex: once
1425:                  //in main loop context, while simultaneously getting an interrupt which
1426:                  //tries to call USBCtrlEPAllowStatusStage() again, at the same time).
1427:                  if(USBStatusStageEnabledFlag1 == false)
006C6C  E24F9E     CP0.B USBStatusStageEnabledFlag1
006C6E  3A002A     BRA NZ, .L99
1428:                  {
1429:                      USBStatusStageEnabledFlag1 = true;
006C70  B3C010     MOV.B #0x1, W0
006C72  B7EF9E     MOV.B WREG, USBStatusStageEnabledFlag1
1430:                      if(USBStatusStageEnabledFlag2 == false)
006C74  E24F9F     CP0.B USBStatusStageEnabledFlag2
006C76  3A0026     BRA NZ, .L99
1431:                      {
1432:                          USBStatusStageEnabledFlag2 = true;
006C78  B7EF9F     MOV.B WREG, USBStatusStageEnabledFlag2
1433:              
1434:                          //Determine which endpoints (EP0 IN or OUT needs arming for the status
1435:                          //stage), based on the type of control transfer currently pending.
1436:                          if(controlTransferState == CTRL_TRF_RX)
006C7A  BFCF97     MOV.B controlTransferState, WREG
006C7C  504FE2     SUB.B W0, #0x2, [W15]
006C7E  3A000A     BRA NZ, .L101
1437:                          {
1438:                              pBDTEntryIn[0]->CNT = 0;
006C80  807C60     MOV pBDTEntryIn, W0
006C82  EB4800     CLR.B [W0]
1439:                              pBDTEntryIn[0]->STAT.Val = _DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);
006C84  B3C481     MOV.B #0x48, W1
006C86  807C60     MOV pBDTEntryIn, W0
006C88  984011     MOV.B W1, [W0+1]
1440:                              pBDTEntryIn[0]->STAT.Val |= _USIE;
006C8A  807C60     MOV pBDTEntryIn, W0
006C8C  904090     MOV.B [W0+1], W1
006C8E  A07401     BSET.B W1, #7
006C90  984011     MOV.B W1, [W0+1]
006C92  370018     BRA .L99
1441:                          }
1442:                          else if(controlTransferState == CTRL_TRF_TX)
006C94  504FE1     SUB.B W0, #0x1, [W15]
006C96  3A0016     BRA NZ, .L99
1443:                          {
1444:                              BothEP0OutUOWNsSet = false;	//Indicator flag used in USBCtrlTrfOutHandler()
006C98  EF6F9C     CLR.B BothEP0OutUOWNsSet
1445:              
1446:                              //This buffer (when ping pong buffering is enabled on EP0 OUT) receives the
1447:                              //next SETUP packet.
1448:                              #if((USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG))
1449:                                  pBDTEntryEP0OutCurrent->CNT = USB_EP0_BUFF_SIZE;
006C9A  B3C080     MOV.B #0x8, W0
006C9C  807C91     MOV pBDTEntryEP0OutCurrent, W1
006C9E  784880     MOV.B W0, [W1]
1450:                                  pBDTEntryEP0OutCurrent->ADR = ConvertToPhysicalAddress(&SetupPkt);
006CA0  807C92     MOV pBDTEntryEP0OutCurrent, W2
006CA2  20A321     MOV #0xA32, W1
006CA4  980111     MOV W1, [W2+2]
1451:                                  pBDTEntryEP0OutCurrent->STAT.Val = _BSTALL; //Prepare endpoint to accept a SETUP transaction
006CA6  B3C043     MOV.B #0x4, W3
006CA8  984113     MOV.B W3, [W2+1]
1452:                                  pBDTEntryEP0OutCurrent->STAT.Val |= _USIE;
006CAA  807C92     MOV pBDTEntryEP0OutCurrent, W2
006CAC  904192     MOV.B [W2+1], W3
006CAE  A07403     BSET.B W3, #7
006CB0  984113     MOV.B W3, [W2+1]
1453:                                  BothEP0OutUOWNsSet = true;	//Indicator flag used in USBCtrlTrfOutHandler()
006CB2  B3C014     MOV.B #0x1, W4
006CB4  20F9C3     MOV #0xF9C, W3
006CB6  784984     MOV.B W4, [W3]
1454:                              #endif
1455:              
1456:                              //This EP0 OUT buffer receives the 0-byte OUT status stage packet.
1457:                              pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
006CB8  807CA2     MOV pBDTEntryEP0OutNext, W2
006CBA  784900     MOV.B W0, [W2]
1458:                              pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
006CBC  807CA0     MOV pBDTEntryEP0OutNext, W0
006CBE  980011     MOV W1, [W0+2]
1459:                              pBDTEntryEP0OutNext->STAT.Val = _USIE;           // Note: DTSEN is 0
006CC0  B3C801     MOV.B #0x80, W1
006CC2  984011     MOV.B W1, [W0+1]
1460:                          }
1461:                      }
1462:                  }
1463:              }
006CC4  060000     RETURN
1464:              
1465:              
1466:              /*******************************************************************************
1467:                Function: void USBCtrlEPAllowDataStage(void);
1468:              
1469:                Summary: This function allows the data stage of either a host-to-device or
1470:                          device-to-host control transfer (with data stage) to complete.
1471:                          This function is meant to be used in conjunction with either the
1472:                          USBDeferOUTDataStage() or USBDeferINDataStage().  If the firmware
1473:                          does not call either USBDeferOUTDataStage() or USBDeferINDataStage(),
1474:                          then the firmware does not need to manually call
1475:                          USBCtrlEPAllowDataStage(), as the USB stack will call this function
1476:                          instead.
1477:              
1478:                Description:
1479:              
1480:                Conditions: A control transfer (with data stage) should already be pending,
1481:                              if the firmware calls this function.  Additionally, the firmware
1482:                              should have called either USBDeferOUTDataStage() or
1483:                              USBDeferINDataStage() at the start of the control transfer, if
1484:                              the firmware will be calling this function manually.
1485:              
1486:                Input:
1487:              
1488:                Return:
1489:              
1490:                Remarks:
1491:                *****************************************************************************/
1492:              void USBCtrlEPAllowDataStage(void)
1493:              {
1494:                  USBDeferINDataStagePackets = false;
006DAA  EF6F80     CLR.B USBDeferINDataStagePackets
1495:                  USBDeferOUTDataStagePackets = false;
006DAC  EF6F7E     CLR.B USBDeferOUTDataStagePackets
1496:              
1497:                  if(controlTransferState == CTRL_TRF_RX) //(<setup><out><out>...<out><in>)
006DAE  BFCF97     MOV.B controlTransferState, WREG
006DB0  504FE2     SUB.B W0, #0x2, [W15]
006DB2  3A000D     BRA NZ, .L116
1498:                  {
1499:                      //Prepare EP0 OUT to receive the first OUT data packet in the data stage sequence.
1500:                      pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
006DB4  B3C081     MOV.B #0x8, W1
006DB6  807CA0     MOV pBDTEntryEP0OutNext, W0
006DB8  784801     MOV.B W1, [W0]
1501:                      pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&CtrlTrfData);
006DBA  807CA0     MOV pBDTEntryEP0OutNext, W0
006DBC  20A3A1     MOV #0xA3A, W1
006DBE  980011     MOV W1, [W0+2]
1502:                      pBDTEntryEP0OutNext->STAT.Val = _DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);
006DC0  B3C481     MOV.B #0x48, W1
006DC2  984011     MOV.B W1, [W0+1]
1503:                      pBDTEntryEP0OutNext->STAT.Val |= _USIE;
006DC4  807CA0     MOV pBDTEntryEP0OutNext, W0
006DC6  904090     MOV.B [W0+1], W1
006DC8  A07401     BSET.B W1, #7
006DCA  984011     MOV.B W1, [W0+1]
006DCC  37001B     BRA .L115
1504:                  }
1505:                  else    //else must be controlTransferState == CTRL_TRF_TX (<setup><in><in>...<in><out>)
1506:                  {
1507:                      //Error check the data stage byte count.  Make sure the user specified
1508:                      //value was no greater than the number of bytes the host requested.
1509:              		if(SetupPkt.wLength < inPipes[0].wCount.Val)
006DCE  20A380     MOV #0xA38, W0
006DD0  FB8010     ZE [W0], W0
006DD2  20A391     MOV #0xA39, W1
006DD4  FB8091     ZE [W1], W1
006DD6  DD08C8     SL W1, #8, W1
006DD8  700081     IOR W0, W1, W1
006DDA  20A240     MOV #0xA24, W0
006DDC  508F90     SUB W1, [W0], [W15]
006DDE  310007     BRA C, .L118
1510:              		{
1511:              			inPipes[0].wCount.Val = SetupPkt.wLength;
006DE0  20A380     MOV #0xA38, W0
006DE2  FB8090     ZE [W0], W1
006DE4  E80000     INC W0, W0
006DE6  FB8110     ZE [W0], W2
006DE8  DD1148     SL W2, #8, W2
006DEA  20A240     MOV #0xA24, W0
006DEC  710801     IOR W2, W1, [W0]
1512:              		}
1513:              		USBCtrlTrfTxService();  //Copies one IN data packet worth of data from application buffer
006DEE  07FC19     RCALL _USBCtrlTrfTxService, .LFE8, .LFB10
1514:              		                        //to CtrlTrfData buffer.  Also keeps track of how many bytes remaining.
1515:              
1516:              	    //Cnt should have been initialized by responsible request owner (ex: by
1517:              	    //using the USBEP0SendRAMPtr() or USBEP0SendROMPtr() API function).
1518:              		pBDTEntryIn[0]->ADR = ConvertToPhysicalAddress(&CtrlTrfData);
006DF0  20A3A1     MOV #0xA3A, W1
006DF2  807C60     MOV pBDTEntryIn, W0
006DF4  980011     MOV W1, [W0+2]
1519:              		pBDTEntryIn[0]->STAT.Val = _DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);
006DF6  B3C481     MOV.B #0x48, W1
006DF8  807C60     MOV pBDTEntryIn, W0
006DFA  984011     MOV.B W1, [W0+1]
1520:                      pBDTEntryIn[0]->STAT.Val |= _USIE;
006DFC  807C60     MOV pBDTEntryIn, W0
006DFE  904090     MOV.B [W0+1], W1
006E00  A07401     BSET.B W1, #7
006E02  984011     MOV.B W1, [W0+1]
1521:                  }
1522:              }
006E04  060000     RETURN
1523:              
1524:              
1525:              /******************************************************************************/
1526:              /** Internal Functions *********************************************************/
1527:              /******************************************************************************/
1528:              
1529:              /********************************************************************
1530:               * Function:        void USBConfigureEndpoint(uint8_t EPNum, uint8_t direction)
1531:               *
1532:               * PreCondition:    None
1533:               *
1534:               * Input:           uint8_t EPNum - the endpoint to be configured
1535:               *                  uint8_t direction - the direction to be configured
1536:               *                                   (either OUT_FROM_HOST or IN_TO_HOST)
1537:               *
1538:               * Output:          None
1539:               *
1540:               * Side Effects:    None
1541:               *
1542:               * Overview:        This function will configure the specified
1543:               *                  endpoint
1544:               *
1545:               * Note:            None
1546:               *******************************************************************/
1547:              static void USBConfigureEndpoint(uint8_t EPNum, uint8_t direction)
1548:              {
1549:                  volatile BDT_ENTRY* handle;
1550:              
1551:                  //Compute a pointer to the even BDT entry corresponding to the
1552:                  //EPNum and direction values passed to this function.
1553:                  handle = (volatile BDT_ENTRY*)&BDT[EP0_OUT_EVEN]; //Get address of start of BDT
1554:                  handle += EP(EPNum,direction,0u);     //Add in offset to the BDT of interest
0065F8  FB8000     ZE W0, W0
0065FA  FB8181     ZE W1, W3
0065FC  400100     ADD W0, W0, W2
0065FE  418102     ADD W3, W2, W2
006600  DD1143     SL W2, #3, W2
006602  20A003     MOV #0xA00, W3
006604  410103     ADD W2, W3, W2
1555:              
1556:                  handle->STAT.UOWN = 0;  //mostly redundant, since USBStdSetCfgHandler()
006606  A1F012     BCLR [W2], #15
1557:                  //already cleared the entire BDT table
1558:              
1559:                  //Make sure our pBDTEntryIn/Out[] pointer is initialized.  Needed later
1560:                  //for USBTransferOnePacket() API calls.
1561:                  if(direction == OUT_FROM_HOST)
006608  E00401     CP0.B W1
00660A  3A0004     BRA NZ, .L2
1562:                  {
1563:                      pBDTEntryOut[EPNum] = handle;
00660C  400000     ADD W0, W0, W0
00660E  20F881     MOV #0xF88, W1
006610  783082     MOV W2, [W1+W0]
006612  370003     BRA .L3
1564:                  }
1565:                  else
1566:                  {
1567:                      pBDTEntryIn[EPNum] = handle;
006614  400000     ADD W0, W0, W0
006616  20F8C1     MOV #0xF8C, W1
006618  783082     MOV W2, [W1+W0]
1568:                  }
1569:              
1570:                  #if (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)
1571:                      handle->STAT.DTS = 0;
00661A  A1E012     BCLR [W2], #14
1572:                      (handle+1)->STAT.DTS = 1;
00661C  410164     ADD W2, #0x4, W2
00661E  A0E012     BSET [W2], #14
1573:                  #elif (USB_PING_PONG_MODE == USB_PING_PONG__NO_PING_PONG)
1574:                      //Set DTS to one because the first thing we will do
1575:                      //when transmitting is toggle the bit
1576:                      handle->STAT.DTS = 1;
1577:                  #elif (USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY)
1578:                      if(EPNum != 0)
1579:                      {
1580:                          handle->STAT.DTS = 1;
1581:                      }
1582:                  #elif (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0)
1583:                      if(EPNum != 0)
1584:                      {
1585:                          handle->STAT.DTS = 0;
1586:                          (handle+1)->STAT.DTS = 1;
1587:                      }
1588:                  #endif
1589:              }
006620  060000     RETURN
1590:              
1591:              
1592:              /******************************************************************************
1593:               * Function:        void USBCtrlEPServiceComplete(void)
1594:               *
1595:               * PreCondition:    None
1596:               *
1597:               * Input:           None
1598:               *
1599:               * Output:          None
1600:               *
1601:               * Side Effects:    None
1602:               *
1603:               * Overview:        This routine wrap up the remaining tasks in servicing
1604:               *                  a Setup Request. Its main task is to set the endpoint
1605:               *                  controls appropriately for a given situation. See code
1606:               *                  below.
1607:               *                  There are three main scenarios:
1608:               *                  a) There was no handler for the Request, in this case
1609:               *                     a STALL should be sent out.
1610:               *                  b) The host has requested a read control transfer,
1611:               *                     endpoints are required to be setup in a specific way.
1612:               *                  c) The host has requested a write control transfer, or
1613:               *                     a control data stage is not required, endpoints are
1614:               *                     required to be setup in a specific way.
1615:               *
1616:               *                  Packet processing is resumed by clearing PKTDIS bit.
1617:               *
1618:               * Note:            None
1619:               *****************************************************************************/
1620:              static void USBCtrlEPServiceComplete(void)
1621:              {
1622:                  /*
1623:                   * PKTDIS bit is set when a Setup Transaction is received.
1624:                   * Clear to resume packet processing.
1625:                   */
1626:                  USBPacketDisable = 0;
006E06  A9A494     BCLR U1CON, #5
1627:              
1628:              	//Check the busy bits and the SetupPtk.DataDir variables to determine what type of
1629:              	//control transfer is currently in progress.  We need to know the type of control
1630:              	//transfer that is currently pending, in order to know how to properly arm the
1631:              	//EP0 IN and EP0 OUT endpoints.
1632:                  if(inPipes[0].info.bits.busy == 0)
006E08  200800     MOV #0x80, W0
006E0A  20A221     MOV #0xA22, W1
006E0C  600011     AND W0, [W1], W0
006E0E  3A001F     BRA NZ, .L120
1633:                  {
1634:                      if(outPipes[0].info.bits.busy == 1)
006E10  20A280     MOV #0xA28, W0
006E12  E00410     CP0.B [W0]
006E14  3D0008     BRA GE, .L121
1635:                      {
1636:                          controlTransferState = CTRL_TRF_RX;
006E16  B3C020     MOV.B #0x2, W0
006E18  B7EF97     MOV.B WREG, controlTransferState
1637:                          /*
1638:                           * Control Write:
1639:                           * <SETUP[0]><OUT[1]><OUT[0]>...<IN[1]> | <SETUP[0]>
1640:                           */
1641:              
1642:                          //1. Prepare OUT EP to receive data, unless a USB class request handler
1643:                          //   function decided to defer the data stage (ex: because the intended
1644:                          //   RAM buffer wasn't available yet) by calling USBDeferDataStage().
1645:                          //   If it did so, it is then responsible for calling USBCtrlEPAllowDataStage(),
1646:                          //   once it is ready to begin receiving the data.
1647:                          if(USBDeferOUTDataStagePackets == false)
006E1A  E24F7E     CP0.B USBDeferOUTDataStagePackets
006E1C  3A0001     BRA NZ, .L122
1648:                          {
1649:                              USBCtrlEPAllowDataStage();
006E1E  07FFC5     RCALL USBCtrlEPAllowDataStage
1650:                          }
1651:              
1652:                          //2.  IN endpoint 0 status stage will be armed by USBCtrlEPAllowStatusStage()
1653:                          //after all of the OUT data has been received and consumed, or if a timeout occurs.
1654:                          USBStatusStageEnabledFlag2 = false;
006E20  EF6F9F     CLR.B USBStatusStageEnabledFlag2
1655:                          USBStatusStageEnabledFlag1 = false;
006E22  EF6F9E     CLR.B USBStatusStageEnabledFlag1
006E24  370035     BRA .L119
1656:                      }
1657:                      else
1658:                      {
1659:                          /*
1660:                           * If no one knows how to service this request then stall.
1661:                           * Must also prepare EP0 to receive the next SETUP transaction.
1662:                           */
1663:                          pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
006E26  B3C081     MOV.B #0x8, W1
006E28  807CA0     MOV pBDTEntryEP0OutNext, W0
006E2A  784801     MOV.B W1, [W0]
1664:                          pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
006E2C  807CA0     MOV pBDTEntryEP0OutNext, W0
006E2E  20A321     MOV #0xA32, W1
006E30  980011     MOV W1, [W0+2]
1665:                          pBDTEntryEP0OutNext->STAT.Val = _DAT0|(_DTSEN & _DTS_CHECKING_ENABLED)|_BSTALL;
006E32  B3C0C1     MOV.B #0xC, W1
006E34  984011     MOV.B W1, [W0+1]
1666:                          pBDTEntryEP0OutNext->STAT.Val |= _USIE;
006E36  807CA0     MOV pBDTEntryEP0OutNext, W0
006E38  904090     MOV.B [W0+1], W1
006E3A  A07401     BSET.B W1, #7
006E3C  984011     MOV.B W1, [W0+1]
1667:                          pBDTEntryIn[0]->STAT.Val = _BSTALL;
006E3E  B3C041     MOV.B #0x4, W1
006E40  807C60     MOV pBDTEntryIn, W0
006E42  984011     MOV.B W1, [W0+1]
1668:                          pBDTEntryIn[0]->STAT.Val |= _USIE;
006E44  807C60     MOV pBDTEntryIn, W0
006E46  904090     MOV.B [W0+1], W1
006E48  A07401     BSET.B W1, #7
006E4A  984011     MOV.B W1, [W0+1]
006E4C  370021     BRA .L119
1669:                      }
1670:                  }
1671:                  else    // A module has claimed ownership of the control transfer session.
1672:                  {
1673:              		if(SetupPkt.DataDir == USB_SETUP_DEVICE_TO_HOST_BITFIELD)
006E4E  20A320     MOV #0xA32, W0
006E50  E00410     CP0.B [W0]
006E52  3D000B     BRA GE, .L124
1674:              		{
1675:              			controlTransferState = CTRL_TRF_TX;
006E54  B3C010     MOV.B #0x1, W0
006E56  B7EF97     MOV.B WREG, controlTransferState
1676:              			/*
1677:              			 * Control Read:
1678:              			 * <SETUP[0]><IN[1]><IN[0]>...<OUT[1]> | <SETUP[0]>
1679:              			 *
1680:              			 * 1. Prepare IN EP to transfer data to the host.  If however the data
1681:              			 *    wasn't ready yet (ex: because the firmware needs to go and read it from
1682:              			 *    some slow/currently unavailable resource, such as an external I2C EEPconst),
1683:              			 *    Then the class request handler responsible should call the USBDeferDataStage()
1684:              			 *    macro.  In this case, the firmware may wait up to 500ms, before it is required
1685:              			 *    to transmit the first IN data packet.  Once the data is ready, and the firmware
1686:              			 *    is ready to begin sending the data, it should then call the
1687:              			 *    USBCtrlEPAllowDataStage() function to start the data stage.
1688:              			 */
1689:              			if(USBDeferINDataStagePackets == false)
006E58  E24F80     CP0.B USBDeferINDataStagePackets
006E5A  3A0001     BRA NZ, .L125
1690:                          {
1691:                              USBCtrlEPAllowDataStage();
006E5C  07FFA6     RCALL USBCtrlEPAllowDataStage
1692:              			}
1693:              
1694:                          // 2. (Optionally) allow the status stage now, to prepare for early termination.
1695:                          //    Note: If a class request handler decided to set USBDeferStatusStagePacket == true,
1696:                          //    then it is responsible for eventually calling USBCtrlEPAllowStatusStage() once it
1697:                          //    is ready.  If the class request handler does this, it needs to be careful to
1698:                          //    be written so that it can handle the early termination scenario.
1699:                          //    Ex: It should call USBCtrlEPAllowStatusStage() when any of the following occurs:
1700:                          //    1.  The desired total number of bytes were sent to the host.
1701:                          //    2.  The number of bytes that the host originally requested (in the SETUP packet that
1702:                          //        started the control transfer) has been reached.
1703:                          //    3.  Or, if a timeout occurs (ex: <50ms since the last successful EP0 IN transaction), regardless
1704:                          //        of how many bytes have actually been sent.  This is necessary to prevent a deadlock situation
1705:                          //        (where the control transfer can't complete, due to continuous NAK on status stage) if the
1706:                          //        host performs early termination.  If enabled, the USB_ENABLE_STATUS_STAGE_TIMEOUTS usb_config.h
1707:                          //        option can take care of this for you.
1708:                          //    Note: For this type of control transfer, there is normally no harm in simply arming the
1709:                          //    status stage packet right now, even if the IN data is not ready yet.  This allows for
1710:                          //    immediate early termination, without adding unnecessary delay.  Therefore, it is generally not
1711:                          //    recommended for the USB class handler firmware to call USBDeferStatusStage(), for this
1712:                          //    type of control transfer.  If the USB class handler firmware needs more time to fetch the IN
1713:                          //    data that needs to be sent to the host, it should instead use the USBDeferDataStage() function.
1714:                          USBStatusStageEnabledFlag2 = false;
006E5E  EF6F9F     CLR.B USBStatusStageEnabledFlag2
1715:                          USBStatusStageEnabledFlag1 = false;
006E60  EF6F9E     CLR.B USBStatusStageEnabledFlag1
1716:                          if(USBDeferStatusStagePacket == false)
006E62  E24F7F     CP0.B USBDeferStatusStagePacket
006E64  3A0015     BRA NZ, .L119
1717:                          {
1718:                              USBCtrlEPAllowStatusStage();
006E66  07FF02     RCALL USBCtrlEPAllowStatusStage
006E68  370013     BRA .L119
1719:                          }
1720:              		}
1721:              		else   // (SetupPkt.DataDir == USB_SETUP_DIRECTION_HOST_TO_DEVICE)
1722:              		{
1723:              			//This situation occurs for special types of control transfers,
1724:              			//such as that which occurs when the host sends a SET_ADDRESS
1725:              			//control transfer.  Ex:
1726:              			//
1727:              			//<SETUP[0]><IN[1]> | <SETUP[0]>
1728:              
1729:              			//Although the data direction is HOST_TO_DEVICE, there is no data stage
1730:              			//(hence: outPipes[0].info.bits.busy == 0).  There is however still
1731:              			//an IN status stage.
1732:              
1733:              			controlTransferState = CTRL_TRF_RX;     //Since this is a HOST_TO_DEVICE control transfer
006E6A  B3C020     MOV.B #0x2, W0
006E6C  B7EF97     MOV.B WREG, controlTransferState
1734:              
1735:              			//1. Prepare OUT EP to receive the next SETUP packet.
1736:              			pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
006E6E  B3C081     MOV.B #0x8, W1
006E70  807CA0     MOV pBDTEntryEP0OutNext, W0
006E72  784801     MOV.B W1, [W0]
1737:              			pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
006E74  807CA0     MOV pBDTEntryEP0OutNext, W0
006E76  20A321     MOV #0xA32, W1
006E78  980011     MOV W1, [W0+2]
1738:              			pBDTEntryEP0OutNext->STAT.Val = _BSTALL;
006E7A  B3C041     MOV.B #0x4, W1
006E7C  984011     MOV.B W1, [W0+1]
1739:                          pBDTEntryEP0OutNext->STAT.Val |= _USIE;
006E7E  807CA0     MOV pBDTEntryEP0OutNext, W0
006E80  904090     MOV.B [W0+1], W1
006E82  A07401     BSET.B W1, #7
006E84  984011     MOV.B W1, [W0+1]
1740:              
1741:              			//2. Prepare for IN status stage of the control transfer
1742:                          USBStatusStageEnabledFlag2 = false;
006E86  EF6F9F     CLR.B USBStatusStageEnabledFlag2
1743:                          USBStatusStageEnabledFlag1 = false;
006E88  EF6F9E     CLR.B USBStatusStageEnabledFlag1
1744:              			if(USBDeferStatusStagePacket == false)
006E8A  E24F7F     CP0.B USBDeferStatusStagePacket
006E8C  3A0001     BRA NZ, .L119
1745:                          {
1746:                              USBCtrlEPAllowStatusStage();
006E8E  07FEEE     RCALL USBCtrlEPAllowStatusStage
1747:                          }
1748:              		}
1749:              
1750:                  }//end if(ctrl_trf_session_owner == MUID_NULL)
1751:              
1752:              }//end USBCtrlEPServiceComplete
006E90  060000     RETURN
1753:              
1754:              
1755:              /******************************************************************************
1756:               * Function:        void USBCtrlTrfTxService(void)
1757:               *
1758:               * PreCondition:    pSrc, wCount, and usb_stat.ctrl_trf_mem are setup properly.
1759:               *
1760:               * Input:           None
1761:               *
1762:               * Output:          None
1763:               *
1764:               * Side Effects:    None
1765:               *
1766:               * Overview:        This routine is used for device to host control transfers
1767:               *					(IN transactions).  This function takes care of managing a
1768:               *                  transfer over multiple USB transactions.
1769:               *					This routine should be called from only two places.
1770:               *                  One from USBCtrlEPServiceComplete() and one from
1771:               *                  USBCtrlTrfInHandler().
1772:               *
1773:               * Note:
1774:               *****************************************************************************/
1775:              static void USBCtrlTrfTxService(void)
1776:              {
1777:                  uint8_t byteToSend;
1778:              
1779:                  //Figure out how many bytes of data to send in the next IN transaction.
1780:                  //Assume a full size packet, unless otherwise determined below.
1781:                  byteToSend = USB_EP0_BUFF_SIZE;
006624  B3C080     MOV.B #0x8, W0
1782:                  if(inPipes[0].wCount.Val < (uint8_t)USB_EP0_BUFF_SIZE)
006622  805121     MOV 0xA24, W1
006626  508FE7     SUB W1, #0x7, [W15]
006628  3E000E     BRA GTU, .L5
1783:                  {
1784:                      byteToSend = inPipes[0].wCount.Val;
00662A  784001     MOV.B W1, W0
1785:              
1786:                      //Keep track of whether or not we have sent a "short packet" yet.
1787:                      //This is useful so that later on, we can configure EP0 IN to STALL,
1788:                      //after we have sent all of the intended data.  This makes sure the
1789:                      //hardware STALLs if the host erroneously tries to send more IN token
1790:                      //packets, requesting more data than intended in the control transfer.
1791:                      if(shortPacketStatus == SHORT_PKT_NOT_USED)
00662C  20F961     MOV #0xF96, W1
00662E  784091     MOV.B [W1], W1
006630  E00401     CP0.B W1
006632  3A0004     BRA NZ, .L6
1792:                      {
1793:                          shortPacketStatus = SHORT_PKT_PENDING;
006634  B3C013     MOV.B #0x1, W3
006636  20F962     MOV #0xF96, W2
006638  784903     MOV.B W3, [W2]
00663A  370005     BRA .L5
1794:                      }
1795:                      else if(shortPacketStatus == SHORT_PKT_PENDING)
00663C  50CFE1     SUB.B W1, #0x1, [W15]
00663E  3A0003     BRA NZ, .L5
1796:                      {
1797:                          shortPacketStatus = SHORT_PKT_SENT;
006640  B3C023     MOV.B #0x2, W3
006642  20F962     MOV #0xF96, W2
006644  784903     MOV.B W3, [W2]
1798:                      }
1799:                  }
1800:              
1801:                  //Keep track of how many bytes remain to be sent in the transfer, by
1802:                  //subtracting the number of bytes about to be sent from the total.
1803:                  inPipes[0].wCount.Val -= byteToSend;
006646  20A241     MOV #0xA24, W1
006648  FB8100     ZE W0, W2
00664A  110891     SUBR W2, [W1], [W1]
1804:              
1805:                  //Next, load the number of bytes to send to BC7..0 in buffer descriptor.
1806:                  //Note: Control endpoints may never have a max packet size of > 64 bytes.
1807:                  //Therefore, the BC8 and BC9 bits should always be maintained clear.
1808:                  pBDTEntryIn[0]->CNT = byteToSend;
00664C  807C61     MOV pBDTEntryIn, W1
00664E  784880     MOV.B W0, [W1]
1809:              
1810:                  //Now copy the data from the source location, to the CtrlTrfData[] buffer,
1811:                  //which we will send to the host.
1812:                  pDst = (USB_VOLATILE uint8_t*)CtrlTrfData;                // Set destination pointer
006650  20A3A1     MOV #0xA3A, W1
006652  887CC1     MOV W1, pDst
1813:                  if(inPipes[0].info.bits.ctrl_trf_mem == USB_EP0_ROM)   // Determine type of memory source
006654  20A221     MOV #0xA22, W1
006656  780091     MOV [W1], W1
006658  6080E1     AND W1, #0x1, W1
00665A  320004     BRA Z, .L7
1814:                  {
1815:                      while(byteToSend)
006664  E00400     CP0.B W0
006666  320010     BRA Z, .L4
006676  3AFFF9     BRA NZ, .L12
006678  370007     BRA .L4
1816:                      {
1817:                          *pDst++ = *inPipes[0].pSrc.bRom++;
006668  20A203     MOV #0xA20, W3
00666A  780113     MOV [W3], W2
00666C  807CC1     MOV pDst, W1
00666E  785892     MOV.B [W2], [W1++]
006670  887CC1     MOV W1, pDst
006672  E80982     INC W2, [W3]
1818:                          byteToSend--;
006674  E94000     DEC.B W0, W0
1819:                      }//end while(byte_to_send.Val)
1820:                  }
1821:                  else  // RAM
1822:                  {
1823:                      while(byteToSend)
00665E  E00400     CP0.B W0
006660  3A000C     BRA NZ, .L13
006662  370012     BRA .L4
006686  3AFFF9     BRA NZ, .L13
1824:                      {
1825:                          *pDst++ = *inPipes[0].pSrc.bRam++;
00665C  20A203     MOV #0xA20, W3
00667A  780113     MOV [W3], W2
00667C  807CC1     MOV pDst, W1
00667E  785892     MOV.B [W2], [W1++]
006680  887CC1     MOV W1, pDst
006682  E80982     INC W2, [W3]
1826:                          byteToSend--;
006684  E94000     DEC.B W0, W0
1827:                      }//end while(byte_to_send.Val)
1828:                  }//end if(usb_stat.ctrl_trf_mem == _const)
1829:              }//end USBCtrlTrfTxService
006688  060000     RETURN
1830:              
1831:              /******************************************************************************
1832:               * Function:        void USBCtrlTrfRxService(void)
1833:               *
1834:               * PreCondition:    pDst and wCount are setup properly.
1835:               *                  pSrc is always &CtrlTrfData
1836:               *                  usb_stat.ctrl_trf_mem is always USB_EP0_RAM.
1837:               *                  wCount should be set to 0 at the start of each control
1838:               *                  transfer.
1839:               *
1840:               * Input:           None
1841:               *
1842:               * Output:          None
1843:               *
1844:               * Side Effects:    None
1845:               *
1846:               * Overview:        This routine is used for host to device control transfers
1847:               *					(uses OUT transactions).  This function receives the data that arrives
1848:               *					on EP0 OUT, and copies it into the appropriate outPipes[0].pDst.bRam
1849:               *					buffer.  Once the host has sent all the data it was intending
1850:               *					to send, this function will call the appropriate outPipes[0].pFunc()
1851:               *					handler (unless it is NULL), so that it can be used by the
1852:               *					intended target firmware.
1853:               *
1854:               * Note:            None
1855:               *****************************************************************************/
1856:              static void USBCtrlTrfRxService(void)
1857:              {
1858:                  uint8_t byteToRead;
1859:                  uint8_t i;
1860:              
1861:                  //Load byteToRead with the number of bytes the host just sent us in the
1862:                  //last OUT transaction.
1863:                  byteToRead = pBDTEntryEP0OutCurrent->CNT;
006CC6  807C90     MOV pBDTEntryEP0OutCurrent, W0
006CC8  784190     MOV.B [W0], W3
1864:              
1865:                  //Update the "outPipes[0].wCount.Val", which keeps track of the total number
1866:                  //of remaining bytes expected to be received from the host, in the control
1867:                  //transfer.  First check to see if the host sent us more bytes than the
1868:                  //application firmware was expecting to receive.
1869:                  if(byteToRead > outPipes[0].wCount.Val)
006CCA  805141     MOV 0xA28, W1
006CCC  DE08C8     LSR W1, #8, W1
006CCE  20A2A0     MOV #0xA2A, W0
006CD0  FB8010     ZE [W0], W0
006CD2  DD0048     SL W0, #8, W0
006CD4  708000     IOR W1, W0, W0
006CD6  FB8083     ZE W3, W1
006CD8  508F80     SUB W1, W0, [W15]
006CDA  360001     BRA LEU, .L103
1870:                  {
1871:                      byteToRead = outPipes[0].wCount.Val;
006CDC  784180     MOV.B W0, W3
1872:                  }
1873:                  //Reduce the number of remaining bytes by the number we just received.
1874:                  outPipes[0].wCount.Val -= byteToRead;
006CDE  FB8083     ZE W3, W1
006CE0  500001     SUB W0, W1, W0
006CE2  20A281     MOV #0xA28, W1
006CE4  DD0148     SL W0, #8, W2
006CE6  200FF4     MOV #0xFF, W4
006CE8  620211     AND W4, [W1], W4
006CEA  720882     IOR W4, W2, [W1]
006CEC  DE0048     LSR W0, #8, W0
006CEE  E88081     INC2 W1, W1
006CF0  784880     MOV.B W0, [W1]
1875:              
1876:                  //Copy the OUT DATAx packet bytes that we just received from the host,
1877:                  //into the user application buffer space.
1878:                  for(i=0;i<byteToRead;i++)
006CF2  E00403     CP0.B W3
006CF4  320009     BRA Z, .L104
006CF6  EB0000     CLR W0
006D04  51CF80     SUB.B W3, W0, [W15]
006D06  3EFFFA     BRA GTU, .L105
1879:                  {
1880:                      *outPipes[0].pDst.bRam++ = CtrlTrfData[i];
006CF8  508164     SUB W1, #0x4, W2
006CFA  20A3A4     MOV #0xA3A, W4
006CFC  780092     MOV [W2], W1
006CFE  7848E4     MOV.B [W4+W0], [W1]
006D00  E80901     INC W1, [W2]
006D02  E80000     INC W0, W0
1881:                  }//end while(byteToRead.Val)
1882:              
1883:                  //If there is more data to receive, prepare EP0 OUT so that it can receive
1884:              	//the next packet in the sequence.
1885:                  if(outPipes[0].wCount.Val > 0)
006D08  805141     MOV 0xA28, W1
006D0A  DE08C8     LSR W1, #8, W1
006D0C  20A2A0     MOV #0xA2A, W0
006D0E  FB8010     ZE [W0], W0
006D10  DD0048     SL W0, #8, W0
006D12  708000     IOR W1, W0, W0
006D14  320019     BRA Z, .L106
1886:                  {
1887:                      pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
006D16  B3C081     MOV.B #0x8, W1
006D18  807CA0     MOV pBDTEntryEP0OutNext, W0
006D1A  784801     MOV.B W1, [W0]
1888:                      pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&CtrlTrfData);
006D1C  20A3A1     MOV #0xA3A, W1
006D1E  807CA0     MOV pBDTEntryEP0OutNext, W0
006D20  980011     MOV W1, [W0+2]
1889:                      if(pBDTEntryEP0OutCurrent->STAT.DTS == 0)
006D22  807C90     MOV pBDTEntryEP0OutCurrent, W0
006D24  A3E810     BTST.Z [W0], #14
006D26  3A0008     BRA NZ, .L107
1890:                      {
1891:                          pBDTEntryEP0OutNext->STAT.Val = _DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);
006D28  B3C481     MOV.B #0x48, W1
006D2A  807CA0     MOV pBDTEntryEP0OutNext, W0
006D2C  984011     MOV.B W1, [W0+1]
1892:                          pBDTEntryEP0OutNext->STAT.Val |= _USIE;
006D2E  807CA0     MOV pBDTEntryEP0OutNext, W0
006D30  904090     MOV.B [W0+1], W1
006D32  A07401     BSET.B W1, #7
006D34  984011     MOV.B W1, [W0+1]
006D36  370021     BRA .L102
1893:                      }
1894:                      else
1895:                      {
1896:                          pBDTEntryEP0OutNext->STAT.Val = _DAT0|(_DTSEN & _DTS_CHECKING_ENABLED);
006D38  B3C081     MOV.B #0x8, W1
006D3A  807CA0     MOV pBDTEntryEP0OutNext, W0
006D3C  984011     MOV.B W1, [W0+1]
1897:                          pBDTEntryEP0OutNext->STAT.Val |= _USIE;
006D3E  807CA0     MOV pBDTEntryEP0OutNext, W0
006D40  904090     MOV.B [W0+1], W1
006D42  A07401     BSET.B W1, #7
006D44  984011     MOV.B W1, [W0+1]
006D46  370019     BRA .L102
1898:                      }
1899:                  }
1900:                  else
1901:                  {
1902:              	    //We have received all OUT packets that we were expecting to
1903:              	    //receive for the control transfer.  Prepare EP0 OUT to receive
1904:              		//the next SETUP transaction that may arrive.
1905:                      pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
006D48  B3C081     MOV.B #0x8, W1
006D4A  807CA0     MOV pBDTEntryEP0OutNext, W0
006D4C  784801     MOV.B W1, [W0]
1906:                      pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
006D4E  807CA0     MOV pBDTEntryEP0OutNext, W0
006D50  20A321     MOV #0xA32, W1
006D52  980011     MOV W1, [W0+2]
1907:                      //Configure EP0 OUT to receive the next SETUP transaction for any future
1908:                      //control transfers.  However, set BSTALL in case the host tries to send
1909:                      //more data than it claims it was going to send.
1910:                      pBDTEntryEP0OutNext->STAT.Val = _BSTALL;
006D54  B3C041     MOV.B #0x4, W1
006D56  984011     MOV.B W1, [W0+1]
1911:                      pBDTEntryEP0OutNext->STAT.Val |= _USIE;
006D58  807CA0     MOV pBDTEntryEP0OutNext, W0
006D5A  904090     MOV.B [W0+1], W1
006D5C  A07401     BSET.B W1, #7
006D5E  984011     MOV.B W1, [W0+1]
1912:              
1913:              		//All data bytes for the host to device control write (OUT) have now been
1914:              		//received successfully.
1915:              		//Go ahead and call the user specified callback function, to use/consume
1916:              		//the control transfer data (ex: if the "void (*function)" parameter
1917:              		//was non-NULL when USBEP0Receive() was called).
1918:                      if(outPipes[0].pFunc != NULL)
006D60  805151     MOV 0xA2A, W1
006D62  DE08C8     LSR W1, #8, W1
006D64  20A2C0     MOV #0xA2C, W0
006D66  FB8010     ZE [W0], W0
006D68  DD0048     SL W0, #8, W0
006D6A  708000     IOR W1, W0, W0
006D6C  320001     BRA Z, .L109
1919:                      {
1920:                          #if defined(__XC8)
1921:                              //Special pragmas to suppress an expected/harmless warning
1922:                              //message when building with the XC8 compiler
1923:                              #pragma warning push
1924:                              #pragma warning disable 1088
1925:                              outPipes[0].pFunc();    //Call the user's callback function
1926:                              #pragma warning pop
1927:                          #else
1928:                              outPipes[0].pFunc();    //Call the user's callback function
006D6E  010000     CALL W0
1929:                          #endif
1930:                      }
1931:                      outPipes[0].info.bits.busy = 0;
006D70  20A280     MOV #0xA28, W0
006D72  A17010     BCLR [W0], #7
1932:              
1933:                      //Ready to arm status stage IN transaction now, if the application
1934:                      //firmware has completed processing the request.  If it is still busy
1935:                      //and needs more time to finish handling the request, then the user
1936:                      //callback (the one called by the outPipes[0].pFunc();) should set the
1937:                      //USBDeferStatusStagePacket to true (by calling USBDeferStatusStage()).  In
1938:                      //this case, it is the application's firmware responsibility to call
1939:                      //the USBCtrlEPAllowStatusStage() function, once it is fully done handling the request.
1940:                      //Note: The application firmware must process the request and call
1941:                      //USBCtrlEPAllowStatusStage() in a semi-timely fashion.  "Semi-timely"
1942:                      //means either 50ms, 500ms, or 5 seconds, depending on the type of
1943:                      //control transfer.  See the USB 2.0 specification section 9.2.6 for
1944:                      //more details.
1945:                      if(USBDeferStatusStagePacket == false)
006D74  E24F7F     CP0.B USBDeferStatusStagePacket
006D76  3A0001     BRA NZ, .L102
1946:                      {
1947:                          USBCtrlEPAllowStatusStage();
006D78  07FF79     RCALL USBCtrlEPAllowStatusStage
1948:                      }
1949:                  }
1950:              
1951:              }//end USBCtrlTrfRxService
006D7A  060000     RETURN
1952:              
1953:              
1954:              /********************************************************************
1955:               * Function:        void USBStdSetCfgHandler(void)
1956:               *
1957:               * PreCondition:    None
1958:               *
1959:               * Input:           None
1960:               *
1961:               * Output:          None
1962:               *
1963:               * Side Effects:    None
1964:               *
1965:               * Overview:        This routine first disables all endpoints by
1966:               *                  clearing UEP registers. It then configures
1967:               *                  (initializes) endpoints by calling the callback
1968:               *                  function USBCBInitEP().
1969:               *
1970:               * Note:            None
1971:               *******************************************************************/
1972:              static void USBStdSetCfgHandler(void)
1973:              {
0069D0  781F88     MOV W8, [W15++]
1974:                  uint8_t i;
1975:              
1976:                  // This will generate a zero length packet
1977:                  inPipes[0].info.bits.busy = 1;
0069D2  20A220     MOV #0xA22, W0
0069D4  A07010     BSET [W0], #7
1978:              
1979:                  //Clear all of the endpoint control registers
1980:                  DisableNonZeroEndpoints(USB_MAX_EP_NUMBER);
0069D6  EF24AC     CLR U1EP1
1981:              
1982:                  //Clear all of the BDT entries
1983:                  memset((void*)&BDT[0], 0x00, sizeof(BDT));
0069D8  20A008     MOV #0xA00, W8
0069DA  200202     MOV #0x20, W2
0069DC  EB0080     CLR W1
0069DE  780008     MOV W8, W0
0069E0  07CD77     RCALL 0x4D0
1984:              
1985:                  // Assert reset request to all of the Ping Pong buffer pointers
1986:                  USBPingPongBufferReset = 1;
0069E2  A82494     BSET U1CON, #1
1987:              
1988:              	//Re-Initialize all ping pong software state bits to 0 (which corresponds to
1989:              	//the EVEN buffer being the next one that will be used), since we are also
1990:              	//doing a hardware ping pong pointer reset above.
1991:              	for(i = 0; i < (uint8_t)(USB_MAX_EP_NUMBER+1u); i++)
1992:              	{
1993:              		ep_data_in[i].Val = 0u;
0069E4  EB4000     CLR.B W0
0069E6  20A2E1     MOV #0xA2E, W1
0069E8  784880     MOV.B W0, [W1]
0069EE  20A2F1     MOV #0xA2F, W1
0069F0  784880     MOV.B W0, [W1]
1994:                      ep_data_out[i].Val = 0u;
0069EA  20A301     MOV #0xA30, W1
0069EC  784880     MOV.B W0, [W1]
0069F2  20A311     MOV #0xA31, W1
0069F4  784880     MOV.B W0, [W1]
1995:              	}
1996:              
1997:                  //clear the alternate interface settings
1998:                  memset((void*)&USBAlternateInterface,0x00,USB_MAX_NUM_INT);
0069F6  EF6F90     CLR.B USBAlternateInterface
1999:              
2000:                  //Stop trying to reset ping pong buffer pointers
2001:                  USBPingPongBufferReset = 0;
0069F8  A92494     BCLR U1CON, #1
2002:              
2003:                  pBDTEntryIn[0] = (volatile BDT_ENTRY*)&BDT[EP0_IN_EVEN];
0069FA  440068     ADD W8, #0x8, W0
0069FC  887C60     MOV W0, pBDTEntryIn
2004:              
2005:              	//Set the next out to the current out packet
2006:                  pBDTEntryEP0OutCurrent = (volatile BDT_ENTRY*)&BDT[EP0_OUT_EVEN];
0069FE  887C98     MOV W8, pBDTEntryEP0OutCurrent
2007:                  pBDTEntryEP0OutNext = pBDTEntryEP0OutCurrent;
006A00  887CA8     MOV W8, pBDTEntryEP0OutNext
2008:              
2009:                  //set the current configuration
2010:                  USBActiveConfiguration = SetupPkt.bConfigurationValue;
006A02  20A340     MOV #0xA34, W0
006A04  784010     MOV.B [W0], W0
006A06  B7EF86     MOV.B WREG, USBActiveConfiguration
2011:              
2012:                  //if the configuration value == 0
2013:                  if(USBActiveConfiguration == 0)
006A08  E00400     CP0.B W0
006A0A  3A0003     BRA NZ, .L68
2014:                  {
2015:                      //Go back to the addressed state
2016:                      USBDeviceState = ADDRESS_STATE;
006A0C  200100     MOV #0x10, W0
006A0E  887C20     MOV W0, USBDeviceState
006A10  370006     BRA .L67
2017:                  }
2018:                  else
2019:                  {
2020:                      //initialize the required endpoints
2021:                      USB_SET_CONFIGURATION_HANDLER(EVENT_CONFIGURED,(void*)&USBActiveConfiguration,1);
006A12  200012     MOV #0x1, W2
006A14  20F861     MOV #0xF86, W1
006A16  200010     MOV #0x1, W0
006A18  07040F     RCALL USER_USB_CALLBACK_EVENT_HANDLER
2022:              
2023:                      //Otherwise go to the configured state.  Update the state variable last,
2024:                      //after performing all of the set configuration related initialization
2025:                      //tasks.
2026:                      USBDeviceState = CONFIGURED_STATE;
006A1A  200200     MOV #0x20, W0
006A1C  887C20     MOV W0, USBDeviceState
2027:                  }//end if(SetupPkt.bConfigurationValue == 0)
2028:              }//end USBStdSetCfgHandler
006A1E  78044F     MOV [--W15], W8
006A20  060000     RETURN
2029:              
2030:              
2031:              /********************************************************************
2032:               * Function:        void USBStdGetDscHandler(void)
2033:               *
2034:               * PreCondition:    None
2035:               *
2036:               * Input:           None
2037:               *
2038:               * Output:          None
2039:               *
2040:               * Side Effects:    None
2041:               *
2042:               * Overview:        This routine handles the standard GET_DESCRIPTOR
2043:               *                  request.
2044:               *
2045:               * Note:            None
2046:               *******************************************************************/
2047:              static void USBStdGetDscHandler(void)
2048:              {
2049:                  if(SetupPkt.bmRequestType == 0x80)
00668A  B3C800     MOV.B #0x80, W0
00668C  20A321     MOV #0xA32, W1
00668E  104F91     SUBR.B W0, [W1], [W15]
006690  3A0033     BRA NZ, .L16
2050:                  {
2051:                      inPipes[0].info.Val = USB_EP0_ROM | USB_EP0_BUSY | USB_EP0_INCLUDE_ZERO;
006692  B3CC01     MOV.B #0xC0, W1
006694  20A220     MOV #0xA22, W0
006696  784801     MOV.B W1, [W0]
2052:              
2053:                      switch(SetupPkt.bDescriptorType)
006698  20A350     MOV #0xA35, W0
00669A  784010     MOV.B [W0], W0
00669C  504FE2     SUB.B W0, #0x2, [W15]
00669E  320009     BRA Z, .L20
0066A0  504FE3     SUB.B W0, #0x3, [W15]
0066A2  320019     BRA Z, .L21
0066A4  504FE1     SUB.B W0, #0x1, [W15]
0066A6  3A0026     BRA NZ, .L24
2054:                      {
2055:                          case USB_DESCRIPTOR_DEVICE:
2056:                              #if !defined(USB_USER_DEVICE_DESCRIPTOR)
2057:                                  inPipes[0].pSrc.bRom = (const uint8_t*)&device_dsc;
2058:                              #else
2059:                                  inPipes[0].pSrc.bRom = (const uint8_t*)USB_USER_DEVICE_DESCRIPTOR;
0066A8  2A0020     MOV #0xA002, W0
0066AA  885100     MOV W0, inPipes
2060:                              #endif
2061:                              inPipes[0].wCount.Val = sizeof(device_dsc);
0066AC  200120     MOV #0x12, W0
0066AE  885120     MOV W0, 0xA24
2062:                              break;
0066B0  370023     BRA .L16
2063:                          case USB_DESCRIPTOR_CONFIGURATION:
2064:                              //First perform error case check, to make sure the host is requesting a
2065:                              //legal descriptor index.  If the request index is illegal, don't do
2066:                              //anything (so that the default STALL response will be sent).
2067:                              if(SetupPkt.bDscIndex < USB_MAX_NUM_CONFIG_DSC)
0066B2  20A340     MOV #0xA34, W0
0066B4  E00410     CP0.B [W0]
0066B6  3A000C     BRA NZ, .L22
2068:                              {
2069:                                  #if !defined(USB_USER_CONFIG_DESCRIPTOR)
2070:                                      inPipes[0].pSrc.bRom = *(USB_CD_Ptr+SetupPkt.bDscIndex);
0066B8  FB8010     ZE [W0], W0
0066BA  400000     ADD W0, W0, W0
0066BC  2A0AC1     MOV #0xA0AC, W1
0066BE  780061     MOV [W1+W0], W0
0066C0  885100     MOV W0, inPipes
2071:                                  #else
2072:                                      inPipes[0].pSrc.bRom = *(USB_USER_CONFIG_DESCRIPTOR+SetupPkt.bDscIndex);
2073:                                  #endif
2074:              
2075:                                  //This must be loaded using byte addressing.  The source pointer
2076:                                  //  may not be word aligned for the 16 or 32 bit machines resulting
2077:                                  //  in an address error on the dereference.
2078:                                  inPipes[0].wCount.byte.LB = *(inPipes[0].pSrc.bRom+2);
0066C2  20A241     MOV #0xA24, W1
0066C4  904120     MOV.B [W0+2], W2
0066C6  784882     MOV.B W2, [W1]
2079:                                  inPipes[0].wCount.byte.HB = *(inPipes[0].pSrc.bRom+3);
0066C8  E80081     INC W1, W1
0066CA  904030     MOV.B [W0+3], W0
0066CC  784880     MOV.B W0, [W1]
0066CE  370014     BRA .L16
2080:                              }
2081:              				else
2082:              				{
2083:              					inPipes[0].info.Val = 0;
0066D0  20A220     MOV #0xA22, W0
0066D2  EB4800     CLR.B [W0]
0066D4  370011     BRA .L16
2084:              				}
2085:                              break;
2086:                          case USB_DESCRIPTOR_STRING:
2087:                              //USB_NUM_STRING_DESCRIPTORS was introduced as optional in release v2.3.  In v2.4 and
2088:                              //  later it is now mandatory.  This should be defined in usb_config.h and should
2089:                              //  indicate the number of string descriptors.
2090:                              if(SetupPkt.bDscIndex<USB_NUM_STRING_DESCRIPTORS)
0066D6  20A340     MOV #0xA34, W0
0066D8  B3C021     MOV.B #0x2, W1
0066DA  10CF90     SUBR.B W1, [W0], [W15]
0066DC  3E0008     BRA GTU, .L23
2091:                              {
2092:                                  //Get a pointer to the String descriptor requested
2093:                                  inPipes[0].pSrc.bRom = *(USB_SD_Ptr+SetupPkt.bDscIndex);
0066DE  FB8010     ZE [W0], W0
0066E0  400000     ADD W0, W0, W0
0066E2  2A0AE1     MOV #0xA0AE, W1
0066E4  780061     MOV [W1+W0], W0
0066E6  885100     MOV W0, inPipes
2094:                                  // Set data count
2095:                                  inPipes[0].wCount.Val = *inPipes[0].pSrc.bRom;
0066E8  FB8010     ZE [W0], W0
0066EA  885120     MOV W0, 0xA24
0066EC  370005     BRA .L16
2096:                              }
2097:                              #if defined(IMPLEMENT_MICROSOFT_OS_DESCRIPTOR)
2098:                              else if(SetupPkt.bDscIndex == MICROSOFT_OS_DESCRIPTOR_INDEX)
2099:                              {
2100:                                  //Get a pointer to the special MS OS string descriptor requested
2101:                                  inPipes[0].pSrc.bRom = (const uint8_t*)&MSOSDescriptor;
2102:                                  // Set data count
2103:                                  inPipes[0].wCount.Val = *inPipes[0].pSrc.bRom;
2104:                              }
2105:                              #endif
2106:                              else
2107:                              {
2108:                                  inPipes[0].info.Val = 0;
0066EE  20A220     MOV #0xA22, W0
0066F0  EB4800     CLR.B [W0]
0066F2  370002     BRA .L16
2109:                              }
2110:                              break;
2111:                          default:
2112:                              inPipes[0].info.Val = 0;
0066F4  20A220     MOV #0xA22, W0
0066F6  EB4800     CLR.B [W0]
2113:                              break;
2114:                      }//end switch
2115:                  }//end if
2116:              }//end USBStdGetDscHandler
0066F8  060000     RETURN
2117:              
2118:              /********************************************************************
2119:               * Function:        void USBStdGetStatusHandler(void)
2120:               *
2121:               * PreCondition:    None
2122:               *
2123:               * Input:           None
2124:               *
2125:               * Output:          None
2126:               *
2127:               * Side Effects:    None
2128:               *
2129:               * Overview:        This routine handles the standard GET_STATUS request
2130:               *
2131:               * Note:            None
2132:               *******************************************************************/
2133:              static void USBStdGetStatusHandler(void)
2134:              {
2135:                  CtrlTrfData[0] = 0;                 // Initialize content
0066FA  EB4000     CLR.B W0
0066FC  20A3A1     MOV #0xA3A, W1
0066FE  784880     MOV.B W0, [W1]
2136:                  CtrlTrfData[1] = 0;
006700  E80081     INC W1, W1
006702  784880     MOV.B W0, [W1]
2137:              
2138:                  switch(SetupPkt.Recipient)
006704  20A320     MOV #0xA32, W0
006706  784010     MOV.B [W0], W0
006708  60407F     AND.B W0, #0x1F, W0
00670A  FB8000     ZE W0, W0
00670C  500FE1     SUB W0, #0x1, [W15]
00670E  32000B     BRA Z, .L28
006710  500FE2     SUB W0, #0x2, [W15]
006712  32000C     BRA Z, .L29
006714  E00000     CP0 W0
006716  3A0028     BRA NZ, .L26, .LBE2
2139:                  {
2140:                      case USB_SETUP_RECIPIENT_DEVICE_BITFIELD:
2141:                          inPipes[0].info.bits.busy = 1;
006718  20A220     MOV #0xA22, W0
00671A  A07010     BSET [W0], #7
2142:                          /*
2143:                           * [0]: bit0: Self-Powered Status [0] Bus-Powered [1] Self-Powered
2144:                           *      bit1: RemoteWakeup        [0] Disabled    [1] Enabled
2145:                           */
2146:                          if(self_power == 1) // self_power is defined in HardwareProfile.h
2147:                          {
2148:                              CtrlTrfData[0]|=0x01;
2149:                          }
2150:              
2151:                          if(RemoteWakeup == true)
00671C  E24F81     CP0.B RemoteWakeup
00671E  320024     BRA Z, .L26, .LBE2
2152:                          {
2153:                              CtrlTrfData[0]|=0x02;
006720  E90001     DEC W1, W0
006722  A01410     BSET.B [W0], #1
006724  370021     BRA .L26, .LBE2
2154:                          }
2155:                          break;
2156:                      case USB_SETUP_RECIPIENT_INTERFACE_BITFIELD:
2157:                          inPipes[0].info.bits.busy = 1;     // No data to update
006726  20A220     MOV #0xA22, W0
006728  A07010     BSET [W0], #7
2158:                          break;
00672A  37001E     BRA .L26, .LBE2
2159:                      case USB_SETUP_RECIPIENT_ENDPOINT_BITFIELD:
2160:                          inPipes[0].info.bits.busy = 1;
00672C  20A220     MOV #0xA22, W0
00672E  A07010     BSET [W0], #7
2161:                          /*
2162:                           * [0]: bit0: Halt Status [0] Not Halted [1] Halted
2163:                           */
2164:                          if(SetupPkt.EPNum != 0)
006730  20A360     MOV #0xA36, W0
006732  784010     MOV.B [W0], W0
006734  60406F     AND.B W0, #0xF, W0
006736  320018     BRA Z, .L26, .LBE2
2165:                          {
2166:                              BDT_ENTRY *p;
2167:              
2168:                              if(SetupPkt.EPDir == 0)
006738  20A360     MOV #0xA36, W0
00673A  E00410     CP0.B [W0]
00673C  350007     BRA LT, .L30
2169:                              {
2170:                                  p = (BDT_ENTRY*)pBDTEntryOut[SetupPkt.EPNum];
00673E  784010     MOV.B [W0], W0
006740  60406F     AND.B W0, #0xF, W0
006742  FB8000     ZE W0, W0
006744  400000     ADD W0, W0, W0
006746  20F881     MOV #0xF88, W1
006748  7800E1     MOV [W1+W0], W1
00674A  370007     BRA .L31
2171:                              }
2172:                              else
2173:                              {
2174:                                  p = (BDT_ENTRY*)pBDTEntryIn[SetupPkt.EPNum];
00674C  20A360     MOV #0xA36, W0
00674E  784010     MOV.B [W0], W0
006750  60406F     AND.B W0, #0xF, W0
006752  FB8000     ZE W0, W0
006754  400000     ADD W0, W0, W0
006756  20F8C1     MOV #0xF8C, W1
006758  7800E1     MOV [W1+W0], W1
2175:                              }
2176:              
2177:                              if((p->STAT.UOWN == 1) && (p->STAT.BSTALL == 1))
00675A  284000     MOV #0x8400, W0
00675C  600091     AND W0, [W1], W1
00675E  508F80     SUB W1, W0, [W15]
006760  3A0003     BRA NZ, .L26, .LBE2
2178:                              {
2179:                                  CtrlTrfData[0]=0x01;    // Set bit0
006762  B3C011     MOV.B #0x1, W1
006764  20A3A0     MOV #0xA3A, W0
006766  784801     MOV.B W1, [W0]
2180:                              }
2181:                          }
2182:                          break;
2183:                  }//end switch
2184:              
2185:                  if(inPipes[0].info.bits.busy == 1)
006768  200800     MOV #0x80, W0
00676A  20A221     MOV #0xA22, W1
00676C  600011     AND W0, [W1], W0
00676E  320007     BRA Z, .L25
2186:                  {
2187:                      inPipes[0].pSrc.bRam = (uint8_t*)&CtrlTrfData;        // Set Source
006770  20A3A0     MOV #0xA3A, W0
006772  885100     MOV W0, inPipes
2188:                      inPipes[0].info.bits.ctrl_trf_mem = USB_EP0_RAM;      // Set memory type
006774  780001     MOV W1, W0
006776  A00010     BSET [W0], #0
2189:                      inPipes[0].wCount.v[0] = 2;                           // Set data count
006778  B3C021     MOV.B #0x2, W1
00677A  E88000     INC2 W0, W0
00677C  784801     MOV.B W1, [W0]
2190:                  }//end if(...)
2191:              }//end USBStdGetStatusHandler
00677E  060000     RETURN
2192:              
2193:              /********************************************************************
2194:               * Function:        void USBStallHandler(void)
2195:               *
2196:               * PreCondition:    None
2197:               *
2198:               * Input:           None
2199:               *
2200:               * Output:          None
2201:               *
2202:               * Side Effects:
2203:               *
2204:               * Overview:        This function handles the event of a STALL
2205:               *                  occurring on the bus
2206:               *
2207:               * Note:            None
2208:               *******************************************************************/
2209:              static void USBStallHandler(void)
2210:              {
2211:                  /*
2212:                   * Does not really have to do anything here,
2213:                   * even for the control endpoint.
2214:                   * All BDs of Endpoint 0 are owned by SIE right now,
2215:                   * but once a Setup Transaction is received, the ownership
2216:                   * for EP0_OUT will be returned to CPU.
2217:                   * When the Setup Transaction is serviced, the ownership
2218:                   * for EP0_IN will then be forced back to CPU by firmware.
2219:                   */
2220:              
2221:                  if(U1EP0bits.EPSTALL == 1)
006780  AB24AA     BTST U1EP0, #1
006782  320011     BRA Z, .L34
2222:                  {
2223:                      // UOWN - if 0, owned by CPU, if 1, owned by SIE
2224:                      if((pBDTEntryEP0OutCurrent->STAT.Val == _USIE) && (pBDTEntryIn[0]->STAT.Val == (_USIE|_BSTALL)))
006784  807C90     MOV pBDTEntryEP0OutCurrent, W0
006786  904110     MOV.B [W0+1], W2
006788  B3C801     MOV.B #0x80, W1
00678A  514F81     SUB.B W2, W1, [W15]
00678C  3A000B     BRA NZ, .L35
00678E  807C61     MOV pBDTEntryIn, W1
006790  904111     MOV.B [W1+1], W2
006792  B3C841     MOV.B #0x84, W1
006794  514F81     SUB.B W2, W1, [W15]
006796  3A0006     BRA NZ, .L35
2225:                      {
2226:                          // Set ep0Bo to stall also
2227:                          pBDTEntryEP0OutCurrent->STAT.Val = _DAT0|(_DTSEN & _DTS_CHECKING_ENABLED)|_BSTALL;
006798  B3C0C1     MOV.B #0xC, W1
00679A  984011     MOV.B W1, [W0+1]
2228:                          pBDTEntryEP0OutCurrent->STAT.Val |= _USIE;
00679C  807C90     MOV pBDTEntryEP0OutCurrent, W0
00679E  904090     MOV.B [W0+1], W1
0067A0  A07401     BSET.B W1, #7
0067A2  984011     MOV.B W1, [W0+1]
2229:                      }//end if
2230:                      U1EP0bits.EPSTALL = 0;               // Clear stall status
0067A4  A924AA     BCLR U1EP0, #1
2231:                  }//end if
2232:              
2233:                  USBClearInterruptFlag(USBStallIFReg,USBStallIFBitNum);
0067A6  200800     MOV #0x80, W0
0067A8  882450     MOV W0, U1IR
2234:              }
0067AA  060000     RETURN
2235:              
2236:              /********************************************************************
2237:               * Function:        void USBSuspend(void)
2238:               *
2239:               * PreCondition:    None
2240:               *
2241:               * Input:           None
2242:               *
2243:               * Output:          None
2244:               *
2245:               * Side Effects:
2246:               *
2247:               * Overview:        This function handles if the host tries to
2248:               *                  suspend the device
2249:               *
2250:               * Note:            None
2251:               *******************************************************************/
2252:              static void USBSuspend(void)
2253:              {
2254:                  /*
2255:                   * NOTE: Do not clear UIRbits.ACTVIF here!
2256:                   * Reason:
2257:                   * ACTVIF is only generated once an IDLEIF has been generated.
2258:                   * This is a 1:1 ratio interrupt generation.
2259:                   * For every IDLEIF, there will be only one ACTVIF regardless of
2260:                   * the number of subsequent bus transitions.
2261:                   *
2262:                   * If the ACTIF is cleared here, a problem could occur when:
2263:                   * [       IDLE       ][bus activity ->
2264:                   * <--- 3 ms ----->     ^
2265:                   *                ^     ACTVIF=1
2266:                   *                IDLEIF=1
2267:                   *  #           #           #           #   (#=Program polling flags)
2268:                   *                          ^
2269:                   *                          This polling loop will see both
2270:                   *                          IDLEIF=1 and ACTVIF=1.
2271:                   *                          However, the program services IDLEIF first
2272:                   *                          because ACTIVIE=0.
2273:                   *                          If this routine clears the only ACTIVIF,
2274:                   *                          then it can never get out of the suspend
2275:                   *                          mode.
2276:                   */
2277:                  USBActivityIE = 1;                     // Enable bus activity interrupt
006852  A88482     BSET U1OTGIE, #4
2278:                  USBClearInterruptFlag(USBIdleIFReg,USBIdleIFBitNum);
006854  200100     MOV #0x10, W0
006856  882450     MOV W0, U1IR
2279:              
2280:                  #if defined(__18CXX) || defined(_PIC14E) || defined(__XC8)
2281:                      U1CONbits.SUSPND = 1;                   // Put USB module in power conserve
2282:                                                              // mode, SIE clock inactive
2283:                  #endif
2284:                  USBBusIsSuspended = true;
006858  B3C010     MOV.B #0x1, W0
00685A  B7EF82     MOV.B WREG, USBBusIsSuspended
2285:                  USBTicksSinceSuspendEnd = 0;
00685C  EF6F87     CLR.B USBTicksSinceSuspendEnd
2286:              
2287:                  /*
2288:                   * At this point the PIC can go into sleep,idle, or
2289:                   * switch to a slower clock, etc.  This should be done in the
2290:                   * USBCBSuspend() if necessary.
2291:                   */
2292:                  USB_SUSPEND_HANDLER(EVENT_SUSPEND,0,0);
00685E  EB0100     CLR W2
006860  EB0080     CLR W1
006862  200750     MOV #0x75, W0
006864  0704E9     RCALL USER_USB_CALLBACK_EVENT_HANDLER
2293:              }
006866  060000     RETURN
2294:              
2295:              /********************************************************************
2296:               * Function:        void USBWakeFromSuspend(void)
2297:               *
2298:               * PreCondition:    None
2299:               *
2300:               * Input:           None
2301:               *
2302:               * Output:          None
2303:               *
2304:               * Side Effects:    None
2305:               *
2306:               * Overview:
2307:               *
2308:               * Note:            None
2309:               *******************************************************************/
2310:              static void USBWakeFromSuspend(void)
2311:              {
2312:                  USBBusIsSuspended = false;
00683E  EF6F82     CLR.B USBBusIsSuspended
2313:              
2314:                  /*
2315:                   * If using clock switching, the place to restore the original
2316:                   * microcontroller core clock frequency is in the USBCBWakeFromSuspend() callback
2317:                   */
2318:                  USB_WAKEUP_FROM_SUSPEND_HANDLER(EVENT_RESUME,0,0);
006840  EB0100     CLR W2
006842  EB0080     CLR W1
006844  200740     MOV #0x74, W0
006846  0704F8     RCALL USER_USB_CALLBACK_EVENT_HANDLER
2319:              
2320:                  #if defined(__18CXX) || defined(_PIC14E) || defined(__XC8)
2321:                      //To avoid improperly clocking the USB module, make sure the oscillator
2322:                      //settings are consistent with USB operation before clearing the SUSPND bit.
2323:                      //Make sure the correct oscillator settings are selected in the
2324:                      //"USB_WAKEUP_FROM_SUSPEND_HANDLER(EVENT_RESUME,0,0)" handler.
2325:                      U1CONbits.SUSPND = 0;   // Bring USB module out of power conserve
2326:                                              // mode.
2327:                  #endif
2328:              
2329:              
2330:                  USBActivityIE = 0;
006848  A98482     BCLR U1OTGIE, #4
2331:              
2332:                  /********************************************************************
2333:                  Bug Fix: Feb 26, 2007 v2.1
2334:                  *********************************************************************
2335:                  The ACTVIF bit cannot be cleared immediately after the USB module wakes
2336:                  up from Suspend or while the USB module is suspended. A few clock cycles
2337:                  are required to synchronize the internal hardware state machine before
2338:                  the ACTIVIF bit can be cleared by firmware. Clearing the ACTVIF bit
2339:                  before the internal hardware is synchronized may not have an effect on
2340:                  the value of ACTVIF. Additionally, if the USB module uses the clock from
2341:                  the 96 MHz PLL source, then after clearing the SUSPND bit, the USB
2342:                  module may not be immediately operational while waiting for the 96 MHz
2343:                  PLL to lock.
2344:                  ********************************************************************/
2345:              
2346:                  // UIRbits.ACTVIF = 0;                      // Removed
2347:                  #if defined(__18CXX) || defined(__XC8)
2348:                  while(USBActivityIF)
2349:                  #endif
2350:                  {
2351:                      USBClearInterruptFlag(USBActivityIFReg,USBActivityIFBitNum);
00684A  200100     MOV #0x10, W0
00684C  882400     MOV W0, U1OTGIR
2352:                  }  // Added
2353:              
2354:                  USBTicksSinceSuspendEnd = 0;
00684E  EF6F87     CLR.B USBTicksSinceSuspendEnd
2355:              
2356:              }//end USBWakeFromSuspend
006850  060000     RETURN
2357:              
2358:              /********************************************************************
2359:               * Function:        void USBCtrlEPService(void)
2360:               *
2361:               * PreCondition:    USTAT is loaded with a valid endpoint address.
2362:               *
2363:               * Input:           None
2364:               *
2365:               * Output:          None
2366:               *
2367:               * Side Effects:    None
2368:               *
2369:               * Overview:        USBCtrlEPService checks for three transaction
2370:               *                  types that it knows how to service and services
2371:               *                  them:
2372:               *                  1. EP0 SETUP
2373:               *                  2. EP0 OUT
2374:               *                  3. EP0 IN
2375:               *                  It ignores all other types (i.e. EP1, EP2, etc.)
2376:               *
2377:               * Note:            None
2378:               *******************************************************************/
2379:              static void USBCtrlEPService(void)
2380:              {
2381:                  //If we get to here, that means a successful transaction has just occurred
2382:                  //on EP0.  This means "progress" has occurred in the currently pending
2383:                  //control transfer, so we should re-initialize our timeout counter.
2384:                  #if defined(USB_ENABLE_STATUS_STAGE_TIMEOUTS)
2385:                      USBStatusStageTimeoutCounter = USB_STATUS_STAGE_TIMEOUT;
006EDE  B3C2D0     MOV.B #0x2D, W0
006EE0  B7EF9D     MOV.B WREG, USBStatusStageTimeoutCounter
2386:                  #endif
2387:              
2388:              	//Check if the last transaction was on EP0 OUT endpoint (of any kind, to either the even or odd buffer if ping pong buffers used)
2389:                  if((USTATcopy.Val & USTAT_EP0_PP_MASK) == USTAT_EP0_OUT_EVEN)
006EE2  20F9A1     MOV #0xF9A, W1
006EE4  784091     MOV.B [W1], W1
006EE6  780001     MOV W1, W0
006EE8  B20FB0     AND #0xFB, W0
006EEA  3A0015     BRA NZ, .L128
2390:                  {
2391:              		//Point to the EP0 OUT buffer of the buffer that arrived
2392:                      #if defined (_PIC14E) || defined(__18CXX) || defined(__XC8)
2393:                          pBDTEntryEP0OutCurrent = (volatile BDT_ENTRY*)&BDT[(USTATcopy.Val & USTAT_EP_MASK)>>1];
2394:                      #elif defined(__C30__) || defined(__C32__) || defined __XC16__
2395:                          pBDTEntryEP0OutCurrent = (volatile BDT_ENTRY*)&BDT[(USTATcopy.Val & USTAT_EP_MASK)>>2];
006EEC  B20FC1     AND #0xFC, W1
006EEE  20A000     MOV #0xA00, W0
006EF0  408080     ADD W1, W0, W1
006EF2  887C91     MOV W1, pBDTEntryEP0OutCurrent
2396:                      #else
2397:                          #error "unimplemented"
2398:                      #endif
2399:              
2400:              		//Set the next out to the current out packet
2401:                      pBDTEntryEP0OutNext = pBDTEntryEP0OutCurrent;
2402:              		//Toggle it to the next ping pong buffer (if applicable)
2403:                      pBDTEntryEP0OutNext = (volatile BDT_ENTRY*)(((uintptr_t)pBDTEntryEP0OutNext) ^ USB_NEXT_EP0_OUT_PING_PONG);
006EF4  780001     MOV W1, W0
006EF6  A22000     BTG W0, #2
006EF8  887CA0     MOV W0, pBDTEntryEP0OutNext
2404:              
2405:              		//If the current EP0 OUT buffer has a SETUP packet
2406:                      if(pBDTEntryEP0OutCurrent->STAT.PID == PID_SETUP)
006EFA  23C002     MOV #0x3C00, W2
006EFC  610111     AND W2, [W1], W2
006EFE  234000     MOV #0x3400, W0
006F00  510F80     SUB W2, W0, [W15]
006F02  3A0007     BRA NZ, .L129
2407:                      {
2408:              	        //The SETUP transaction data may have gone into the the CtrlTrfData
2409:              	        //buffer, or elsewhere, depending upon how the BDT was prepared
2410:              	        //before the transaction.  Therefore, we should copy the data to the
2411:              	        //SetupPkt buffer so it can be processed correctly by USBCtrlTrfSetupHandler().
2412:                          memcpy((uint8_t*)&SetupPkt, (uint8_t*)ConvertToVirtualAddress(pBDTEntryEP0OutCurrent->ADR), 8);
006F04  900011     MOV [W1+2], W0
006F06  20A321     MOV #0xA32, W1
006F08  090007     REPEAT #0x7
006F0A  7858B0     MOV.B [W0++], [W1++]
006F0C  B10080     SUB #0x8, W0
2413:              
2414:              			//Handle the control transfer (parse the 8-byte SETUP command and figure out what to do)
2415:                          USBCtrlTrfSetupHandler();
006F0E  07FFC1     RCALL _USBCtrlTrfSetupHandler, .LFE9, .LFB19
006F10  370005     BRA .L127
2416:                      }
2417:                      else
2418:                      {
2419:              			//Handle the DATA transfer
2420:                          USBCtrlTrfOutHandler();
006F12  07FF34     RCALL _USBCtrlTrfOutHandler, .LFE11, .LFB20
006F14  370003     BRA .L127
2421:                      }
2422:                  }
2423:                  else if((USTATcopy.Val & USTAT_EP0_PP_MASK) == USTAT_EP0_IN)
006F16  500FE8     SUB W0, #0x8, [W15]
006F18  3A0001     BRA NZ, .L127
2424:                  {
2425:              		//Otherwise the transmission was and EP0 IN
2426:              		//  so take care of the IN transfer
2427:                      USBCtrlTrfInHandler();
006F1A  07FC48     RCALL _USBCtrlTrfInHandler, .LFE15, .LFB21
2428:                  }
2429:              
2430:              }//end USBCtrlEPService
006F1C  060000     RETURN
2431:              
2432:              /********************************************************************
2433:               * Function:        void USBCtrlTrfSetupHandler(void)
2434:               *
2435:               * PreCondition:    SetupPkt buffer is loaded with valid USB Setup Data
2436:               *
2437:               * Input:           None
2438:               *
2439:               * Output:          None
2440:               *
2441:               * Side Effects:    None
2442:               *
2443:               * Overview:        This routine is a task dispatcher and has 3 stages.
2444:               *                  1. It initializes the control transfer state machine.
2445:               *                  2. It calls on each of the module that may know how to
2446:               *                     service the Setup Request from the host.
2447:               *                     Module Example: USBD, HID, CDC, MSD, ...
2448:               *                     A callback function, USBCBCheckOtherReq(),
2449:               *                     is required to call other module handlers.
2450:               *                  3. Once each of the modules has had a chance to check if
2451:               *                     it is responsible for servicing the request, stage 3
2452:               *                     then checks direction of the transfer to determine how
2453:               *                     to prepare EP0 for the control transfer.
2454:               *                     Refer to USBCtrlEPServiceComplete() for more details.
2455:               *
2456:               * Note:            Microchip USB Firmware has three different states for
2457:               *                  the control transfer state machine:
2458:               *                  1. WAIT_SETUP
2459:               *                  2. CTRL_TRF_TX (device sends data to host through IN transactions)
2460:               *                  3. CTRL_TRF_RX (device receives data from host through OUT transactions)
2461:               *                  Refer to firmware manual to find out how one state
2462:               *                  is transitioned to another.
2463:               *
2464:               *                  A Control Transfer is composed of many USB transactions.
2465:               *                  When transferring data over multiple transactions,
2466:               *                  it is important to keep track of data source, data
2467:               *                  destination, and data count. These three parameters are
2468:               *                  stored in pSrc,pDst, and wCount. A flag is used to
2469:               *                  note if the data source is from const or RAM.
2470:               *
2471:               *******************************************************************/
2472:              static void USBCtrlTrfSetupHandler(void)
2473:              {
2474:                  //--------------------------------------------------------------------------
2475:                  //1. Re-initialize state tracking variables related to control transfers.
2476:                  //--------------------------------------------------------------------------
2477:                  shortPacketStatus = SHORT_PKT_NOT_USED;
006E92  EF6F96     CLR.B shortPacketStatus
2478:                  USBDeferStatusStagePacket = false;
006E94  EF6F7F     CLR.B USBDeferStatusStagePacket
2479:                  USBDeferINDataStagePackets = false;
006E96  EF6F80     CLR.B USBDeferINDataStagePackets
2480:                  USBDeferOUTDataStagePackets = false;
006E98  EF6F7E     CLR.B USBDeferOUTDataStagePackets
2481:                  BothEP0OutUOWNsSet = false;
006E9A  EF6F9C     CLR.B BothEP0OutUOWNsSet
2482:                  controlTransferState = WAIT_SETUP;
006E9C  EF6F97     CLR.B controlTransferState
2483:              
2484:                  //Abandon any previous control transfers that might have been using EP0.
2485:                  //Ordinarily, nothing actually needs abandoning, since the previous control
2486:                  //transfer would have completed successfully prior to the host sending the next
2487:                  //SETUP packet.  However, in a timeout error case, or after an EP0 STALL event,
2488:                  //one or more UOWN bits might still be set.  If so, we should clear the UOWN bits,
2489:                  //so the EP0 IN/OUT endpoints are in a known inactive state, ready for re-arming
2490:                  //by the class request handler that will be called next.
2491:                  pBDTEntryIn[0]->STAT.Val &= ~(_USIE);
006E9E  807C60     MOV pBDTEntryIn, W0
006EA0  904090     MOV.B [W0+1], W1
006EA2  A17401     BCLR.B W1, #7
006EA4  984011     MOV.B W1, [W0+1]
2492:              
2493:                  pBDTEntryIn[0] = (volatile BDT_ENTRY*)(((uintptr_t)pBDTEntryIn[0]) ^ USB_NEXT_EP0_IN_PING_PONG);
006EA6  807C60     MOV pBDTEntryIn, W0
006EA8  A22000     BTG W0, #2
006EAA  887C60     MOV W0, pBDTEntryIn
2494:                  pBDTEntryIn[0]->STAT.Val &= ~(_USIE);
006EAC  904090     MOV.B [W0+1], W1
006EAE  A17401     BCLR.B W1, #7
006EB0  984011     MOV.B W1, [W0+1]
2495:                  pBDTEntryIn[0] = (volatile BDT_ENTRY*)(((uintptr_t)pBDTEntryIn[0]) ^ USB_NEXT_EP0_IN_PING_PONG);
006EB2  AA4F8C     BTG pBDTEntryIn, #2
2496:                  pBDTEntryEP0OutNext->STAT.Val &= ~(_USIE);
006EB4  807CA0     MOV pBDTEntryEP0OutNext, W0
006EB6  904090     MOV.B [W0+1], W1
006EB8  A17401     BCLR.B W1, #7
006EBA  984011     MOV.B W1, [W0+1]
2497:              
2498:                  inPipes[0].info.Val = 0;
006EBC  20A220     MOV #0xA22, W0
006EBE  EB4800     CLR.B [W0]
2499:                  inPipes[0].wCount.Val = 0;
006EC0  EB0080     CLR W1
006EC2  885121     MOV W1, 0xA24
2500:                  outPipes[0].info.Val = 0;
006EC4  20A280     MOV #0xA28, W0
2501:                  outPipes[0].wCount.Val = 0;
006EC6  FB8081     ZE W1, W1
006EC8  780801     MOV W1, [W0]
006ECA  E88000     INC2 W0, W0
006ECC  2FF001     MOV #0xFF00, W1
006ECE  608810     AND W1, [W0], [W0]
2502:              
2503:              
2504:                  //--------------------------------------------------------------------------
2505:                  //2. Now find out what was in the SETUP packet, and begin handling the request.
2506:                  //--------------------------------------------------------------------------
2507:                  USBCheckStdRequest();                                               //Check for standard USB "Chapter 9" requests.
006ED0  07FDA8     RCALL _USBCheckStdRequest, .LFE12, .LFB22
2508:                  USB_NONSTANDARD_EP0_REQUEST_HANDLER(EVENT_EP0_REQUEST,0,0); //Check for USB device class specific requests
006ED2  EB0100     CLR W2
006ED4  EB0080     CLR W1
006ED6  200030     MOV #0x3, W0
006ED8  0701AF     RCALL USER_USB_CALLBACK_EVENT_HANDLER
2509:              
2510:              
2511:                  //--------------------------------------------------------------------------
2512:                  //3. Re-arm EP0 IN and EP0 OUT endpoints, based on the control transfer in
2513:                  //   progress.  If one of the above handlers (in step 2) knew how to process
2514:                  //   the request, it will have set one of the inPipes[0].info.bits.busy or
2515:                  //   outPipes[0].info.bits.busy flags = 1.  This lets the
2516:                  //   USBCtrlEPServiceComplete() function know how and which endpoints to
2517:                  //   arm.  If both info.bits.busy flags are = 0, then no one knew how to
2518:                  //   process the request.  In this case, the default behavior will be to
2519:                  //   perform protocol STALL on EP0.
2520:                  //--------------------------------------------------------------------------
2521:                  USBCtrlEPServiceComplete();
006EDA  07FF95     RCALL _USBCtrlEPServiceComplete, .LFE7, .LFB9
2522:              }//end USBCtrlTrfSetupHandler
006EDC  060000     RETURN
2523:              
2524:              
2525:              /******************************************************************************
2526:               * Function:        void USBCtrlTrfOutHandler(void)
2527:               *
2528:               * PreCondition:    None
2529:               *
2530:               * Input:           None
2531:               *
2532:               * Output:          None
2533:               *
2534:               * Side Effects:    None
2535:               *
2536:               * Overview:        This routine handles an OUT transaction according to
2537:               *                  which control transfer state is currently active.
2538:               *
2539:               * Note:            Note that if the the control transfer was from
2540:               *                  host to device, the session owner should be notified
2541:               *                  at the end of each OUT transaction to service the
2542:               *                  received data.
2543:               *
2544:               *****************************************************************************/
2545:              static void USBCtrlTrfOutHandler(void)
2546:              {
2547:                  if(controlTransferState == CTRL_TRF_RX)
006D7C  BFCF97     MOV.B controlTransferState, WREG
006D7E  504FE2     SUB.B W0, #0x2, [W15]
006D80  3A0002     BRA NZ, .L112
2548:                  {
2549:                      USBCtrlTrfRxService();	//Copies the newly received data into the appropriate buffer and configures EP0 OUT for next transaction.
006D82  07FFA1     RCALL _USBCtrlTrfRxService, .LFE6, .LFB11
006D84  370011     BRA .L111
2550:                  }
2551:                  else //In this case the last OUT transaction must have been a status stage of a CTRL_TRF_TX (<setup><in><in>...<OUT>  <-- this last OUT just occurred as the status stage)
2552:                  {
2553:                      //If the status stage is complete, this means we are done with the
2554:                      //control transfer.  Go back to the idle "WAIT_SETUP" state.
2555:                      controlTransferState = WAIT_SETUP;
006D86  EF6F97     CLR.B controlTransferState
2556:              
2557:                      //Prepare EP0 OUT for the next SETUP transaction, however, it may have
2558:                      //already been prepared if ping-pong buffering was enabled on EP0 OUT,
2559:                      //and the last control transfer was of direction: device to host, see
2560:                      //USBCtrlEPServiceComplete().  If it was already prepared, do not want
2561:                      //to do anything to the BDT.
2562:                      if(BothEP0OutUOWNsSet == false)
006D88  E24F9C     CP0.B BothEP0OutUOWNsSet
006D8A  3A000D     BRA NZ, .L114
2563:                      {
2564:                          pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
006D8C  B3C081     MOV.B #0x8, W1
006D8E  807CA0     MOV pBDTEntryEP0OutNext, W0
006D90  784801     MOV.B W1, [W0]
2565:                          pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
006D92  807CA0     MOV pBDTEntryEP0OutNext, W0
006D94  20A321     MOV #0xA32, W1
006D96  980011     MOV W1, [W0+2]
2566:                          pBDTEntryEP0OutNext->STAT.Val = _DAT0|(_DTSEN & _DTS_CHECKING_ENABLED)|_BSTALL;
006D98  B3C0C1     MOV.B #0xC, W1
006D9A  984011     MOV.B W1, [W0+1]
2567:                          pBDTEntryEP0OutNext->STAT.Val |= _USIE;
006D9C  807CA0     MOV pBDTEntryEP0OutNext, W0
006D9E  904090     MOV.B [W0+1], W1
006DA0  A07401     BSET.B W1, #7
006DA2  984011     MOV.B W1, [W0+1]
006DA4  370001     BRA .L111
2568:                      }
2569:                      else
2570:                      {
2571:                          BothEP0OutUOWNsSet = false;
006DA6  EF6F9C     CLR.B BothEP0OutUOWNsSet
2572:                      }
2573:                  }
2574:              }
006DA8  060000     RETURN
2575:              
2576:              /******************************************************************************
2577:               * Function:        void USBCtrlTrfInHandler(void)
2578:               *
2579:               * PreCondition:    None
2580:               *
2581:               * Input:           None
2582:               *
2583:               * Output:          None
2584:               *
2585:               * Side Effects:    None
2586:               *
2587:               * Overview:        This routine handles an IN transaction according to
2588:               *                  which control transfer state is currently active.
2589:               *
2590:               * Note:            A Set Address Request must not change the actual address
2591:               *                  of the device until the completion of the control
2592:               *                  transfer. The end of the control transfer for Set Address
2593:               *                  Request is an IN transaction. Therefore it is necessary
2594:               *                  to service this unique situation when the condition is
2595:               *                  right. Macro mUSBCheckAdrPendingState is defined in
2596:               *                  usb9.h and its function is to specifically service this
2597:               *                  event.
2598:               *****************************************************************************/
2599:              static void USBCtrlTrfInHandler(void)
2600:              {
0067AC  781F88     MOV W8, [W15++]
2601:                  uint8_t lastDTS;
2602:              
2603:                  lastDTS = pBDTEntryIn[0]->STAT.DTS;
0067AE  807C60     MOV pBDTEntryIn, W0
0067B0  780410     MOV [W0], W8
0067B2  DE444E     LSR W8, #14, W8
0067B4  644461     AND.B W8, #0x1, W8
2604:              
2605:                  //switch to the next ping pong buffer
2606:                  pBDTEntryIn[0] = (volatile BDT_ENTRY*)(((uintptr_t)pBDTEntryIn[0]) ^ USB_NEXT_EP0_IN_PING_PONG);
0067B6  A22000     BTG W0, #2
0067B8  887C60     MOV W0, pBDTEntryIn
2607:              
2608:                  //Must check if in ADR_PENDING_STATE.  If so, we need to update the address
2609:                  //now, since the IN status stage of the (set address) control transfer has
2610:                  //evidently completed successfully.
2611:                  if(USBDeviceState == ADR_PENDING_STATE)
0067BA  807C20     MOV USBDeviceState, W0
0067BC  500FE8     SUB W0, #0x8, [W15]
0067BE  3A000B     BRA NZ, .L37
2612:                  {
2613:                      U1ADDR = (SetupPkt.bDevADR & 0x7F);
0067C0  20A340     MOV #0xA34, W0
0067C2  FB8010     ZE [W0], W0
0067C4  B207F0     AND #0x7F, W0
0067C6  8824B0     MOV W0, U1ADDR
2614:                      if(U1ADDR != 0u)
0067C8  E20496     CP0 U1ADDR
0067CA  320003     BRA Z, .L38
2615:                      {
2616:                          USBDeviceState=ADDRESS_STATE;
0067CC  200100     MOV #0x10, W0
0067CE  887C20     MOV W0, USBDeviceState
0067D0  370002     BRA .L37
2617:                      }
2618:                      else
2619:                      {
2620:                          USBDeviceState=DEFAULT_STATE;
0067D2  200040     MOV #0x4, W0
0067D4  887C20     MOV W0, USBDeviceState
2621:                      }
2622:                  }//end if
2623:              
2624:              
2625:                  if(controlTransferState == CTRL_TRF_TX)
0067D6  BFCF97     MOV.B controlTransferState, WREG
0067D8  504FE1     SUB.B W0, #0x1, [W15]
0067DA  3A0021     BRA NZ, .L39
2626:                  {
2627:                      pBDTEntryIn[0]->ADR = ConvertToPhysicalAddress(CtrlTrfData);
0067DC  20A3A1     MOV #0xA3A, W1
0067DE  807C60     MOV pBDTEntryIn, W0
0067E0  980011     MOV W1, [W0+2]
2628:                      USBCtrlTrfTxService();
0067E2  07FF1F     RCALL _USBCtrlTrfTxService, .LFE8, .LFB10
2629:              
2630:                      //Check if we have already sent a short packet.  If so, configure
2631:                      //the endpoint to STALL in response to any further IN tokens (in the
2632:                      //case that the host erroneously tries to receive more data than it
2633:                      //should).
2634:                      if(shortPacketStatus == SHORT_PKT_SENT)
0067E4  BFCF96     MOV.B shortPacketStatus, WREG
0067E6  504FE2     SUB.B W0, #0x2, [W15]
0067E8  3A0008     BRA NZ, .L40
2635:                      {
2636:                          // If a short packet has been sent, don't want to send any more,
2637:                          // stall next time if host is still trying to read.
2638:                          pBDTEntryIn[0]->STAT.Val = _BSTALL;
0067EA  B3C041     MOV.B #0x4, W1
0067EC  807C60     MOV pBDTEntryIn, W0
0067EE  984011     MOV.B W1, [W0+1]
2639:                          pBDTEntryIn[0]->STAT.Val |= _USIE;
0067F0  807C60     MOV pBDTEntryIn, W0
0067F2  904090     MOV.B [W0+1], W1
0067F4  A07401     BSET.B W1, #7
0067F6  984011     MOV.B W1, [W0+1]
0067F8  370020     BRA .L36
2640:                      }
2641:                      else
2642:                      {
2643:                          if(lastDTS == 0)
0067FA  E00408     CP0.B W8
0067FC  3A0008     BRA NZ, .L42
2644:                          {
2645:                              pBDTEntryIn[0]->STAT.Val = _DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);
0067FE  B3C481     MOV.B #0x48, W1
006800  807C60     MOV pBDTEntryIn, W0
006802  984011     MOV.B W1, [W0+1]
2646:                              pBDTEntryIn[0]->STAT.Val |= _USIE;
006804  807C60     MOV pBDTEntryIn, W0
006806  904090     MOV.B [W0+1], W1
006808  A07401     BSET.B W1, #7
00680A  984011     MOV.B W1, [W0+1]
00680C  370016     BRA .L36
2647:                          }
2648:                          else
2649:                          {
2650:                              pBDTEntryIn[0]->STAT.Val = _DAT0|(_DTSEN & _DTS_CHECKING_ENABLED);
00680E  B3C081     MOV.B #0x8, W1
006810  807C60     MOV pBDTEntryIn, W0
006812  984011     MOV.B W1, [W0+1]
2651:                              pBDTEntryIn[0]->STAT.Val |= _USIE;
006814  807C60     MOV pBDTEntryIn, W0
006816  904090     MOV.B [W0+1], W1
006818  A07401     BSET.B W1, #7
00681A  984011     MOV.B W1, [W0+1]
00681C  37000E     BRA .L36
2652:                          }
2653:                      }//end if(...)else
2654:                  }
2655:              	else // must have been a CTRL_TRF_RX status stage IN packet (<setup><out><out>...<IN>  <-- this last IN just occurred as the status stage)
2656:              	{
2657:                      //if someone is still expecting data from the control transfer
2658:                      //  then make sure to terminate that request and let them know that
2659:                      //  they are done
2660:                      if(outPipes[0].info.bits.busy == 1)
00681E  20A280     MOV #0xA28, W0
006820  E00410     CP0.B [W0]
006822  3D000A     BRA GE, .L43
2661:                      {
2662:                          if(outPipes[0].pFunc != NULL)
006824  805151     MOV 0xA2A, W1
006826  DE08C8     LSR W1, #8, W1
006828  400064     ADD W0, #0x4, W0
00682A  FB8010     ZE [W0], W0
00682C  DD0048     SL W0, #8, W0
00682E  708000     IOR W1, W0, W0
006830  320001     BRA Z, .L44
2663:                          {
2664:                              outPipes[0].pFunc();
006832  010000     CALL W0
2665:                          }
2666:                          outPipes[0].info.bits.busy = 0;
006834  20A280     MOV #0xA28, W0
006836  A17010     BCLR [W0], #7
2667:                      }
2668:              
2669:                      controlTransferState = WAIT_SETUP;
006838  EF6F97     CLR.B controlTransferState
2670:                      //Don't need to arm EP0 OUT here.  It was already armed by the last <out> that
2671:                      //got processed by the USBCtrlTrfRxService() handler.
2672:              	}
2673:              
2674:              }
00683A  78044F     MOV [--W15], W8
00683C  060000     RETURN
2675:              
2676:              
2677:              /********************************************************************
2678:               * Function:        void USBCheckStdRequest(void)
2679:               *
2680:               * PreCondition:    None
2681:               *
2682:               * Input:           None
2683:               *
2684:               * Output:          None
2685:               *
2686:               * Side Effects:    None
2687:               *
2688:               * Overview:        This routine checks the setup data packet to see
2689:               *                  if it knows how to handle it
2690:               *
2691:               * Note:            None
2692:               *******************************************************************/
2693:              static void USBCheckStdRequest(void)
2694:              {
2695:                  if(SetupPkt.RequestType != USB_SETUP_TYPE_STANDARD_BITFIELD) return;
006A22  20A320     MOV #0xA32, W0
006A24  B3C601     MOV.B #0x60, W1
006A26  60C010     AND.B W1, [W0], W0
006A28  3A0043     BRA NZ, .L70
2696:              
2697:                  switch(SetupPkt.bRequest)
006A2A  20A330     MOV #0xA33, W0
006A2C  FB8010     ZE [W0], W0
006A2E  EB0080     CLR W1
006A30  500FEB     SUB W0, #0xB, [W15]
006A32  588FE0     SUBB W1, #0x0, [W15]
006A34  3E003D     BRA GTU, .L70
006A36  016000     BRA W0
006A38  37001E     BRA .L72
006A3A  37001F     BRA .L73
006A3C  370039     BRA .L70
006A3E  37001D     BRA .L73
006A40  370037     BRA .L70
006A42  370006     BRA .L74
006A44  37000A     BRA .L75
006A46  370030     BRA .L76
006A48  37000C     BRA .L77
006A4A  370009     BRA .L78
006A4C  370018     BRA .L79
006A4E  370024     BRA .L80
2698:                  {
2699:                      case USB_REQUEST_SET_ADDRESS:
2700:                          inPipes[0].info.bits.busy = 1;            // This will generate a zero length packet
006A50  20A220     MOV #0xA22, W0
006A52  A07010     BSET [W0], #7
2701:                          USBDeviceState = ADR_PENDING_STATE;       // Update state only
006A54  200080     MOV #0x8, W0
006A56  887C20     MOV W0, USBDeviceState
2702:                          /* See USBCtrlTrfInHandler() for the next step */
2703:                          break;
006A58  37002B     BRA .L70
2704:                      case USB_REQUEST_GET_DESCRIPTOR:
2705:                          USBStdGetDscHandler();
006A5A  07FE17     RCALL _USBStdGetDscHandler, .LFE10, .LFB13
2706:                          break;
006A5C  370029     BRA .L70
2707:                      case USB_REQUEST_SET_CONFIGURATION:
2708:                          USBStdSetCfgHandler();
006A5E  07FFB8     RCALL _USBStdSetCfgHandler, .LFE23, .LFB12
2709:                          break;
006A60  370027     BRA .L70
2710:                      case USB_REQUEST_GET_CONFIGURATION:
2711:                          inPipes[0].pSrc.bRam = (uint8_t*)&USBActiveConfiguration;         // Set Source
006A62  20F860     MOV #0xF86, W0
006A64  885100     MOV W0, inPipes
2712:                          inPipes[0].info.bits.ctrl_trf_mem = USB_EP0_RAM;               // Set memory type
006A66  20A220     MOV #0xA22, W0
006A68  780090     MOV [W0], W1
2713:                          inPipes[0].wCount.v[0] = 1;                         // Set data count
006A6A  B3C013     MOV.B #0x1, W3
006A6C  E88100     INC2 W0, W2
006A6E  784903     MOV.B W3, [W2]
2714:                          inPipes[0].info.bits.busy = 1;
006A70  B30811     IOR #0x81, W1
006A72  780801     MOV W1, [W0]
2715:                          break;
006A74  37001D     BRA .L70
2716:                      case USB_REQUEST_GET_STATUS:
2717:                          USBStdGetStatusHandler();
006A76  07FE41     RCALL _USBStdGetStatusHandler, .LFE13, .LFB14
2718:                          break;
006A78  37001B     BRA .L70
2719:                      case USB_REQUEST_CLEAR_FEATURE:
2720:                      case USB_REQUEST_SET_FEATURE:
2721:                          USBStdFeatureReqHandler();
006A7A  07FEF6     RCALL _USBStdFeatureReqHandler, .LFE16, .LFB23
2722:                          break;
006A7C  370019     BRA .L70
2723:                      case USB_REQUEST_GET_INTERFACE:
2724:                          inPipes[0].pSrc.bRam = (uint8_t*)&USBAlternateInterface[SetupPkt.bIntfID];  // Set source
006A7E  20A360     MOV #0xA36, W0
006A80  FB8110     ZE [W0], W2
006A82  20F901     MOV #0xF90, W1
006A84  20A200     MOV #0xA20, W0
006A86  410801     ADD W2, W1, [W0]
2725:                          inPipes[0].info.bits.ctrl_trf_mem = USB_EP0_RAM;               // Set memory type
006A88  E88000     INC2 W0, W0
006A8A  780090     MOV [W0], W1
2726:                          inPipes[0].wCount.v[0] = 1;                         // Set data count
006A8C  B3C013     MOV.B #0x1, W3
006A8E  E88100     INC2 W0, W2
006A90  784903     MOV.B W3, [W2]
2727:                          inPipes[0].info.bits.busy = 1;
006A92  B30811     IOR #0x81, W1
006A94  780801     MOV W1, [W0]
2728:                          break;
006A96  37000C     BRA .L70
2729:                      case USB_REQUEST_SET_INTERFACE:
2730:                          inPipes[0].info.bits.busy = 1;
006A98  20A220     MOV #0xA22, W0
006A9A  A07010     BSET [W0], #7
2731:                          USBAlternateInterface[SetupPkt.bIntfID] = SetupPkt.bAltID;
006A9C  20A360     MOV #0xA36, W0
006A9E  FB8090     ZE [W0], W1
006AA0  20F900     MOV #0xF90, W0
006AA2  20A342     MOV #0xA34, W2
006AA4  787092     MOV.B [W2], [W1+W0]
2732:                          break;
006AA6  370004     BRA .L70
2733:                      case USB_REQUEST_SET_DESCRIPTOR:
2734:                          USB_SET_DESCRIPTOR_HANDLER(EVENT_SET_DESCRIPTOR,0,0);
006AA8  EB0100     CLR W2
006AAA  EB0080     CLR W1
006AAC  200020     MOV #0x2, W0
006AAE  0703C4     RCALL USER_USB_CALLBACK_EVENT_HANDLER
2735:                          break;
2736:                      case USB_REQUEST_SYNCH_FRAME:
2737:                      default:
2738:                          break;
2739:                  }//end switch
2740:              }//end USBCheckStdRequest
006AB0  060000     RETURN
2741:              
2742:              /********************************************************************
2743:               * Function:        void USBStdFeatureReqHandler(void)
2744:               *
2745:               * PreCondition:    None
2746:               *
2747:               * Input:           None
2748:               *
2749:               * Output:          Can alter BDT entries.  Can also modify USB stack
2750:               *                  Maintained variables.
2751:               *
2752:               * Side Effects:    None
2753:               *
2754:               * Overview:        This routine handles the standard SET & CLEAR
2755:               *                  FEATURES requests
2756:               *
2757:               * Note:            This is a private function, intended for internal
2758:               *                  use by the USB stack, when processing SET/CLEAR
2759:               *                  feature requests.
2760:               *******************************************************************/
2761:              static void USBStdFeatureReqHandler(void)
2762:              {
006868  BE9F88     MOV.D W8, [W15++]
2763:                  BDT_ENTRY *p;
2764:                  EP_STATUS current_ep_data;
2765:                  #if defined(__C32__)
2766:                      uint32_t* pUEP;
2767:                  #else
2768:                      unsigned char* pUEP;
2769:                  #endif
2770:              
2771:                  //Check if the host sent a valid SET or CLEAR feature (remote wakeup) request.
2772:                  if((SetupPkt.bFeature == USB_FEATURE_DEVICE_REMOTE_WAKEUP)&&
00686A  20A340     MOV #0xA34, W0
00686C  B3C011     MOV.B #0x1, W1
00686E  10CF90     SUBR.B W1, [W0], [W15]
006870  3A000E     BRA NZ, .L48
006878  3A000A     BRA NZ, .L48
2773:                     (SetupPkt.Recipient == USB_SETUP_RECIPIENT_DEVICE_BITFIELD))
006872  E98000     DEC2 W0, W0
006874  784010     MOV.B [W0], W0
006876  60407F     AND.B W0, #0x1F, W0
2774:                  {
2775:                      inPipes[0].info.bits.busy = 1;
00687A  20A220     MOV #0xA22, W0
00687C  A07010     BSET [W0], #7
2776:                      if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
00687E  20A330     MOV #0xA33, W0
006880  B3C032     MOV.B #0x3, W2
006882  114F90     SUBR.B W2, [W0], [W15]
006884  3A0003     BRA NZ, .L49
2777:                          RemoteWakeup = true;
006886  784001     MOV.B W1, W0
006888  B7EF81     MOV.B WREG, RemoteWakeup
00688A  370001     BRA .L48
2778:                      else
2779:                          RemoteWakeup = false;
00688C  EF6F81     CLR.B RemoteWakeup
2780:                  }//end if
2781:              
2782:                  //Check if the host sent a valid SET or CLEAR endpoint halt request.
2783:                  if((SetupPkt.bFeature == USB_FEATURE_ENDPOINT_HALT)&&
00688E  20A340     MOV #0xA34, W0
006890  E00410     CP0.B [W0]
006892  3A009C     BRA NZ, .L47
00689A  504FE2     SUB.B W0, #0x2, [W15]
00689C  3A0097     BRA NZ, .L47
2784:                     (SetupPkt.Recipient == USB_SETUP_RECIPIENT_ENDPOINT_BITFIELD)&&
006894  E98000     DEC2 W0, W0
006896  784010     MOV.B [W0], W0
006898  60407F     AND.B W0, #0x1F, W0
0068A4  320093     BRA Z, .L47
2785:                     (SetupPkt.EPNum != 0) && (SetupPkt.EPNum <= USB_MAX_EP_NUMBER)&&
00689E  20A360     MOV #0xA36, W0
0068A0  784010     MOV.B [W0], W0
0068A2  60406F     AND.B W0, #0xF, W0
0068A6  20A360     MOV #0xA36, W0
0068A8  784010     MOV.B [W0], W0
0068AA  60406F     AND.B W0, #0xF, W0
0068AC  FB8000     ZE W0, W0
0068AE  500FE1     SUB W0, #0x1, [W15]
0068B0  3C008D     BRA GT, .L47
0068B2  200200     MOV #0x20, W0
0068B4  E30F84     CP USBDeviceState
0068B6  3A008A     BRA NZ, .L47
2786:                     (USBDeviceState == CONFIGURED_STATE))
2787:                  {
2788:              		//The request was valid.  Take control of the control transfer and
2789:              		//perform the host requested action.
2790:              		inPipes[0].info.bits.busy = 1;
0068B8  20A220     MOV #0xA22, W0
0068BA  A07010     BSET [W0], #7
2791:              
2792:                      //Fetch a pointer to the BDT that the host wants to SET/CLEAR halt on.
2793:                      if(SetupPkt.EPDir == OUT_FROM_HOST)
0068BC  20A360     MOV #0xA36, W0
0068BE  E00410     CP0.B [W0]
0068C0  35000C     BRA LT, .L51
2794:                      {
2795:                          p = (BDT_ENTRY*)pBDTEntryOut[SetupPkt.EPNum];
0068C2  784110     MOV.B [W0], W2
0068C4  6140EF     AND.B W2, #0xF, W1
0068C6  FB8081     ZE W1, W1
0068C8  408081     ADD W1, W1, W1
0068CA  20F882     MOV #0xF88, W2
0068CC  788462     MOV [W2+W1], W8
2796:                          current_ep_data.Val = ep_data_out[SetupPkt.EPNum].Val;
0068CE  784010     MOV.B [W0], W0
0068D0  60406F     AND.B W0, #0xF, W0
0068D2  FB8000     ZE W0, W0
0068D4  20A301     MOV #0xA30, W1
0068D6  7844E1     MOV.B [W1+W0], W9
0068D8  37000C     BRA .L52
2797:                      }
2798:                      else
2799:                      {
2800:                          p = (BDT_ENTRY*)pBDTEntryIn[SetupPkt.EPNum];
0068DA  20A360     MOV #0xA36, W0
0068DC  784110     MOV.B [W0], W2
0068DE  6140EF     AND.B W2, #0xF, W1
0068E0  FB8081     ZE W1, W1
0068E2  408081     ADD W1, W1, W1
0068E4  20F8C2     MOV #0xF8C, W2
0068E6  788462     MOV [W2+W1], W8
2801:                          current_ep_data.Val = ep_data_in[SetupPkt.EPNum].Val;
0068E8  784010     MOV.B [W0], W0
0068EA  60406F     AND.B W0, #0xF, W0
0068EC  FB8000     ZE W0, W0
0068EE  20A2E1     MOV #0xA2E, W1
0068F0  7844E1     MOV.B [W1+W0], W9
2802:                      }
2803:              
2804:                      //If ping pong buffering is enabled on the requested endpoint, need
2805:                      //to point to the one that is the active BDT entry which the SIE will
2806:                      //use for the next attempted transaction on that EP number.
2807:                      #if (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)
2808:                          if(current_ep_data.bits.ping_pong_state == 0) //Check if even
0068F2  A30809     BTST.Z W9, #0
0068F4  3A0002     BRA NZ, .L53
2809:                          {
2810:                              p = (BDT_ENTRY*)(((uintptr_t)p) & (~USB_NEXT_PING_PONG));
0068F6  A12008     BCLR W8, #2
0068F8  370001     BRA .L54
2811:                          }
2812:                          else //else must have been odd
2813:                          {
2814:                              p = (BDT_ENTRY*)(((uintptr_t)p) | USB_NEXT_PING_PONG);
0068FA  A02008     BSET W8, #2
2815:                          }
2816:                      #endif
2817:              
2818:                      //Update the BDT pointers with the new, next entry based on the feature
2819:                      //  request
2820:                      if(SetupPkt.EPDir == OUT_FROM_HOST)
0068FC  20A360     MOV #0xA36, W0
0068FE  E00410     CP0.B [W0]
006900  350007     BRA LT, .L55
2821:                      {
2822:                          pBDTEntryOut[SetupPkt.EPNum] = (volatile BDT_ENTRY *)p;
006902  784010     MOV.B [W0], W0
006904  60406F     AND.B W0, #0xF, W0
006906  FB8000     ZE W0, W0
006908  400000     ADD W0, W0, W0
00690A  20F881     MOV #0xF88, W1
00690C  783088     MOV W8, [W1+W0]
00690E  370007     BRA .L56
2823:                      }
2824:                      else
2825:                      {
2826:                          pBDTEntryIn[SetupPkt.EPNum] = (volatile BDT_ENTRY *)p;
006910  20A360     MOV #0xA36, W0
006912  784010     MOV.B [W0], W0
006914  60406F     AND.B W0, #0xF, W0
006916  FB8000     ZE W0, W0
006918  400000     ADD W0, W0, W0
00691A  20F8C1     MOV #0xF8C, W1
00691C  783088     MOV W8, [W1+W0]
2827:                      }
2828:              
2829:              		//Check if it was a SET_FEATURE endpoint halt request
2830:                      if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
00691E  20A330     MOV #0xA33, W0
006920  B3C031     MOV.B #0x3, W1
006922  10CF90     SUBR.B W1, [W0], [W15]
006924  3A001A     BRA NZ, .L57
2831:                      {
2832:                          if(p->STAT.UOWN == 1)
006926  E00018     CP0 [W8]
006928  3D0013     BRA GE, .L58
2833:                          {
2834:                              //Mark that we are terminating this transfer and that the user
2835:                              //  needs to be notified later
2836:                              if(SetupPkt.EPDir == OUT_FROM_HOST)
00692A  400063     ADD W0, #0x3, W0
00692C  E00410     CP0.B [W0]
00692E  350008     BRA LT, .L59
2837:                              {
2838:                                  ep_data_out[SetupPkt.EPNum].bits.transfer_terminated = 1;
006930  784010     MOV.B [W0], W0
006932  60406F     AND.B W0, #0xF, W0
006934  FB8000     ZE W0, W0
006936  20A301     MOV #0xA30, W1
006938  784161     MOV.B [W1+W0], W2
00693A  A01402     BSET.B W2, #1
00693C  787082     MOV.B W2, [W1+W0]
00693E  370008     BRA .L58
2839:                              }
2840:                              else
2841:                              {
2842:                                  ep_data_in[SetupPkt.EPNum].bits.transfer_terminated = 1;
006940  20A360     MOV #0xA36, W0
006942  784010     MOV.B [W0], W0
006944  60406F     AND.B W0, #0xF, W0
006946  FB8000     ZE W0, W0
006948  20A2E1     MOV #0xA2E, W1
00694A  784161     MOV.B [W1+W0], W2
00694C  A01402     BSET.B W2, #1
00694E  787082     MOV.B W2, [W1+W0]
2843:                              }
2844:                          }
2845:              
2846:              			//Then STALL the endpoint
2847:                          p->STAT.Val |= _BSTALL;
2848:                          p->STAT.Val |= _USIE;
006950  904098     MOV.B [W8+1], W1
006952  B3C840     MOV.B #0x84, W0
006954  70C000     IOR.B W1, W0, W0
006956  984410     MOV.B W0, [W8+1]
006958  370039     BRA .L47
2849:                      }//if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
2850:                      else
2851:                      {
2852:              			//Else the request must have been a CLEAR_FEATURE endpoint halt.
2853:                          #if (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)
2854:                              //toggle over the to the non-active BDT
2855:                              p = (BDT_ENTRY*)(((uintptr_t)p) ^ USB_NEXT_PING_PONG);
00695A  780088     MOV W8, W1
00695C  A22001     BTG W1, #2
2856:              
2857:                              if(p->STAT.UOWN == 1)
00695E  E00011     CP0 [W1]
006960  3D0008     BRA GE, .L60
2858:                              {
2859:                                  //Clear UOWN and set DTS state so it will be correct the next time
2860:                                  //the application firmware uses USBTransferOnePacket() on the EP.
2861:                                  p->STAT.Val &= (~_USIE);    //Clear UOWN bit
006962  904011     MOV.B [W1+1], W0
006964  A17400     BCLR.B W0, #7
2862:                                  p->STAT.Val |= _DAT1;       //Set DTS to DATA1
006966  A06400     BSET.B W0, #6
006968  984090     MOV.B W0, [W1+1]
2863:                                  USB_TRANSFER_TERMINATED_HANDLER(EVENT_TRANSFER_TERMINATED,p,sizeof(p));
00696A  200022     MOV #0x2, W2
00696C  200050     MOV #0x5, W0
00696E  070464     RCALL USER_USB_CALLBACK_EVENT_HANDLER
006970  370003     BRA .L61
2864:                              }
2865:                              else
2866:                              {
2867:                                  //UOWN already clear, but still need to set DTS to DATA1
2868:              					p->STAT.Val |= _DAT1;
006972  904011     MOV.B [W1+1], W0
006974  A06400     BSET.B W0, #6
006976  984090     MOV.B W0, [W1+1]
2869:                              }
2870:              
2871:                              //toggle back to the active BDT (the one the SIE is currently looking at
2872:                              //and will use for the next successful transaction to take place on the EP
2873:                              p = (BDT_ENTRY*)(((uintptr_t)p) ^ USB_NEXT_PING_PONG);
2874:              
2875:                              //Check if we are currently terminating, or have previously terminated
2876:                              //a transaction on the given endpoint.  If so, need to clear UOWN,
2877:                              //set DTS to the proper state, and call the application callback
2878:                              //function.
2879:                              if((current_ep_data.bits.transfer_terminated != 0) || (p->STAT.UOWN == 1))
006978  A31809     BTST.Z W9, #1
00697A  3A0002     BRA NZ, .L62
00697C  E00018     CP0 [W8]
00697E  3D001B     BRA GE, .L63
2880:                              {
2881:                                  if(SetupPkt.EPDir == OUT_FROM_HOST)
006980  20A360     MOV #0xA36, W0
006982  E00410     CP0.B [W0]
006984  350008     BRA LT, .L64
2882:                                  {
2883:                                      ep_data_out[SetupPkt.EPNum].bits.transfer_terminated = 0;
006986  784010     MOV.B [W0], W0
006988  60406F     AND.B W0, #0xF, W0
00698A  FB8000     ZE W0, W0
00698C  20A301     MOV #0xA30, W1
00698E  784161     MOV.B [W1+W0], W2
006990  A11402     BCLR.B W2, #1
006992  787082     MOV.B W2, [W1+W0]
006994  370008     BRA .L65
2884:                                  }
2885:                                  else
2886:                                  {
2887:                                      ep_data_in[SetupPkt.EPNum].bits.transfer_terminated = 0;
006996  20A360     MOV #0xA36, W0
006998  784010     MOV.B [W0], W0
00699A  60406F     AND.B W0, #0xF, W0
00699C  FB8000     ZE W0, W0
00699E  20A2E1     MOV #0xA2E, W1
0069A0  784161     MOV.B [W1+W0], W2
0069A2  A11402     BCLR.B W2, #1
0069A4  787082     MOV.B W2, [W1+W0]
2888:                                  }
2889:                                  //clear UOWN, clear DTS to DATA0, and finally remove the STALL condition
2890:                                  p->STAT.Val &= ~(_USIE | _DAT1 | _BSTALL);
0069A6  904018     MOV.B [W8+1], W0
0069A8  B243B0     AND.B #0x3B, W0
0069AA  984410     MOV.B W0, [W8+1]
2891:                                  //Call the application event handler callback function, so it can
2892:              					//decide if the endpoint should get re-armed again or not.
2893:                                  USB_TRANSFER_TERMINATED_HANDLER(EVENT_TRANSFER_TERMINATED,p,sizeof(p));
0069AC  200022     MOV #0x2, W2
0069AE  780088     MOV W8, W1
0069B0  200050     MOV #0x5, W0
0069B2  070442     RCALL USER_USB_CALLBACK_EVENT_HANDLER
0069B4  370003     BRA .L66
2894:                              }
2895:                              else
2896:                              {
2897:                                  //clear UOWN, clear DTS to DATA0, and finally remove the STALL condition
2898:                                  p->STAT.Val &= ~(_USIE | _DAT1 | _BSTALL);
0069B6  904018     MOV.B [W8+1], W0
0069B8  B243B0     AND.B #0x3B, W0
0069BA  984410     MOV.B W0, [W8+1]
2899:                              }
2900:                          #else //else we must not be using ping-pong buffering on the requested endpoint
2901:                              //Check if we need to call the user transfer terminated event callback function.
2902:                              //We should call the callback, if the endpoint was previously terminated,
2903:                              //or the endpoint is currently armed, and the host is performing clear
2904:                              //endpoint halt, even though the endpoint wasn't stalled.
2905:                              if((current_ep_data.bits.transfer_terminated != 0) || (p->STAT.UOWN == 1))
2906:                              {
2907:                                  //We are going to call the user transfer terminated callback.
2908:                                  //Clear the flag so we know we took care of it and don't need
2909:                                  //to call it again later.
2910:                                  if(SetupPkt.EPDir == OUT_FROM_HOST)
2911:                                  {
2912:                                      ep_data_out[SetupPkt.EPNum].bits.transfer_terminated = 0;
2913:                                  }
2914:                                  else
2915:                                  {
2916:                                      ep_data_in[SetupPkt.EPNum].bits.transfer_terminated = 0;
2917:                                  }
2918:              
2919:                                  //Clear UOWN and remove the STALL condition.
2920:                                  //  In this case we also need to set the DTS bit to 1 so that
2921:                                  //  it toggles to DATA0 the next time the application firmware
2922:                                  //  calls USBTransferOnePacket() (or equivalent macro).
2923:                                  p->STAT.Val &= ~(_USIE | _BSTALL);
2924:                                  p->STAT.Val |= _DAT1;
2925:                                  //Let the application firmware know a transaction just
2926:                                  //got terminated by the host, and that it is now free to
2927:                                  //re-arm the endpoint or do other tasks if desired.
2928:                                  USB_TRANSFER_TERMINATED_HANDLER(EVENT_TRANSFER_TERMINATED,p,sizeof(p));
2929:                              }
2930:                              else
2931:                              {
2932:                                  //Clear UOWN and remove the STALL condition.
2933:                                  //  In this case we also need to set the DTS bit to 1 so that
2934:                                  //  it toggles to DATA0 the next time the application firmware
2935:                                  //  calls USBTransferOnePacket() (or equivalent macro).
2936:                                  p->STAT.Val &= ~(_USIE | _BSTALL);
2937:                                  p->STAT.Val |= _DAT1;
2938:                              }
2939:                          #endif //end of #if (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)
2940:              
2941:              			//Get a pointer to the appropriate UEPn register
2942:                          #if defined(__C32__)
2943:                              pUEP = (uint32_t*)(&U1EP0);
2944:                              pUEP += (SetupPkt.EPNum*4);
2945:                          #else
2946:                              pUEP = (unsigned char*)(&U1EP0+SetupPkt.EPNum);
0069BC  20A360     MOV #0xA36, W0
0069BE  784010     MOV.B [W0], W0
0069C0  60406F     AND.B W0, #0xF, W0
0069C2  FB8000     ZE W0, W0
0069C4  400000     ADD W0, W0, W0
0069C6  204AA1     MOV #0x4AA, W1
0069C8  400001     ADD W0, W1, W0
2947:                          #endif
2948:              
2949:              			//Clear the STALL bit in the UEP register
2950:                          *pUEP &= ~UEP_STALL;
0069CA  A11410     BCLR.B [W0], #1
2951:                      }//end if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
2952:                  }//end if (lots of checks for set/clear endpoint halt)
2953:              }//end USBStdFeatureReqHandler
0069CC  BE044F     MOV.D [--W15], W8
0069CE  060000     RETURN
2954:              
2955:              
2956:              
2957:              
2958:              /**************************************************************************
2959:                  Function:
2960:                      void USBIncrement1msInternalTimers(void)
2961:              
2962:                  Description:
2963:                      This function increments internal 1ms time base counters, which are
2964:                      useful for application code (that can use a 1ms time base/counter), and
2965:                      for certain USB event timing specific purposes.
2966:              
2967:                      In USB full speed applications, the application code does not need to (and should
2968:                      not) explicitly call this function, as the USBDeviceTasks() function will
2969:                      automatically call this function whenever a 1ms time interval has elapsed
2970:                      (assuming the code is calling USBDeviceTasks() frequently enough in USB_POLLING
2971:                      mode, or that USB interrupts aren't being masked for more than 1ms at a time
2972:                      in USB_INTERRUPT mode).
2973:              
2974:                      In USB low speed applications, the application firmware is responsible for
2975:                      periodically calling this function at a ~1ms rate.  This can be done using
2976:                      a general purpose microcontroller timer set to interrupt every 1ms for example.
2977:                      If the low speed application code does not call this function, the internal timers
2978:                      will not increment, and the USBGet1msTickCount() API function will not be available.
2979:                      Additionally, certain USB stack operations (like control transfer timeouts)
2980:                      may be unavailable.
2981:              
2982:                  Precondition:
2983:                      This function should be called only after USBDeviceInit() has been
2984:                      called (at least once at the start of the application).  Ordinarily,
2985:                      application code should never call this function, unless it is a low speed
2986:                      USB device.
2987:              
2988:                  Parameters:
2989:                      None
2990:              
2991:                  Return Values:
2992:                      None
2993:              
2994:                  Remarks:
2995:                      This function does not need to be called during USB suspend conditions, when
2996:                      the USB module/stack is disabled, or when the USB cable is detached from the host.
2997:                ***************************************************************************/
2998:              void USBIncrement1msInternalTimers(void)
2999:              {
3000:                  #if(USB_SPEED_OPTION == USB_LOW_SPEED)
3001:                      #warning "For low speed USB applications, read the function comments for the USBIncrement1msInternalTimers() function, and implement code to call this function periodically."
3002:                  #endif
3003:              
3004:                  //Increment timekeeping 1ms tick counters.  Useful for other APIs/code
3005:                  //that needs a 1ms time base that is active during USB non-suspended operation.
3006:                  USB1msTickCount++;
006F1E  807D00     MOV USB1msTickCount, W0
006F20  807D11     MOV 0xFA2, W1
006F22  400061     ADD W0, #0x1, W0
006F24  4880E0     ADDC W1, #0x0, W1
006F26  887D00     MOV W0, USB1msTickCount
006F28  887D11     MOV W1, 0xFA2
3007:                  if(USBIsBusSuspended() == false)
006F2A  E24F82     CP0.B USBBusIsSuspended
006F2C  3A0004     BRA NZ, .L131
3008:                  {
3009:                      USBTicksSinceSuspendEnd++;
006F2E  EC4F87     INC.B USBTicksSinceSuspendEnd, WREG
006F30  B7EF87     MOV.B WREG, USBTicksSinceSuspendEnd
3010:                      //Check for 8-bit wraparound.  If so, force it to saturate at 255.
3011:                      if(USBTicksSinceSuspendEnd == 0)
006F32  3A0001     BRA NZ, .L131
3012:                      {
3013:                          USBTicksSinceSuspendEnd = 255;
006F34  EFEF87     SETM.B USBTicksSinceSuspendEnd
3014:                      }
3015:                  }
3016:              }
006F36  060000     RETURN
3017:              
3018:              
3019:              
3020:              
3021:              /**************************************************************************
3022:                  Function:
3023:                      uint32_t USBGet1msTickCount(void)
3024:              
3025:                  Description:
3026:                      This function retrieves a 32-bit unsigned integer that normally increments by
3027:                      one every one millisecond.  The count value starts from zero when the
3028:                      USBDeviceInit() function is first called.  See the remarks section for
3029:                      details on special circumstances where the tick count will not increment.
3030:              
3031:                  Precondition:
3032:                      This function should be called only after USBDeviceInit() has been
3033:                      called (at least once at the start of the application).
3034:              
3035:                  Parameters:
3036:                      None
3037:              
3038:                  Return Values:
3039:                      uint32_t representing the approximate millisecond count, since the time the
3040:                      USBDeviceInit() function was first called.
3041:              
3042:                  Remarks:
3043:                      On 8-bit USB full speed devices, the internal counter is incremented on
3044:                      every SOF packet detected.  Therefore, it will not increment during suspend
3045:                      or when the USB cable is detached.  However, on 16-bit devices, the T1MSECIF
3046:                      hardware interrupt source is used to increment the internal counter.  Therefore,
3047:                      on 16-bit devices, the count continue to increment during USB suspend or
3048:                      detach events, so long as the application code has not put the microcontroller
3049:                      to sleep during these events, and the application firmware is regularly
3050:                      calling the USBDeviceTasks() function (or allowing it to execute, if using
3051:                      USB_INTERRUPT mode operation).
3052:              
3053:                      In USB low speed applications, the host does not broadcast SOF packets to
3054:                      the device, so the application firmware becomes responsible for calling
3055:                      USBIncrement1msInternalTimers() periodically (ex: from a general purpose
3056:                      timer interrupt handler), or else the returned value from this function will
3057:                      not increment.
3058:              
3059:                      Prior to calling USBDeviceInit() for the first time the returned value will
3060:                      be unpredictable.
3061:              
3062:                      This function is USB_INTERRUPT mode safe and may be called from main loop
3063:                      code without risk of retrieving a partially updated 32-bit number.
3064:              
3065:                      However, this value only increments when the USBDeviceTasks() function is allowed
3066:                      to execute.  If USB_INTERRUPT mode is used, it is allowable to block on this
3067:                      function.  If however USB_POLLING mode is used, one must not block on this
3068:                      function without also calling USBDeviceTasks() continuously for the blocking
3069:                      duration (since the USB stack must still be allowed to execute, and the USB
3070:                      stack is also responsible for updating the tick counter internally).
3071:              
3072:                      If the application is operating in USB_POLLING mode, this function should
3073:                      only be called from the main loop context, and not from an interrupt handler,
3074:                      as the returned value could be incorrect, if the main loop context code was in
3075:                      the process of updating the internal count at the moment of the interrupt event.
3076:                 ***************************************************************************/
3077:              uint32_t USBGet1msTickCount(void)
3078:              {
3079:                  #if defined (USB_INTERRUPT)
3080:                      uint32_t localContextValue;
3081:              
3082:                      //Repeatedly read the interrupt context variable, until we get a stable/unchanging
3083:                      //value.  This ensures that the complete 32-bit value got read without
3084:                      //getting interrupted in between bytes.
3085:                      do
3086:                      {
3087:                          localContextValue = USB1msTickCount;
3088:                      }while(localContextValue != USB1msTickCount);
3089:              
3090:                      return localContextValue;
3091:              
3092:                  #else
3093:                      return USB1msTickCount;
3094:                  #endif
3095:              }
00706A  807D00     MOV USB1msTickCount, W0
00706C  807D11     MOV 0xFA2, W1
00706E  060000     RETURN
3096:              
3097:              
3098:              
3099:              
3100:              
3101:              
3102:              /** EOF USBDevice.c *****************************************************/
---  /home/sladekm/MPLABXProjects/USB_Device_Host_MIDI.X/src/timer.c  -----------------------------------
1:                 #include <xc.h>
2:                 
3:                 #include <stdbool.h>
4:                 
5:                 #include "leds.h"
6:                 #include "timer.h"
7:                 
8:                 void scan_state_flag();
9:                 
10:                void initTimer4_10ms()
11:                {
12:                    T4CON = 0x00; //Stops the Timer4 and reset control reg.
0071DE  EF211E     CLR T4CON
13:                    TMR4 = 0x00; //Clear contents of the timer register
0071E0  EF2114     CLR TMR4
14:                    PR4 = 624; //Load the Period register with the value 0xFFFF
0071E2  202700     MOV #0x270, W0
0071E4  8808D0     MOV W0, PR4
15:                    IPC6bits.T4IP = 0x01;   //Setup Timer4 interrupt for desired priority level
0071E6  28FFF0     MOV #0x8FFF, W0
0071E8  B600B0     AND IPC6, WREG
0071EA  A0C000     BSET W0, #12
0071EC  880580     MOV W0, IPC6
16:                                            // (This example assigns level 1 priority)
17:                    T4CONbits.TCKPS = 0x03; //Prescaler 1:256
0071EE  200300     MOV #0x30, W0
0071F0  B7211E     IOR T4CON
18:                    IFS1bits.T4IF = 0; //Clear the Timer4 interrupt status flag
0071F2  A96087     BCLR 0x87, #3
19:                    IEC1bits.T4IE = 1; //Enable Timer4 interrupts
0071F4  A86097     BSET 0x97, #3
20:                    T4CONbits.TON = 1; //Start Timer4 with 
0071F6  A8E11F     BSET 0x11F, #7
21:                    //clock source set to the internal instruction cycle
22:                }
0071F8  060000     RETURN
23:                
24:                void initTimer3_100ms()
25:                {
26:                    T3CON = 0x00;   //Stops the Timer3 and reset control reg.
0071FA  EF2112     CLR T3CON
27:                    TMR3 = 0x00;    //Clear contents of the timer register
0071FC  EF210A     CLR TMR3
28:                    PR3 = 6240;     //Load the Period register
0071FE  218600     MOV #0x1860, W0
007200  880870     MOV W0, PR3
29:                    IPC2bits.T3IP = 0x01;   //Setup Timer3 interrupt for desired priority level
007202  2FFF80     MOV #0xFFF8, W0
007204  B600A8     AND IPC2, WREG
007206  A00000     BSET W0, #0
007208  880540     MOV W0, IPC2
30:                                            // (This example assigns level 1 priority)
31:                    T3CONbits.TCKPS = 0x03; //Prescaler 1:256
00720A  200300     MOV #0x30, W0
00720C  B72112     IOR T3CON
32:                    IFS0bits.T3IF = 0; //Clear the Timer3 interrupt status flag
00720E  A90085     BCLR 0x85, #0
33:                    IEC0bits.T3IE = 1; //Enable Timer3 interrupts
007210  A80095     BSET 0x95, #0
34:                    T3CONbits.TON = 1; //Start Timer3 with 
007212  A8E113     BSET 0x113, #7
35:                    //clock source set to the internal instruction cycle
36:                }
007214  060000     RETURN
37:                
38:                void initTimer2_250ms()
39:                {
40:                    T2CON = 0x00;   //Stops the Timer2 and reset control reg.
007216  EF2110     CLR T2CON
41:                    TMR2 = 0x00;    //Clear contents of the timer register
007218  EF2106     CLR TMR2
42:                    PR2 = 15600;     //Load the Period register
00721A  23CF00     MOV #0x3CF0, W0
00721C  880860     MOV W0, PR2
43:                    IPC1bits.T2IP = 0x01;   //Setup Timer2 interrupt for desired priority level
00721E  28FFF0     MOV #0x8FFF, W0
007220  B600A6     AND IPC1, WREG
007222  A0C000     BSET W0, #12
007224  880530     MOV W0, IPC1
44:                                            // (This example assigns level 1 priority)
45:                    T2CONbits.TCKPS = 0x03; //Prescaler 1:256
007226  200300     MOV #0x30, W0
007228  B72110     IOR T2CON
46:                    IFS0bits.T2IF = 0; //Clear the Timer2 interrupt status flag
00722A  A9E084     BCLR IFS0, #7
47:                    IEC0bits.T2IE = 1; //Enable Timer2 interrupts
00722C  A8E094     BSET IEC0, #7
48:                    T2CONbits.TON = 1; //Start Timer2 with 
00722E  A8E111     BSET 0x111, #7
49:                    //clock source set to the internal instruction cycle
50:                }
007230  060000     RETURN
51:                
52:                void disableTimer2(){
53:                    T2CONbits.TON = 0; //Stop Timer2 with     
007232  A9E111     BCLR 0x111, #7
54:                    IEC0bits.T2IE = 0; //Disable Timer2 interrupts
007234  A9E094     BCLR IEC0, #7
55:                }
007236  060000     RETURN
56:                
57:                /**
58:                 * 
59:                 */
60:                void __attribute__((__interrupt__, __no_auto_psv__)) _T4Interrupt(void)
61:                {
00A1C4  F80036     PUSH RCOUNT
00A1C6  BE9F80     MOV.D W0, [W15++]
00A1C8  BE9F82     MOV.D W2, [W15++]
00A1CA  BE9F84     MOV.D W4, [W15++]
00A1CC  BE9F86     MOV.D W6, [W15++]
62:                /* Interrupt Service Routine code goes here */
63:                
64:                    _call10msEventHandler(); 
00A1CE  07040F     RCALL LED1_handler
65:                    IFS1bits.T4IF = 0; //Reset Timer4 interrupt flag and Return from ISR
00A1D0  A96087     BCLR 0x87, #3
66:                }
00A1D2  BE034F     MOV.D [--W15], W6
00A1D4  BE024F     MOV.D [--W15], W4
00A1D6  BE014F     MOV.D [--W15], W2
00A1D8  BE004F     MOV.D [--W15], W0
00A1DA  F90036     POP RCOUNT
00A1DC  064000     RETFIE
67:                
68:                void __attribute__((__interrupt__, __no_auto_psv__)) _T3Interrupt(void)
69:                {
00A1DE  F80036     PUSH RCOUNT
00A1E0  BE9F80     MOV.D W0, [W15++]
00A1E2  BE9F82     MOV.D W2, [W15++]
00A1E4  BE9F84     MOV.D W4, [W15++]
00A1E6  BE9F86     MOV.D W6, [W15++]
70:                /* Interrupt Service Routine code goes here */
71:                
72:                    _call100msEventHandler(); 
00A1E8  070433     RCALL LED2_handler
73:                    IFS0bits.T3IF = 0; //Reset Timer3 interrupt flag and Return from ISR
00A1EA  A90085     BCLR 0x85, #0
74:                }
00A1EC  BE034F     MOV.D [--W15], W6
00A1EE  BE024F     MOV.D [--W15], W4
00A1F0  BE014F     MOV.D [--W15], W2
00A1F2  BE004F     MOV.D [--W15], W0
00A1F4  F90036     POP RCOUNT
00A1F6  064000     RETFIE
75:                
76:                void __attribute__((__interrupt__, __no_auto_psv__)) _T2Interrupt(void)
77:                {
00A1F8  F80036     PUSH RCOUNT
00A1FA  BE9F80     MOV.D W0, [W15++]
00A1FC  BE9F82     MOV.D W2, [W15++]
00A1FE  BE9F84     MOV.D W4, [W15++]
00A200  BE9F86     MOV.D W6, [W15++]
78:                /* Interrupt Service Routine code goes here */
79:                
80:                    _call250msEventHandler(); 
00A202  0704DF     RCALL change_scan_state_flag
81:                    IFS0bits.T2IF = 0; //Reset Timer3 interrupt flag and Return from ISR
00A204  A9E084     BCLR IFS0, #7
82:                }
00A206  BE034F     MOV.D [--W15], W6
00A208  BE024F     MOV.D [--W15], W4
00A20A  BE014F     MOV.D [--W15], W2
00A20C  BE004F     MOV.D [--W15], W0
00A20E  F90036     POP RCOUNT
00A210  064000     RETFIE
---  /home/sladekm/MPLABXProjects/USB_Device_Host_MIDI.X/src/system.c  ----------------------------------
1:                 /*******************************************************************************
2:                 Copyright 2016 Microchip Technology Inc. (www.microchip.com)
3:                 
4:                 Licensed under the Apache License, Version 2.0 (the "License");
5:                 you may not use this file except in compliance with the License.
6:                 You may obtain a copy of the License at
7:                 
8:                     http://www.apache.org/licenses/LICENSE-2.0
9:                 
10:                Unless required by applicable law or agreed to in writing, software
11:                distributed under the License is distributed on an "AS IS" BASIS,
12:                WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
13:                See the License for the specific language governing permissions and
14:                limitations under the License.
15:                
16:                To request to license the code under the MLA license (www.microchip.com/mla_license), 
17:                please contact mla_licensing@microchip.com
18:                *******************************************************************************/
19:                
20:                #include <p24FJ64GB002.h>
21:                #include "system.h"
22:                #include "usb.h"
23:                #include "leds.h"
24:                #include "buttons.h"
25:                #include "system.h"
26:                #include "timer.h"
27:                
28:                #ifdef NO_BOOTLOADER
29:                
30:                // If USB bootloader is used configuration is done in Bootloader so we use it 
31:                // here only whe bootloader is not used
32:                /** CONFIGURATION Bits **********************************************/
33:                // CONFIG1
34:                #pragma config WDTPS = PS1              // Watchdog Timer Postscaler (1:1)
35:                #pragma config FWPSA = PR32             // WDT Prescaler (Prescaler ratio of 1:32)
36:                #pragma config WINDIS = OFF             // Windowed WDT (Standard Watchdog Timer enabled,(Windowed-mode is disabled))
37:                #pragma config FWDTEN = OFF             // Watchdog Timer (Watchdog Timer is disabled)
38:                #pragma config ICS = PGx1               // Emulator Pin Placement Select bits (Emulator functions are shared with PGEC1/PGED1)
39:                #pragma config GWRP = OFF               // General Segment Write Protect (Writes to program memory are allowed)
40:                #pragma config GCP = OFF                // General Segment Code Protect (Code protection is disabled)
41:                #pragma config JTAGEN = OFF             // JTAG Port Enable (JTAG port is disabled)
42:                
43:                // CONFIG2
44:                #pragma config POSCMOD = HS             // Primary Oscillator Select (HS Oscillator mode selected)
45:                #pragma config I2C1SEL = PRI            // I2C1 Pin Select bit (Use default SCL1/SDA1 pins for I2C1 )
46:                #pragma config IOL1WAY = OFF            // IOLOCK One-Way Set Enable (The IOLOCK bit can be set and cleared using the unlock sequence)
47:                #pragma config OSCIOFNC = ON            // OSCO Pin Configuration (OSCO pin functions as port I/O (RA3))
48:                #pragma config FCKSM = CSDCMD           // Clock Switching and Fail-Safe Clock Monitor (Sw Disabled, Mon Disabled)
49:                #pragma config FNOSC = PRIPLL           // Initial Oscillator Select (Primary Oscillator with PLL module (XTPLL, HSPLL, ECPLL))
50:                #pragma config PLL96MHZ = ON            // 96MHz PLL Startup Select (96 MHz PLL Startup is enabled automatically on start-up)
51:                #pragma config PLLDIV = DIV4            // USB 96 MHz PLL Prescaler Select (Oscillator input divided by 4 (16 MHz input))
52:                #pragma config IESO = OFF               // Internal External Switchover (IESO mode (Two-Speed Start-up) disabled)
53:                
54:                // CONFIG3
55:                #pragma config WPFP = WPFP0             // Write Protection Flash Page Segment Boundary (Page 0 (0x0))
56:                #pragma config SOSCSEL = SOSC           // Secondary Oscillator Pin Mode Select (SOSC pins in Default (high drive-strength) Oscillator Mode)
57:                #pragma config WUTSEL = LEG             // Voltage Regulator Wake-up Time Select (Default regulator start-up time used)
58:                #pragma config WPDIS = WPDIS            // Segment Write Protection Disable (Segmented code protection disabled)
59:                #pragma config WPCFG = WPCFGDIS         // Write Protect Configuration Page Select (Last page and Flash Configuration words are unprotected)
60:                #pragma config WPEND = WPENDMEM         // Segment Write Protection End Page Select (Write Protect from WPFP to the last page of memory)
61:                
62:                // CONFIG4
63:                #pragma config DSWDTPS = DSWDTPS3       // DSWDT Postscale Select (1:128 (132 ms))
64:                #pragma config DSWDTOSC = LPRC          // Deep Sleep Watchdog Timer Oscillator Select (DSWDT uses Low Power RC Oscillator (LPRC))
65:                #pragma config RTCOSC = SOSC            // RTCC Reference Oscillator Select (RTCC uses Secondary Oscillator (SOSC))
66:                #pragma config DSBOREN = OFF            // Deep Sleep BOR Enable bit (BOR disabled in Deep Sleep)
67:                #pragma config DSWDTEN = OFF            // Deep Sleep Watchdog Timer (DSWDT disabled)
68:                
69:                #endif
70:                
71:                
72:                SCAN_STATE scan_state = SCAN_STATE_HOST;
73:                
74:                void UART2Init();
75:                void MIDI_U2RXInterruptHandler();
76:                
77:                /*********************************************************************
78:                * Function: void SYSTEM_Initialize( SYSTEM_STATE state )
79:                *
80:                * Overview: Initializes the system.
81:                *
82:                * PreCondition: None
83:                *
84:                * Input:  SYSTEM_STATE - the state to initialize the system into
85:                *
86:                * Output: None
87:                *
88:                ********************************************************************/
89:                void SYSTEM_Initialize( SYSTEM_STATE state )
90:                {
91:                    switch(state)
00ABA2  E00000     CP0 W0
00ABA4  3A000D     BRA NZ, .L2
92:                    {
93:                        case SYSTEM_STATE_USB_START:
94:                            //On the PIC24FJ64GB004 Family of USB microcontrollers, the PLL will not power up and be enabled
95:                            //by default, even if a PLL enabled oscillator configuration is selected (such as HS+PLL).
96:                            //This allows the device to power up at a lower initial operating frequency, which can be
97:                            //advantageous when powered from a source which is not gauranteed to be adequate for 32MHz
98:                            //operation.  On these devices, user firmware needs to manually set the CLKDIV<PLLEN> bit to
99:                            //power up the PLL.
100:                           {
101:                               unsigned int pll_startup_counter = 600;
00ABA8  202580     MOV #0x258, W0
102:                               CLKDIVbits.PLLEN = 1;
00ABA6  A8A744     BSET CLKDIV, #5
103:                               while(pll_startup_counter--);
00ABAA  E90000     DEC W0, W0
00ABAC  400FE1     ADD W0, #0x1, [W15]
00ABAE  3AFFFD     BRA NZ, .L5
104:                           }
105:                           UART2Init();
00ABB0  07FFD0     RCALL UART2Init
106:                           initTimer4_10ms();
00ABB2  07E315     RCALL initTimer4_10ms
107:                           initTimer3_100ms();
00ABB4  07E322     RCALL initTimer3_100ms
108:                           initTimer2_250ms();
00ABB6  07E32F     RCALL initTimer2_250ms
109:                           LED_Enable(LED_USB_DATA);
00ABB8  EB0000     CLR W0
00ABBA  07FEC4     RCALL LED_Enable
110:                           LED_Enable(LED_USB_DEVICE_STATE);
00ABBC  200010     MOV #0x1, W0
00ABBE  07FEC2     RCALL LED_Enable
111:                           break;
112:                           
113:                       case SYSTEM_STATE_USB_SUSPEND:
114:                           break;
115:                           
116:                       case SYSTEM_STATE_USB_RESUME:
117:                           break;
118:                           
119:                       default:
120:                           break;
121:                   }
122:               }
00ABC0  060000     RETURN
123:               
124:               
125:               /*********************************************************************
126:               * Function: void UARTInit()
127:               *
128:               * Overview: Initializes the UART1.
129:               *
130:               * PreCondition: None
131:               *
132:               * Input:  None
133:               *
134:               * Output: None
135:               *
136:               ********************************************************************/
137:               void UART2Init()
138:               {
139:                   // UART2 Pin configuration
140:                   // Configure Input Functions (Table 10-2)
141:                   // Assign U1RX To Pin RP8 (Pin 17 on the DIP-28)
142:                   RPINR19bits.U2RXR = 8;
00AB52  2FFE00     MOV #0xFFE0, W0
00AB54  B606A6     AND RPINR19, WREG
00AB56  A03000     BSET W0, #3
00AB58  883530     MOV W0, RPINR19
143:                   // Configure Output Functions (Table 10-3)
144:                   // Assign U1TX (Function 3) to Pin RP7 (Pin 16 on the DIP-28)
145:                   RPOR3bits.RP7R = 5;    
00AB5A  2E0FF1     MOV #0xE0FF, W1
00AB5C  803630     MOV RPOR3, W0
00AB5E  608080     AND W1, W0, W1
00AB60  205000     MOV #0x500, W0
00AB62  700001     IOR W0, W1, W0
00AB64  883630     MOV W0, RPOR3
146:                   // RB7 (U1TX) as output
147:                   TRISBbits.TRISB7 = 0;
00AB66  A9E2C8     BCLR TRISB, #7
148:               
149:                   // Value for 31250 baud rate.
150:                   U2BRG = 31;
00AB68  2001F0     MOV #0x1F, W0
00AB6A  8811C0     MOV W0, U2BRG
151:                
152:                   U2MODEbits.UARTEN = 1; // UART1 is Enabled
00AB6C  A8E231     BSET 0x231, #7
153:                   U2MODEbits.USIDL = 0; // Continue operation at Idlestate
00AB6E  A9A231     BCLR 0x231, #5
154:                   U2MODEbits.IREN = 0; // IrDA En/Decoder is disabled
00AB70  A98231     BCLR 0x231, #4
155:                   U2MODEbits.RTSMD = 0; // flow control mode
00AB72  A96231     BCLR 0x231, #3
156:                   U2MODEbits.UEN0=0; // Uart1 Tx and Rx pins are enabled and used.
00AB74  A90231     BCLR 0x231, #0
157:                   U2MODEbits.UEN1=0;
00AB76  A92231     BCLR 0x231, #1
158:                   U2MODEbits.WAKE = 0; // Wake-up disabled
00AB78  A9E230     BCLR U2MODE, #7
159:                   U2MODEbits.LPBACK = 0; // Loop-back is disabled
00AB7A  A9C230     BCLR U2MODE, #6
160:                   U2MODEbits.ABAUD = 0; // auto baud is disabled
00AB7C  A9A230     BCLR U2MODE, #5
161:                   U2MODEbits.RXINV = 0; // No RX inversion
00AB7E  A98230     BCLR U2MODE, #4
162:                   U2MODEbits.BRGH = 0; // low boud rate
00AB80  A96230     BCLR U2MODE, #3
163:                   U2MODEbits.PDSEL = 0b00; // 8bit no parity
00AB82  2FFF90     MOV #0xFFF9, W0
00AB84  B62230     AND U2MODE
164:                   U2MODEbits.STSEL = 0; // one stop bit
00AB86  A90230     BCLR U2MODE, #0
165:                
166:               
167:                   U2STAbits.UTXISEL1 = 0; // Tx interrupt mode disabled
00AB88  A9E233     BCLR 0x233, #7
168:                   U2STAbits.URXISEL0 = 0; // Interrupt when a last character is shifted out of Transmit Shift Register. All Tx operations are complete.
00AB8A  A9C232     BCLR U2STA, #6
169:                   U2STA &= 0xDFFF; // clearTORNADO II T TXINV by bit masking
00AB8C  A9A233     BCLR 0x233, #5
170:                   U2STAbits.UTXBRK = 0; // sync break tx is disabled
00AB8E  A96233     BCLR 0x233, #3
171:                   U2STAbits.UTXEN = 1; //transmit is enabled
00AB90  A84233     BSET 0x233, #2
172:                   U2STAbits.URXISEL = 0b00; // interrupt flag bit is set when RXBUF is filled whith 1 character
00AB92  2FF3F0     MOV #0xFF3F, W0
00AB94  B62232     AND U2STA
173:                   U2STAbits.ADDEN = 0; // address detect mode is disabled
00AB96  A9A232     BCLR U2STA, #5
174:                
175:                   IFS1bits.U2RXIF = 0; // clear interrupt flag of rx
00AB98  A9C087     BCLR 0x87, #6
176:                   IFS1bits.U2TXIF = 0; // clear interrupt flag of Tx
00AB9A  A9E087     BCLR 0x87, #7
177:                
178:                   IEC1bits.U2TXIE = 0 ; // Disabl uart transmit interrupt.
00AB9C  A9E097     BCLR 0x97, #7
179:                   IEC1bits.U2RXIE = 1 ; // Enable uart receive interrupt. 
00AB9E  A8C097     BSET 0x97, #6
180:               }
00ABA0  060000     RETURN
181:               
182:               
183:               void __attribute__((interrupt,auto_psv)) _USB1Interrupt()
184:               {
00A184  F80036     PUSH RCOUNT
00A186  BE9F80     MOV.D W0, [W15++]
00A188  BE9F82     MOV.D W2, [W15++]
00A18A  BE9F84     MOV.D W4, [W15++]
00A18C  BE9F86     MOV.D W6, [W15++]
00A18E  F80034     PUSH PSVPAG
00A190  200010     MOV #0x1, W0
00A192  8801A0     MOV W0, PSVPAG
185:                   USB_HostInterruptHandler();
00A194  07E070     RCALL USB_HostInterruptHandler
186:               }
00A196  F90034     POP PSVPAG
00A198  BE034F     MOV.D [--W15], W6
00A19A  BE024F     MOV.D [--W15], W4
00A19C  BE014F     MOV.D [--W15], W2
00A19E  BE004F     MOV.D [--W15], W0
00A1A0  F90036     POP RCOUNT
00A1A2  064000     RETFIE
187:               
188:               void __attribute__((interrupt, auto_psv)) _U2RXInterrupt()
189:               {
00A1A4  F80036     PUSH RCOUNT
00A1A6  BE9F80     MOV.D W0, [W15++]
00A1A8  BE9F82     MOV.D W2, [W15++]
00A1AA  BE9F84     MOV.D W4, [W15++]
00A1AC  BE9F86     MOV.D W6, [W15++]
00A1AE  F80034     PUSH PSVPAG
00A1B0  200010     MOV #0x1, W0
00A1B2  8801A0     MOV W0, PSVPAG
190:                   MIDI_U2RXInterruptHandler();
00A1B4  070040     RCALL MIDI_U2RXInterruptHandler
191:               }
00A1B6  F90034     POP PSVPAG
00A1B8  BE034F     MOV.D [--W15], W6
00A1BA  BE024F     MOV.D [--W15], W4
00A1BC  BE014F     MOV.D [--W15], W2
00A1BE  BE004F     MOV.D [--W15], W0
00A1C0  F90036     POP RCOUNT
00A1C2  064000     RETFIE
192:               
193:               /**
194:               * Function: void change_scan_flag()
195:               *
196:               * Overview: Changes scan flag. Used during discovery operation
197:               *
198:               * PreCondition: None
199:               *
200:               * Input:  None
201:               *
202:               * Output: None
203:               */
204:               void change_scan_state_flag(){
205:                   
206:                   static divider = 0;
207:                   if(divider++ <= 3){
00ABC2  8042D0     MOV divider, W0
00ABC4  E80080     INC W0, W1
00ABC6  8842D1     MOV W1, divider
00ABC8  500FE3     SUB W0, #0x3, [W15]
00ABCA  34000B     BRA LE, .L9
208:                       return;
209:                   }
210:                   divider = 0;
00ABCC  EF285A     CLR divider
211:                   switch (scan_state){
00ABCE  8042C0     MOV 0x858, W0
00ABD0  E00000     CP0 W0
00ABD2  320003     BRA Z, .L11
00ABD4  500FE1     SUB W0, #0x1, [W15]
00ABD6  3A0005     BRA NZ, .L9
00ABD8  370003     BRA .L13
212:                       case SCAN_STATE_DEVICE:
213:                           scan_state = SCAN_STATE_HOST;
00ABDA  200010     MOV #0x1, W0
00ABDC  8842C0     MOV W0, 0x858
214:                           break;
00ABDE  370001     BRA .L9
215:                       case SCAN_STATE_HOST:
216:                           scan_state = SCAN_STATE_DEVICE;
00ABE0  EF2858     CLR 0x858
217:                           break;
218:                   }
219:               }
00ABE2  060000     RETURN
---  /home/sladekm/MPLABXProjects/USB_Device_Host_MIDI.X/src/main.c  ------------------------------------
1:                 /*******************************************************************************
2:                 Copyright 2016 Microchip Technology Inc. (www.microchip.com)
3:                 
4:                 Licensed under the Apache License, Version 2.0 (the "License");
5:                 you may not use this file except in compliance with the License.
6:                 You may obtain a copy of the License at
7:                 
8:                     http://www.apache.org/licenses/LICENSE-2.0
9:                 
10:                Unless required by applicable law or agreed to in writing, software
11:                distributed under the License is distributed on an "AS IS" BASIS,
12:                WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
13:                See the License for the specific language governing permissions and
14:                limitations under the License.
15:                
16:                To request to license the code under the MLA license (www.microchip.com/mla_license), 
17:                please contact mla_licensing@microchip.com
18:                *******************************************************************************/
19:                
20:                /** INCLUDES *******************************************************/
21:                #include "system.h"
22:                
23:                #include "app_device_audio_midi.h"
24:                #include "app_led_usb_status.h"
25:                
26:                #include "usb_device.h"
27:                #include "usb_device_midi.h"
28:                #include "usb_host_midi.h"
29:                #include "leds.h"
30:                #include "timer.h"
31:                #include "usb_host.h"
32:                #include "usb_host_local.h"
33:                
34:                extern SCAN_STATE scan_state;
35:                extern uint16_t usbHostState;
36:                bool usb_host_attached = false;
37:                
38:                /********************************************************************
39:                 * Function:        void main(void)
40:                 *
41:                 * PreCondition:    None
42:                 *
43:                 * Input:           None
44:                 *
45:                 * Output:          None
46:                 *
47:                 * Side Effects:    None
48:                 *
49:                 * Overview:        Main program entry point.
50:                 *
51:                 * Note:            None
52:                 *******************************************************************/
53:                MAIN_RETURN main(void)
54:                {
00AA54  BE9F88     MOV.D W8, [W15++]
55:                    SYSTEM_Initialize(SYSTEM_STATE_USB_START);
00AA56  EB0000     CLR W0
00AA58  0700A4     RCALL SYSTEM_Initialize
56:                    while(1){
57:                //        scan_state = SCAN_STATE_HOST;
58:                        switch (scan_state) {
00AA5C  8042C0     MOV 0x858, W0
00AA5E  E00000     CP0 W0
00AA60  320003     BRA Z, .L3
00AA62  500FE1     SUB W0, #0x1, [W15]
00AA64  3AFFFC     BRA NZ, .L2
00AA66  370011     BRA .L4
59:                            case SCAN_STATE_DEVICE:
60:                                USBDeviceInit();
00AA68  07E024     RCALL USBDeviceInit
61:                                USBDeviceAttach();
62:                                while(scan_state == SCAN_STATE_DEVICE){
00AA6A  37000D     BRA .L5
00AA86  E20858     CP0 0x858
00AA88  32FFF1     BRA Z, .L8
63:                                    USBDeviceTasks();
00AA6C  07E265     RCALL USBDeviceTasks
64:                                    if (USBGetDeviceState() == CONFIGURED_STATE){
00AA6E  200200     MOV #0x20, W0
00AA70  E30F84     CP USBDeviceState
00AA72  3A0009     BRA NZ, .L5
65:                                        // Disable Timet2 as we don't need scanning anymore
66:                                        disableTimer2();
00AA74  07E3DE     RCALL disableTimer2
67:                                        LED2_Set_State(LED_STATUS_ON);
00AA76  200020     MOV #0x2, W0
00AA78  07FF7C     RCALL LED2_Set_State
68:                                        // And continue as an USB device
69:                                        while(1)
70:                                        {
71:                                            SYSTEM_Tasks();
72:                
73:                                            #if defined(USB_POLLING)
74:                                                // Interrupt or polling method.  If using polling, must call
75:                                                // this function periodically.  This function will take care
76:                                                // of processing and responding to SETUP transactions
77:                                                // (such as during the enumeration process when you first
78:                                                // plug in).  USB hosts require that USB devices should accept
79:                                                // and process SETUP packets in a timely fashion.  Therefore,
80:                                                // when using polling, this function should be called
81:                                                // regularly (such as once every 1.8ms or faster** [see
82:                                                // inline code comments in usb_device.c for explanation when
83:                                                // "or faster" applies])  In most cases, the USBDeviceTasks()
84:                                                // function does not take very long to execute (ex: <100
85:                                                // instruction cycles) before it returns.
86:                                                USBDeviceTasks();
00AA7A  07E25E     RCALL USBDeviceTasks
87:                                            #endif
88:                                            if (USBGetDeviceState() == DETACHED_STATE){
00AA7C  E20F84     CP0 USBDeviceState
00AA7E  3A0001     BRA NZ, .L6
89:                                                asm ("RESET");
00AA80  FE0000     RESET
90:                                            }
91:                
92:                                            //Application specific tasks
93:                                            APP_DeviceAudioMIDITasks();
00AA82  07E354     RCALL APP_DeviceAudioMIDITasks
94:                
95:                                        }//end while
00AA84  37FFFA     BRA .L7
96:                                    }
97:                                }
98:                            case SCAN_STATE_HOST:
99:                                disableTimer2(); // REMOVE AFTER USB HOST ISSUE FIXED !!!!
00AA8A  07E3D3     RCALL disableTimer2
100:               
101:                               //Initialize the host stack
102:                               USBHostInit(0);
00AA5A  B84460     MUL.UU W8, #0, W8
00AA8C  BE0008     MOV.D W8, W0
00AA8E  07CF3E     RCALL USBHostInit
103:                               APP_HostMIDIBasicInitialize();
00AA90  07FCE9     RCALL APP_HostMIDIBasicInitialize
104:                               while(scan_state == SCAN_STATE_HOST){
00AA92  37000C     BRA .L9, .LBE3
00AAAC  8042C0     MOV 0x858, W0
00AAAE  500FE1     SUB W0, #0x1, [W15]
00AAB0  3AFFD5     BRA NZ, .L12, .LBE2
00AAB2  37FFF0     BRA .L15
105:               
106:                                   USBHostTasks();
00AA94  07D236     RCALL USBHostTasks
107:                                   if(usb_host_attached){
00AA96  E24856     CP0.B usb_host_attached
00AA98  320009     BRA Z, .L9, .LBE3
108:                                       // Disable Timet2 as we don't need scanning anymore
109:                                       disableTimer2();
00AA9A  07E3CB     RCALL disableTimer2
110:                                       // to make sure that it was not redefined by the timer
111:                                       scan_state = SCAN_STATE_HOST;
00AA9C  200010     MOV #0x1, W0
00AA9E  8842C0     MOV W0, 0x858
112:                                       // And continue as a host
113:                                       while(1)
114:                                       {
115:                                           if(USBHostDeviceStatus(0) == STATE_DETACHED){
00AAA0  EB4400     CLR.B W8
00AAA2  784008     MOV.B W8, W0
00AAA4  07CCE7     RCALL USBHostDeviceStatus
116:               //                                asm("RESET");
117:                                           }
118:                                           USBHostTasks();
00AAA6  07D22D     RCALL USBHostTasks
119:                                           //Application specific tasks
120:                                           APP_HostMIDIBasicTasks();
00AAA8  07FCE3     RCALL APP_HostMIDIBasicTasks
00AAAA  37FFFB     BRA .L10
00AAAC  8042C0     MOV 0x858, W0
00AAAE  500FE1     SUB W0, #0x1, [W15]
00AAB0  3AFFD5     BRA NZ, .L12, .LBE2
00AAB2  37FFF0     BRA .L15
121:                                       }//end while
122:                                   }
123:                               }
124:                       }
125:                   }
126:               
127:               }//end main
128:               
129:               /****************************************************************************
130:                 Function:
131:                   bool USB_ApplicationEventHandler( uint8_t address, USB_EVENT event,
132:                               void *data, uint32_t size )
133:               
134:                 Summary:
135:                   This is the application event handler.  It is called when the stack has
136:                   an event that needs to be handled by the application layer rather than
137:                   by the client driver.
138:               
139:                 Description:
140:                   This is the application event handler.  It is called when the stack has
141:                   an event that needs to be handled by the application layer rather than
142:                   by the client driver.  If the application is able to handle the event, it
143:                   returns TRUE.  Otherwise, it returns FALSE.
144:               
145:                 Precondition:
146:                   None
147:               
148:                 Parameters:
149:                   uint8_t address    - Address of device where event occurred
150:                   USB_EVENT event - Identifies the event that occured
151:                   void *data      - Pointer to event-specific data
152:                   uint32_t size      - Size of the event-specific data
153:               
154:                 Return Values:
155:                   TRUE    - The event was handled
156:                   FALSE   - The event was not handled
157:               
158:                 Remarks:
159:                   The application may also implement an event handling routine if it
160:                   requires knowledge of events.  To do so, it must implement a routine that
161:                   matches this function signature and define the USB_HOST_APP_EVENT_HANDLER
162:                   macro as the name of that function.
163:                 ***************************************************************************/
164:               bool USB_Host_ApplicationEventHandler( uint8_t address, USB_EVENT event, void *data, uint32_t size )
165:               {
00AAB4  BE9F88     MOV.D W8, [W15++]
00AAB6  781F8A     MOV W10, [W15++]
00AAB8  BE9F8C     MOV.D W12, [W15++]
00AABA  784500     MOV.B W0, W10
00AABC  780401     MOV W1, W8
00AABE  780482     MOV W2, W9
00AAC0  BE0604     MOV.D W4, W12
166:                   switch( (int)event )
00AAC2  200700     MOV #0x70, W0
00AAC4  540F80     SUB W8, W0, [W15]
00AAC6  3C000C     BRA GT, .L22
00AAC8  500064     SUB W0, #0x4, W0
00AACA  540F80     SUB W8, W0, [W15]
00AACC  3D0018     BRA GE, .L18, .LBB5
00AACE  500067     SUB W0, #0x7, W0
00AAD0  540F80     SUB W8, W0, [W15]
00AAD2  320015     BRA Z, .L18, .LBB5
00AAD4  350039     BRA LT, .L24, .LBE5
00AAD6  2FF970     MOV #0xFF97, W0
00AAD8  400008     ADD W0, W8, W0
00AADA  500FE1     SUB W0, #0x1, [W15]
00AADC  3E0035     BRA GTU, .L24, .LBE5
00AADE  37000F     BRA .L18, .LBB5
00AAE0  203E80     MOV #0x3E8, W0
00AAE2  540F80     SUB W8, W0, [W15]
00AAE4  320016     BRA Z, .L19
00AAE6  3C0004     BRA GT, .L23
00AAE8  200720     MOV #0x72, W0
00AAEA  540F80     SUB W8, W0, [W15]
00AAEC  3A002D     BRA NZ, .L24, .LBE5
00AAEE  370007     BRA .L18, .LBB5
00AAF0  203E90     MOV #0x3E9, W0
00AAF2  540F80     SUB W8, W0, [W15]
00AAF4  32001C     BRA Z, .L20
00AAF6  E80000     INC W0, W0
00AAF8  540F80     SUB W8, W0, [W15]
00AAFA  3A0026     BRA NZ, .L24, .LBE5
00AAFC  370019     BRA .L21
167:                   {
168:                       /* Standard USB host events ******************************************/
169:                       case EVENT_VBUS_REQUEST_POWER:
170:                       case EVENT_VBUS_RELEASE_POWER:
171:                       case EVENT_HUB_ATTACH:
172:                       case EVENT_UNSUPPORTED_DEVICE:
173:                       case EVENT_CANNOT_ENUMERATE:
174:                       case EVENT_CLIENT_INIT_ERROR:
175:                       case EVENT_OUT_OF_MEMORY:
176:                       case EVENT_UNSPECIFIED_ERROR: // This should never be generated.
177:                       case EVENT_TRANSFER:
178:                            return APP_HostMIDIBasicEventHandler( address, event, data, size );            
00AAFE  FB800A     ZE W10, W0
00AB00  BE020C     MOV.D W12, W4
00AB02  780109     MOV W9, W2
00AB04  780088     MOV W8, W1
00AB06  07FD4D     RCALL APP_HostMIDIBasicEventHandler
00AB08  A7F000     BTSC W0, #15
00AB0A  EA0000     NEG W0, W0
00AB0C  EA0000     NEG W0, W0
00AB0E  DE004F     LSR W0, #15, W0
00AB10  37001C     BRA .L17
179:                       /* MIDI Class Specific Events ******************************************/
180:                       case EVENT_MIDI_ATTACH:
181:                            LED2_Set_State(LED_STATUS_OFF);
00AB12  200030     MOV #0x3, W0
00AB14  07FF2E     RCALL LED2_Set_State
182:                            usb_host_attached = true;
00AB16  B3C010     MOV.B #0x1, W0
00AB18  B7E856     MOV.B WREG, usb_host_attached
183:                            return APP_HostMIDIBasicEventHandler( address, event, data, size );
00AB1A  FB800A     ZE W10, W0
00AB1C  BE020C     MOV.D W12, W4
00AB1E  780109     MOV W9, W2
00AB20  780088     MOV W8, W1
00AB22  07FD3F     RCALL APP_HostMIDIBasicEventHandler
00AB24  A7F000     BTSC W0, #15
00AB26  EA0000     NEG W0, W0
00AB28  EA0000     NEG W0, W0
00AB2A  DE004F     LSR W0, #15, W0
00AB2C  37000E     BRA .L17
184:                       case EVENT_MIDI_DETACH:
185:                           asm ("RESET");            
00AB2E  FE0000     RESET
186:                       case EVENT_MIDI_TRANSFER_DONE:
187:                           LED1_Set_State(LED_STATUS_BLINK_ONCE);
00AB30  200010     MOV #0x1, W0
00AB32  07FF11     RCALL LED1_Set_State
188:                           return APP_HostMIDIBasicEventHandler( address, event, data, size );
00AB34  FB800A     ZE W10, W0
00AB36  BE020C     MOV.D W12, W4
00AB38  780109     MOV W9, W2
00AB3A  780088     MOV W8, W1
00AB3C  07FD32     RCALL APP_HostMIDIBasicEventHandler
00AB3E  A7F000     BTSC W0, #15
00AB40  EA0000     NEG W0, W0
00AB42  EA0000     NEG W0, W0
00AB44  DE004F     LSR W0, #15, W0
00AB46  370001     BRA .L17
189:                       default:
190:                           break;
191:                   }
192:               
193:                   return false;
00AB48  EB4000     CLR.B W0
194:               
195:               }
00AB4A  BE064F     MOV.D [--W15], W12
00AB4C  78054F     MOV [--W15], W10
00AB4E  BE044F     MOV.D [--W15], W8
00AB50  060000     RETURN
196:               
197:               
198:               /*******************************************************************************
199:                End of File
200:               */
---  /home/sladekm/MPLABXProjects/USB_Device_Host_MIDI.X/src/leds.c  ------------------------------------
1:                 /*******************************************************************************
2:                 Copyright 2016 Microchip Technology Inc. (www.microchip.com)
3:                 
4:                 Licensed under the Apache License, Version 2.0 (the "License");
5:                 you may not use this file except in compliance with the License.
6:                 You may obtain a copy of the License at
7:                 
8:                     http://www.apache.org/licenses/LICENSE-2.0
9:                 
10:                Unless required by applicable law or agreed to in writing, software
11:                distributed under the License is distributed on an "AS IS" BASIS,
12:                WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
13:                See the License for the specific language governing permissions and
14:                limitations under the License.
15:                *******************************************************************************/
16:                
17:                #include <xc.h>
18:                
19:                #include <stdbool.h>
20:                
21:                #include "leds.h"
22:                
23:                /* On MIcrostick II, there is only i LED D6, so I defined it here as LED_D1. */
24:                #define LED_D1_LAT      LATAbits.LATA0     //Overlaps with S3
25:                #define LED_D1_TRIS     TRISAbits.TRISA0
26:                
27:                #define LED_D2_LAT      LATAbits.LATA1     
28:                #define LED_D2_TRIS     TRISAbits.TRISA1
29:                
30:                #define LED_ON  1
31:                #define LED_OFF 0
32:                
33:                #define PIN_INPUT   1
34:                #define PIN_OUTPUT  0
35:                
36:                
37:                
38:                static LED_STATE LED1_State = LED_STATUS_OFF;
39:                static LED_STATE LED2_State = LED_STATUS_BLINK;
40:                
41:                /*********************************************************************
42:                * Function: void LED_On(LED led);
43:                *
44:                * Overview: Turns requested LED on
45:                *
46:                * PreCondition: LED configured via LED_Configure()
47:                *
48:                * Input: LED led - enumeration of the LEDs available in this
49:                *        demo.  They should be meaningful names and not the names of
50:                *        the LEDs on the silkscreen on the board (as the demo code may
51:                *        be ported to other boards).
52:                *         i.e. - LED_On(LED_CONNECTION_DETECTED);
53:                *
54:                * Output: none
55:                *
56:                ********************************************************************/
57:                void LED_On(LED led)
58:                {
59:                    switch(led)
00A8DA  E00000     CP0 W0
00A8DC  320003     BRA Z, .L3
00A8DE  500FE1     SUB W0, #0x1, [W15]
00A8E0  3A0004     BRA NZ, .L1
00A8E2  370002     BRA .L5
60:                    {
61:                        case LED_D1:
62:                            LED_D1_LAT = LED_ON;
00A8E4  A802C4     BSET LATA, #0
63:                            break;
00A8E6  370001     BRA .L1
64:                        case LED_D2:
65:                            LED_D2_LAT = LED_ON;
00A8E8  A822C4     BSET LATA, #1
66:                            break;
67:                
68:                        default:
69:                            break;
70:                    }
71:                }
00A8EA  060000     RETURN
72:                
73:                /*********************************************************************
74:                * Function: void LED_Off(LED led);
75:                *
76:                * Overview: Turns requested LED off
77:                *
78:                * PreCondition: LED configured via LEDConfigure()
79:                *
80:                * Input: LED led - enumeration of the LEDs available in this
81:                *        demo.  They should be meaningful names and not the names of
82:                *        the LEDs on the silkscreen on the board (as the demo code may
83:                *        be ported to other boards).
84:                *         i.e. - LED_Off(LED_CONNECTION_DETECTED);
85:                *
86:                * Output: none
87:                *
88:                ********************************************************************/
89:                void LED_Off(LED led)
90:                {
91:                    switch(led)
00A8EC  E00000     CP0 W0
00A8EE  320003     BRA Z, .L8
00A8F0  500FE1     SUB W0, #0x1, [W15]
00A8F2  3A0004     BRA NZ, .L6
00A8F4  370002     BRA .L10
92:                    {
93:                
94:                        case LED_D1:
95:                            LED_D1_LAT = LED_OFF;
00A8F6  A902C4     BCLR LATA, #0
96:                            break;
00A8F8  370001     BRA .L6
97:                        case LED_D2:
98:                            LED_D2_LAT = LED_OFF;
00A8FA  A922C4     BCLR LATA, #1
99:                            break;
100:               
101:                       default:
102:                           break;
103:                   }
104:               }
00A8FC  060000     RETURN
105:               
106:               /*********************************************************************
107:               * Function: void LED_Toggle(LED led);
108:               *
109:               * Overview: Toggles the state of the requested LED
110:               *
111:               * PreCondition: LED configured via LEDConfigure()
112:               *
113:               * Input: LED led - enumeration of the LEDs available in this
114:               *        demo.  They should be meaningful names and not the names of
115:               *        the LEDs on the silkscreen on the board (as the demo code may
116:               *        be ported to other boards).
117:               *         i.e. - LED_Toggle(LED_CONNECTION_DETECTED);
118:               *
119:               * Output: none
120:               *
121:               ********************************************************************/
122:               void LED_Toggle(LED led)
123:               {
124:                   switch(led)
00A8FE  E00000     CP0 W0
00A900  320003     BRA Z, .L13
00A902  500FE1     SUB W0, #0x1, [W15]
00A904  3A0011     BRA NZ, .L11
00A906  370008     BRA .L15
125:                   {
126:               
127:                       case LED_D1:
128:                           LED_D1_LAT ^= 1;
00A908  801620     MOV LATA, W0
00A90A  EA8000     COM W0, W0
00A90C  600061     AND W0, #0x1, W0
00A90E  801621     MOV LATA, W1
00A910  A10001     BCLR W1, #0
00A912  700081     IOR W0, W1, W1
00A914  881621     MOV W1, LATA
129:                           break;
00A916  370008     BRA .L11
130:                           
131:                       case LED_D2:
132:                           LED_D2_LAT ^= 1;
00A918  D502C4     LSR LATA, WREG
00A91A  EA8000     COM W0, W0
00A91C  600061     AND W0, #0x1, W0
00A91E  400000     ADD W0, W0, W0
00A920  801621     MOV LATA, W1
00A922  A11001     BCLR W1, #1
00A924  700081     IOR W0, W1, W1
00A926  881621     MOV W1, LATA
133:                           break;
134:               
135:                       default:
136:                           break;
137:                   }
138:               }
00A928  060000     RETURN
139:               
140:               /*********************************************************************
141:               * Function: bool LED_Get(LED led);
142:               *
143:               * Overview: Returns the current state of the requested LED
144:               *
145:               * PreCondition: LED configured via LEDConfigure()
146:               *
147:               * Input: LED led - enumeration of the LEDs available in this
148:               *        demo.  They should be meaningful names and not the names of
149:               *        the LEDs on the silkscreen on the board (as the demo code may
150:               *        be ported to other boards).
151:               *         i.e. - LED_Get(LED_CONNECTION_DETECTED);
152:               *
153:               * Output: true if on, false if off
154:               *
155:               ********************************************************************/
156:               bool LED_Get(LED led)
157:               {
158:                   switch(led)
00A92A  E00000     CP0 W0
00A92C  320003     BRA Z, .L18
00A92E  500FE1     SUB W0, #0x1, [W15]
00A930  3A0007     BRA NZ, .L21
00A932  370003     BRA .L22
159:                   {
160:                       
161:                       case LED_D1:
162:                           return ( (LED_D1_LAT == LED_ON) ? true : false );
00A934  801620     MOV LATA, W0
00A936  604061     AND.B W0, #0x1, W0
00A938  370004     BRA .L17
163:               
164:                       case LED_D2:
165:                           return ( (LED_D2_LAT == LED_ON) ? true : false );
00A93A  D502C4     LSR LATA, WREG
00A93C  604061     AND.B W0, #0x1, W0
00A93E  370001     BRA .L17
166:               
167:                       default:
168:                           break;
169:                   }
170:                   return false;
00A940  EB4000     CLR.B W0
171:               }
00A942  060000     RETURN
172:               
173:               /*********************************************************************
174:               * Function: void LED_Enable(LED led);
175:               *
176:               * Overview: Configures the LED for use by the other LED API
177:               *
178:               * PreCondition: none
179:               *
180:               * Input: LED led - enumeration of the LEDs available in this
181:               *        demo.  They should be meaningful names and not the names of
182:               *        the LEDs on the silkscreen on the board (as the demo code may
183:               *        be ported to other boards).
184:               *
185:               * Output: none
186:               *
187:               ********************************************************************/
188:               void LED_Enable(LED led)
189:               {
190:                   switch(led)
00A944  E00000     CP0 W0
00A946  320003     BRA Z, .L25
00A948  500FE1     SUB W0, #0x1, [W15]
00A94A  3A0004     BRA NZ, .L23
00A94C  370002     BRA .L27
191:                   {
192:               
193:                       case LED_D1:
194:                           LED_D1_TRIS = PIN_OUTPUT;
00A94E  A902C0     BCLR TRISA, #0
195:                           break;
00A950  370001     BRA .L23
196:               
197:                       case LED_D2:
198:                           LED_D2_TRIS = PIN_OUTPUT;
00A952  A922C0     BCLR TRISA, #1
199:                           break;
200:               
201:                       default:
202:                           break;
203:                   }
204:               }
00A954  060000     RETURN
205:               
206:               /********************************************************************
207:                * Function: void set_LED1_state(LED_STATE state) 
208:                *
209:                * Overview: Sets status of LED1 state-machine;
210:                * 
211:                * Precondition: none
212:                * 
213:                * Input: none
214:                * 
215:                * Output: none
216:                * 
217:                */
218:               void LED1_Set_State(LED_STATE state){
219:                   LED1_State = state;
00A956  884290     MOV W0, 0x852
220:               }
00A958  060000     RETURN
221:               
222:               /********************************************************************
223:                * Function: void led1_on() 
224:                *
225:                * Overview: Sets status of LED1 state-machine to LED_STATUS_ON;
226:                * 
227:                * Precondition: none
228:                * 
229:                * Input: none
230:                * 
231:                * Output: none
232:                * 
233:                */
234:               void LED1_On(){
235:                   LED1_Set_State(LED_STATUS_ON);
00A95A  200020     MOV #0x2, W0
00A95C  07FFFC     RCALL LED1_Set_State
236:               }
00A95E  060000     RETURN
237:               
238:               /********************************************************************
239:                * Function: void led1_off() 
240:                *
241:                * Overview: Sets status of LED1 state-machine to LED_STATUS_OFF;
242:                * 
243:                * Precondition: none
244:                * 
245:                * Input: none
246:                * 
247:                * Output: none
248:                * 
249:                */
250:               void LED1_Off(){
251:                   LED1_Set_State(LED_STATUS_OFF);
00A960  200030     MOV #0x3, W0
00A962  07FFF9     RCALL LED1_Set_State
252:               }
00A964  060000     RETURN
253:               
254:               /********************************************************************
255:                * Function: void blink_LED1(void);
256:                * 
257:                * Overview: Make LED1 blink;
258:                * 
259:                * Precondition: none
260:                * 
261:                * Input: none
262:                * 
263:                * Output: none
264:                * 
265:                */
266:               void LED1_Blink(void){
267:                   LED1_Set_State(LED_STATUS_BLINK);
00A966  EB0000     CLR W0
00A968  07FFF6     RCALL LED1_Set_State
268:               }
00A96A  060000     RETURN
269:               
270:               /********************************************************************
271:                * Function: void blink_LED1_once(void);
272:                * 
273:                * Overview: Make LED1 blink once;
274:                * 
275:                * Precondition: none
276:                * 
277:                * Input: none
278:                * 
279:                * Output: none
280:                * 
281:                */
282:               void LED1_Blink_Once(void){
283:                   LED1_Set_State(LED_STATUS_BLINK_ONCE);
00A96C  200010     MOV #0x1, W0
00A96E  07FFF3     RCALL LED1_Set_State
284:               }
00A970  060000     RETURN
285:               
286:               /********************************************************************
287:                * Function: void set_LED2_state(LED_STATE state) 
288:                *
289:                * Overview: Sets status of LED2 state-machine;
290:                * 
291:                * Precondition: none
292:                * 
293:                * Input: none
294:                * 
295:                * Output: none
296:                * 
297:                */
298:               void LED2_Set_State(LED_STATE state){
299:                   LED2_State = state;
00A972  887FF0     MOV W0, LED2_State
300:               }
00A974  060000     RETURN
301:               
302:               /********************************************************************
303:                * Function: void led2_on() 
304:                *
305:                * Overview: Sets status of LED2 state-machine to LED_STATUS_ON;
306:                * 
307:                * Precondition: none
308:                * 
309:                * Input: none
310:                * 
311:                * Output: none
312:                * 
313:                */
314:               void LED2_On(){
315:                   LED2_Set_State(LED_STATUS_ON);
00A976  200020     MOV #0x2, W0
00A978  07FFFC     RCALL LED2_Set_State
316:               }
00A97A  060000     RETURN
317:               
318:               /********************************************************************
319:                * Function: void led2_off() 
320:                *
321:                * Overview: Sets status of LED2 state-machine to LED_STATUS_OFF;
322:                * 
323:                * Precondition: none
324:                * 
325:                * Input: none
326:                * 
327:                * Output: none
328:                * 
329:                */
330:               void LED2_Off(){
331:                   LED2_Set_State(LED_STATUS_OFF);
00A97C  200030     MOV #0x3, W0
00A97E  07FFF9     RCALL LED2_Set_State
332:               }
00A980  060000     RETURN
333:               
334:               /********************************************************************
335:                * Function: void blink_LED2(void);
336:                * 
337:                * Overview: Make LED2 blink;
338:                * 
339:                * Precondition: none
340:                * 
341:                * Input: none
342:                * 
343:                * Output: none
344:                * 
345:                */
346:               void LED2_Blink(void){
347:                   LED2_Set_State(LED_STATUS_BLINK);
00A982  EB0000     CLR W0
00A984  07FFF6     RCALL LED2_Set_State
348:               }
00A986  060000     RETURN
349:               
350:               /********************************************************************
351:                * Function: void blink_LED2_once(void);
352:                * 
353:                * Overview: Make LED2 blink once;
354:                * 
355:                * Precondition: none
356:                * 
357:                * Input: none
358:                * 
359:                * Output: none
360:                * 
361:                */
362:               void LED2_Blink_Once(void){
363:                   LED2_Set_State(LED_STATUS_BLINK_ONCE);
00A988  200010     MOV #0x1, W0
00A98A  07FFF3     RCALL LED2_Set_State
364:               }
00A98C  060000     RETURN
365:               
366:               
367:               
368:               void LED1_handler(){
369:                   LED1_StateMachine();
00A9EE  07FFCF     RCALL LED1_StateMachine
370:               }
00A9F0  060000     RETURN
371:               
372:               void LED2_handler(){
373:                   LED2_StateMachine();
00AA50  07FFD0     RCALL LED2_StateMachine
374:               }
00AA52  060000     RETURN
375:               
376:               /*******************************************************************
377:                * Function: void LED1_StateMachine();
378:                * 
379:                * Overview: Changes status of LED1 based on state-machine
380:                * 
381:                * Precondition: none
382:                * 
383:                * Input: none
384:                * 
385:                * Output none
386:                * 
387:                *******************************************************************/
388:               void LED1_StateMachine(){
389:                   static unsigned int led_count=0;
390:                   static LED_STATE current_state = LED_STATUS_OFF;
391:               
392:               //    const int c_led_count = 10;
393:               //    if(led_count == 0)
394:               //        led_count = c_led_count;
395:               //    led_count--;
396:               
397:                   switch (LED1_State){
00A98E  804290     MOV 0x852, W0
00A990  500FE1     SUB W0, #0x1, [W15]
00A992  32001F     BRA Z, .L41
00A994  390015     BRA NC, .L40
00A996  500FE2     SUB W0, #0x2, [W15]
00A998  320003     BRA Z, .L42
00A99A  500FE3     SUB W0, #0x3, [W15]
00A99C  3A0027     BRA NZ, .L38
00A99E  370008     BRA .L46
398:                       case LED_STATUS_ON:
399:                           if (current_state != LED_STATUS_ON){
00A9A0  8042A0     MOV 0x854, W0
00A9A2  500FE2     SUB W0, #0x2, [W15]
00A9A4  320023     BRA Z, .L38
400:                               current_state = LED_STATUS_ON;
00A9A6  200020     MOV #0x2, W0
00A9A8  8842A0     MOV W0, 0x854
401:                               LED_On(LED_D1);
00A9AA  EB0000     CLR W0
00A9AC  07FF96     RCALL LED_On
00A9AE  37001E     BRA .L38
402:                           }
403:                           break;
404:                       case LED_STATUS_OFF:
405:                           if (current_state != LED_STATUS_OFF){
00A9B0  8042A0     MOV 0x854, W0
00A9B2  500FE3     SUB W0, #0x3, [W15]
00A9B4  32001B     BRA Z, .L38
406:                               current_state = LED_STATUS_OFF;
00A9B6  200030     MOV #0x3, W0
00A9B8  8842A0     MOV W0, 0x854
407:                               LED_Off(LED_D1);
00A9BA  EB0000     CLR W0
00A9BC  07FF97     RCALL LED_Off
00A9BE  370016     BRA .L38
408:                           }
409:                           break;
410:                       case LED_STATUS_BLINK:
411:                           if (current_state != LED_STATUS_BLINK){
00A9C0  E20854     CP0 0x854
00A9C2  320004     BRA Z, .L44
412:                               current_state = LED_STATUS_BLINK;
00A9C4  EF2854     CLR 0x854
413:               //                led_count = c_led_count;
414:                               LED_Toggle(LED_D1);
00A9C6  EB0000     CLR W0
00A9C8  07FF9A     RCALL LED_Toggle
415:                               break;
00A9CA  370010     BRA .L38
416:                           }
417:                           if (led_count == 0){
418:                               LED_Toggle(LED_D1);
00A9CC  EB0000     CLR W0
00A9CE  07FF97     RCALL LED_Toggle
00A9D0  37000D     BRA .L38
419:                           }
420:                           break;
421:                       case LED_STATUS_BLINK_ONCE:
422:                           if (current_state != LED_STATUS_BLINK_ONCE){
00A9D2  8042A0     MOV 0x854, W0
00A9D4  500FE1     SUB W0, #0x1, [W15]
00A9D6  320005     BRA Z, .L45
423:                               current_state = LED_STATUS_BLINK_ONCE;
00A9D8  200010     MOV #0x1, W0
00A9DA  8842A0     MOV W0, 0x854
424:               //                led_count = c_led_count;
425:                               LED_On(LED_D1);
00A9DC  EB0000     CLR W0
00A9DE  07FF7D     RCALL LED_On
426:                               break;
00A9E0  370005     BRA .L38
427:                           }
428:                           if (led_count == 0){
429:                               LED1_State = current_state = LED_STATUS_OFF;
00A9E2  200030     MOV #0x3, W0
00A9E4  8842A0     MOV W0, 0x854
00A9E6  884290     MOV W0, 0x852
430:                               LED_Off(LED_D1);
00A9E8  EB0000     CLR W0
00A9EA  07FF80     RCALL LED_Off
431:                           }
432:                           break;
433:                   }
434:                           
435:               }
00A9EC  060000     RETURN
436:               
437:               /*******************************************************************
438:                * Function: void LED2_StateMachine();
439:                * 
440:                * Overview: Changes status of LED2 based on state-machine
441:                * 
442:                * Precondition: none
443:                * 
444:                * Input: none
445:                * 
446:                * Output none
447:                * 
448:                *******************************************************************/
449:               void LED2_StateMachine(){
450:                   static unsigned int led_count=0;
451:                   static LED_STATE current_state = LED_STATUS_OFF;
452:               
453:               //    const int c_led_count = 10;
454:               //    if(led_count == 0)
455:               //        led_count = c_led_count;
456:               //    led_count--;
457:               
458:                   switch (LED2_State){
00A9F2  807FF0     MOV LED2_State, W0
00A9F4  500FE1     SUB W0, #0x1, [W15]
00A9F6  32001F     BRA Z, .L51
00A9F8  390015     BRA NC, .L50
00A9FA  500FE2     SUB W0, #0x2, [W15]
00A9FC  320003     BRA Z, .L52
00A9FE  500FE3     SUB W0, #0x3, [W15]
00AA00  3A0026     BRA NZ, .L48
00AA02  370008     BRA .L56
459:                       case LED_STATUS_ON:
460:                           if (current_state != LED_STATUS_ON){
00AA04  804280     MOV 0x850, W0
00AA06  500FE2     SUB W0, #0x2, [W15]
00AA08  320022     BRA Z, .L48
461:                               current_state = LED_STATUS_ON;
00AA0A  200020     MOV #0x2, W0
00AA0C  884280     MOV W0, 0x850
462:                               LED_On(LED_D2);
00AA0E  200010     MOV #0x1, W0
00AA10  07FF64     RCALL LED_On
00AA12  37001D     BRA .L48
463:                           }
464:                           break;
465:                       case LED_STATUS_OFF:
466:                           if (current_state != LED_STATUS_OFF){
00AA14  804280     MOV 0x850, W0
00AA16  500FE3     SUB W0, #0x3, [W15]
00AA18  32001A     BRA Z, .L48
467:                               current_state = LED_STATUS_OFF;
00AA1A  200030     MOV #0x3, W0
00AA1C  884280     MOV W0, 0x850
468:                               LED_Off(LED_D2);
00AA1E  200010     MOV #0x1, W0
00AA20  07FF65     RCALL LED_Off
00AA22  370015     BRA .L48
469:                           }
470:                           break;
471:                       case LED_STATUS_BLINK:
472:                           if (current_state != LED_STATUS_BLINK){
00AA24  E20850     CP0 0x850
00AA26  320004     BRA Z, .L54
473:                               current_state = LED_STATUS_BLINK;
00AA28  EF2850     CLR 0x850
474:               //                led_count = c_led_count;
475:                               LED_Toggle(LED_D2);
00AA2A  200010     MOV #0x1, W0
00AA2C  07FF68     RCALL LED_Toggle
476:                               break;
00AA2E  37000F     BRA .L48
477:                           }
478:                           if (led_count == 0){
479:                               LED_Toggle(LED_D2);
00AA30  200010     MOV #0x1, W0
00AA32  07FF65     RCALL LED_Toggle
00AA34  37000C     BRA .L48
480:                           }
481:                           break;
482:                       case LED_STATUS_BLINK_ONCE:
483:                           if (current_state != LED_STATUS_BLINK_ONCE){
00AA36  804280     MOV 0x850, W0
00AA38  500FE1     SUB W0, #0x1, [W15]
00AA3A  320004     BRA Z, .L55
484:                               current_state = LED_STATUS_BLINK_ONCE;
00AA3C  200010     MOV #0x1, W0
00AA3E  884280     MOV W0, 0x850
485:               //                led_count = c_led_count;
486:                               LED_On(LED_D2);
00AA40  07FF4C     RCALL LED_On
487:                               break;
00AA42  370005     BRA .L48
488:                           }
489:                           if (led_count == 0){
490:                               LED2_State = current_state = LED_STATUS_OFF;
00AA44  200030     MOV #0x3, W0
00AA46  884280     MOV W0, 0x850
00AA48  887FF0     MOV W0, LED2_State
491:                               LED_Off(LED_D2);
00AA4A  200010     MOV #0x1, W0
00AA4C  07FF4F     RCALL LED_Off
492:                           }
493:                           break;
494:                   }
495:                           
496:               }
00AA4E  060000     RETURN
---  /home/sladekm/MPLABXProjects/USB_Device_Host_MIDI.X/src/app_host_midi_basic.c  ---------------------
1:                 /*******************************************************************************
2:                 Copyright 2016 Microchip Technology Inc. (www.microchip.com)
3:                 
4:                 Licensed under the Apache License, Version 2.0 (the "License");
5:                 you may not use this file except in compliance with the License.
6:                 You may obtain a copy of the License at
7:                 
8:                     http://www.apache.org/licenses/LICENSE-2.0
9:                 
10:                Unless required by applicable law or agreed to in writing, software
11:                distributed under the License is distributed on an "AS IS" BASIS,
12:                WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
13:                See the License for the specific language governing permissions and
14:                limitations under the License.
15:                
16:                To request to license the code under the MLA license (www.microchip.com/mla_license), 
17:                please contact mla_licensing@microchip.com
18:                *******************************************************************************/
19:                #include <stdlib.h>
20:                #include "system.h"
21:                #include "usb.h"
22:                #include "usb_host_midi.h"
23:                #include "usb_host_local.h"
24:                #include "usb_common.h"
25:                #include <string.h>
26:                #include <stdio.h>
27:                #include <stdbool.h>
28:                
29:                // *****************************************************************************
30:                // *****************************************************************************
31:                // Internal Function Prototypes
32:                // *****************************************************************************
33:                // *****************************************************************************
34:                void DBG_LED();
35:                //void MIDI_Host_OutJackTasks(void);
36:                void MIDI_InJackTasks(void);
37:                
38:                // *****************************************************************************
39:                // *****************************************************************************
40:                // Macros
41:                // *****************************************************************************
42:                // *****************************************************************************
43:                
44:                // *****************************************************************************
45:                // *****************************************************************************
46:                // Constants
47:                // *****************************************************************************
48:                // *****************************************************************************
49:                
50:                // Application specific
51:                #define MIDI_USB_BUFFER_SIZE                (uint8_t)4
52:                #define NUM_MIDI_PKTS_IN_USB_PKT            (uint8_t)1
53:                
54:                // *****************************************************************************
55:                // *****************************************************************************
56:                // Type definitions
57:                // *****************************************************************************
58:                // *****************************************************************************
59:                typedef enum _APP_STATE
60:                {
61:                    DEVICE_NOT_CONNECTED,
62:                    DEVICE_READY,
63:                    ERROR_REPORTED      /* need to add application states for data interface */
64:                } APP_STATE;
65:                
66:                typedef enum
67:                {
68:                    TX_DATA = 0,
69:                    TX_DATA_WAIT,
70:                    RX_DATA,
71:                    RX_DATA_WAIT,
72:                    TX_REAL_TIME_DATA,
73:                    TX_REAL_TIME_DATA_WAIT
74:                } TX_RX_STATE;
75:                
76:                typedef enum
77:                {
78:                    STATE_WAIT_STATUS_BYTE,
79:                    STATE_WAITING_BYTES
80:                } STATE_WAIT;
81:                
82:                typedef struct
83:                {
84:                    TX_RX_STATE             TransferState;      // The transfer state of the endpoint
85:                    uint8_t                 numOfMIDIPackets;   // Each USB Packet sent from a device has the possibility of holding more than one MIDI packet,
86:                                                                //  so this is to keep track of how many MIDI packets are within a USB packet (between 1 and 16, or 4 and 64 bytes)
87:                    USB_AUDIO_MIDI_PACKET*  bufferStart;        // The 2D buffer for the endpoint. There are MIDI_USB_BUFFER_SIZE USB buffers that are filled with numOfMIDIPackets
88:                                                                //  MIDI packets. This allows for MIDI_USB_BUFFER_SIZE USB packets to be saved, with a possibility of up to 
89:                                                                //  numOfMIDIPackets MID packets within each USB packet.
90:                    USB_AUDIO_MIDI_PACKET*  pBufReadLocation;   // Pointer to USB packet that is being read from
91:                    USB_AUDIO_MIDI_PACKET*  pBufWriteLocation;  // Pointer to USB packet that is being written to
92:                }ENDPOINT_BUFFER;
93:                
94:                
95:                // *****************************************************************************
96:                // *****************************************************************************
97:                // Local Variables
98:                // *****************************************************************************
99:                // *****************************************************************************
100:               volatile APP_STATE  midiState;
101:               
102:               MIDI_DEVICE *deviceHandle;
103:               
104:               bool buttonReleased;
105:               
106:               // *****************************************************************************
107:               // *****************************************************************************
108:               // Global Variables
109:               // *****************************************************************************
110:               // *****************************************************************************
111:               ENDPOINT_BUFFER*    endpointBuffers;    // A pointer to a dynamically allocated array that contains a buffer for each endpoint
112:               
113:               // MIDI packet used to translate MIDI UART to MIDI USB for real time messages, with flag, and buffer
114:               USB_AUDIO_MIDI_PACKET   UARTRealTimeToUSB;
115:               USB_AUDIO_MIDI_PACKET   UARTRealTimeToUSBBuffer;
116:               bool                    UARTRealTimePacketTranslated;
117:               
118:               bool        somethingToSend;
119:               
120:               uint16_t        NumGets;
121:               uint16_t        NumSends;
122:               
123:               
124:               
125:               /*********************************************************************
126:               * Function: void APP_HostMIDIBasicInitialize(void);
127:               *
128:               * Overview: Initializes the demo code
129:               *
130:               * PreCondition: None
131:               *
132:               * Input: None
133:               *
134:               * Output: None
135:               *
136:               ********************************************************************/
137:               void APP_HostMIDIBasicInitialize()
138:               {
139:                   midiState = DEVICE_NOT_CONNECTED;
00A464  EF2FD4     CLR midiState
140:                   
141:                   // Set device handle to NULL
142:                   deviceHandle = NULL;
00A466  EF2FD6     CLR deviceHandle
143:                   
144:                   UARTRealTimePacketTranslated = false;
00A468  EF6FE4     CLR.B UARTRealTimePacketTranslated
145:               
146:                   NumGets = 0;
00A46A  EF2FE6     CLR NumGets
147:                   NumSends = 0;
00A46C  EF2FE8     CLR NumSends
148:               
149:               }
00A46E  060000     RETURN
150:               
151:               /*********************************************************************
152:               * Function: void APP_HostMIDIBasicTasks(void);
153:               *
154:               * Overview: Keeps the demo running.
155:               *
156:               * PreCondition: The demo should have been initialized via
157:               *   the APP_HostMIDIBasicInitialize()
158:               *
159:               * Input: None
160:               *
161:               * Output: None
162:               *
163:               ********************************************************************/
164:               void APP_HostMIDIBasicTasks()
165:               {
00A470  BE9F88     MOV.D W8, [W15++]
00A472  BE9F8A     MOV.D W10, [W15++]
166:                   uint8_t numOfBytesRcvd;
167:                   uint8_t currentEndpoint;
168:               
169:                   numOfBytesRcvd = 0;
170:                   
171:                   switch(midiState)
00A474  807EA0     MOV midiState, W0
00A476  500FE1     SUB W0, #0x1, [W15]
00A478  3A0091     BRA NZ, .L2
172:                   {
173:                       case DEVICE_NOT_CONNECTED:
174:                           break;
175:                       case DEVICE_READY:
176:                           //-----------------------------------------------------------------------------
177:                           //Check if we received any RX data from the MIDI device attached (MIDI In port)
178:                           //-----------------------------------------------------------------------------
179:                           MIDI_InJackTasks();
00A47A  07FEED     RCALL MIDI_InJackTasks
180:               
181:                           //-----------------------------------------------------------------------------
182:                           //Check if we received any RX data from the MIDI device attached (MIDI Out port)
183:                           //-----------------------------------------------------------------------------
184:               //            MIDI_Host_OutJackTasks();
185:                
186:                           for(currentEndpoint = 0; currentEndpoint < USBHostMIDINumberOfEndpoints(deviceHandle); currentEndpoint++)
00A47C  807EB4     MOV deviceHandle, W4
00A47E  904024     MOV.B [W4+2], W0
00A480  E00400     CP0.B W0
00A482  32008C     BRA Z, .L2
00A484  EB4400     CLR.B W8
00A592  E84408     INC.B W8, W8
00A594  807EB4     MOV deviceHandle, W4
00A596  904024     MOV.B [W4+2], W0
00A598  504F88     SUB.B W0, W8, [W15]
00A59A  3EFF77     BRA GTU, .L14
187:                           {
188:                               switch(endpointBuffers[currentEndpoint].TransferState)
00A48A  FB8088     ZE W8, W1
00A48C  784008     MOV.B W8, W0
00A48E  B3C0A2     MOV.B #0xA, W2
00A490  BC4004     MUL.B WREG2
00A492  780482     MOV W2, W9
00A494  780002     MOV W2, W0
00A496  B40FDA     ADD endpointBuffers, WREG
00A498  780180     MOV W0, W3
00A49A  780113     MOV [W3], W2
00A49C  510FE2     SUB W2, #0x2, [W15]
00A49E  32000C     BRA Z, .L8
00A4A0  3E0005     BRA GTU, .L12
00A4A2  E00002     CP0 W2
00A4A4  32001E     BRA Z, .L6
00A4A6  510FE1     SUB W2, #0x1, [W15]
00A4A8  3A0074     BRA NZ, .L5
00A4AA  370057     BRA .L16
00A4AC  510FE4     SUB W2, #0x4, [W15]
00A4AE  320034     BRA Z, .L10
00A4B0  39003D     BRA NC, .L9
00A4B2  510FE5     SUB W2, #0x5, [W15]
00A4B4  3A006E     BRA NZ, .L5
00A4B6  370067     BRA .L17
189:                               {
190:                                   /** Send IN Packet: Loops here until successfuly sends packet **/
191:                                   case RX_DATA:
192:                                       // Then clear current endpoint's buffer, and try to read
193:                                       memset(endpointBuffers[currentEndpoint].pBufWriteLocation, 0x00, endpointBuffers[currentEndpoint].numOfMIDIPackets * sizeof(USB_AUDIO_MIDI_PACKET));
00A4B8  904123     MOV.B [W3+2], W2
00A4BA  FB8102     ZE W2, W2
00A4BC  DD1142     SL W2, #2, W2
00A4BE  900043     MOV [W3+8], W0
00A4C0  EB0080     CLR W1
00A4C2  07B006     RCALL 0x4D0
194:                                       if(USBHostMIDIRead(deviceHandle, currentEndpoint, endpointBuffers[currentEndpoint].pBufWriteLocation, endpointBuffers[currentEndpoint].numOfMIDIPackets * sizeof(USB_AUDIO_MIDI_PACKET) ) == USB_SUCCESS )
00A4C4  780009     MOV W9, W0
00A4C6  B40FDA     ADD endpointBuffers, WREG
00A4C8  780080     MOV W0, W1
00A4CA  9041A1     MOV.B [W1+2], W3
00A4CC  FB8183     ZE W3, W3
00A4CE  900141     MOV [W1+8], W2
00A4D0  DD19C2     SL W3, #2, W3
00A4D2  784088     MOV.B W8, W1
00A4D4  807EB0     MOV deviceHandle, W0
00A4D6  0701DF     RCALL USBHostMIDIRead
00A4D8  E00400     CP0.B W0
00A4DA  3A005B     BRA NZ, .L5
195:                                       {
196:                                           // If successful, then update the transfer state to wait for the transaction to complete    
197:               
198:                                           endpointBuffers[currentEndpoint].TransferState = RX_DATA_WAIT;
00A486  20003A     MOV #0x3, W10
00A4DC  807ED0     MOV endpointBuffers, W0
00A4DE  7CB00A     MOV W10, [W0+W9]
00A4E0  370058     BRA .L5
199:                                       }
200:                                       break;
201:               
202:                                   /** Send OUT Packet: Loops here until successfuly sends packet **/
203:                                   case TX_DATA:
204:                                       // See if there is a real-time message to send. These have a higher priority
205:                                       if(UARTRealTimePacketTranslated == true)
00A4E2  E24FE4     CP0.B UARTRealTimePacketTranslated
00A4E4  320009     BRA Z, .L13
206:                                       {
207:                                           // If so, then clear the flag and write the buffer to the transmit packet
208:                                           UARTRealTimeToUSB.Val = UARTRealTimeToUSBBuffer.Val;
00A4E6  807F00     MOV UARTRealTimeToUSBBuffer, W0
00A4E8  807F11     MOV 0xFE2, W1
00A4EA  887EE0     MOV W0, UARTRealTimeToUSB
00A4EC  887EF1     MOV W1, 0xFDE
209:                                           UARTRealTimePacketTranslated = true;
00A4EE  B3C010     MOV.B #0x1, W0
00A4F0  B7EFE4     MOV.B WREG, UARTRealTimePacketTranslated
210:                                           
211:                                           // And change state to that case, so next time it will get transmitted
212:                                           endpointBuffers[currentEndpoint].TransferState = TX_REAL_TIME_DATA;
00A4F2  200041     MOV #0x4, W1
00A4F4  780981     MOV W1, [W3]
00A4F6  37004D     BRA .L5
213:                                       }
214:                                           
215:                                       // Otherwise, try to send if there's something in the buffer
216:                                       else if(endpointBuffers[currentEndpoint].pBufReadLocation != endpointBuffers[currentEndpoint].pBufWriteLocation)
00A4F8  900133     MOV [W3+6], W2
00A4FA  9000C3     MOV [W3+8], W1
00A4FC  510F81     SUB W2, W1, [W15]
00A4FE  320049     BRA Z, .L5
217:                                       {
218:                                           if(USBHostMIDIWrite(deviceHandle, currentEndpoint, endpointBuffers[currentEndpoint].pBufReadLocation, endpointBuffers[currentEndpoint].numOfMIDIPackets * sizeof(USB_AUDIO_MIDI_PACKET)) == USB_SUCCESS)
00A500  9041A3     MOV.B [W3+2], W3
00A502  FB8183     ZE W3, W3
00A504  DD19C2     SL W3, #2, W3
00A506  784088     MOV.B W8, W1
00A508  780004     MOV W4, W0
00A50A  0701D6     RCALL USBHostMIDIWrite
00A50C  E00400     CP0.B W0
00A50E  3A0041     BRA NZ, .L5
219:                                           {
220:                                               // Update the transfer state to wait for the transaction to complete    
221:                                               endpointBuffers[currentEndpoint].TransferState = TX_DATA_WAIT;
00A510  200011     MOV #0x1, W1
00A512  807ED0     MOV endpointBuffers, W0
00A514  7CB001     MOV W1, [W0+W9]
00A516  37003D     BRA .L5
222:                                           }
223:                                       }    
224:                                       break;
225:                                       
226:                                   case TX_REAL_TIME_DATA:
227:                                       // Try to send the real-time data
228:                                       if(USBHostMIDIWrite(deviceHandle, currentEndpoint, &UARTRealTimeToUSB, sizeof(USB_AUDIO_MIDI_PACKET)) == USB_SUCCESS)
00A518  200043     MOV #0x4, W3
00A51A  20FDC2     MOV #0xFDC, W2
00A51C  784088     MOV.B W8, W1
00A51E  780004     MOV W4, W0
00A520  0701CB     RCALL USBHostMIDIWrite
00A522  E00400     CP0.B W0
00A524  3A0036     BRA NZ, .L5
229:                                       {
230:                                           endpointBuffers[currentEndpoint].TransferState = TX_REAL_TIME_DATA_WAIT;
00A488  20005B     MOV #0x5, W11
00A526  807ED0     MOV endpointBuffers, W0
00A528  7CB00B     MOV W11, [W0+W9]
00A52A  370033     BRA .L5
231:                                       }
232:                                       break;
233:                                   
234:                                   /** Get IN Data: Loops here for this endpoint until successfully receives data packet **/
235:                                   case RX_DATA_WAIT:
236:                                       // If the transfer is complete
237:                                       if(!USBHostMIDITransferIsBusy(deviceHandle, currentEndpoint))
00A52C  900124     MOV [W4+4], W2
00A52E  DD08C2     SL W1, #2, W1
00A530  78C0E2     MOV.B [W2+W1], W1
00A532  E00401     CP0.B W1
00A534  3A002E     BRA NZ, .L5
238:                                       {
239:                                           // Update the transfer state to try and receive another packet
240:                                           endpointBuffers[currentEndpoint].TransferState = RX_DATA;
00A536  200021     MOV #0x2, W1
00A538  780981     MOV W1, [W3]
241:                                           
242:                                           // Then increment the write location pointer to the next USB buffer
243:                                           endpointBuffers[currentEndpoint].pBufWriteLocation += endpointBuffers[currentEndpoint].numOfMIDIPackets;
00A53A  780009     MOV W9, W0
00A53C  B40FDA     ADD endpointBuffers, WREG
00A53E  780480     MOV W0, W9
00A540  9040A9     MOV.B [W9+2], W1
00A542  FB8081     ZE W1, W1
00A544  DD08C2     SL W1, #2, W1
00A546  900149     MOV [W9+8], W2
00A548  410101     ADD W2, W1, W2
00A54A  9804C2     MOV W2, [W9+8]
244:                                           
245:                                           // Check to see if we've gotten to the end of the USB buffer array
246:                                           if(endpointBuffers[currentEndpoint].pBufWriteLocation - endpointBuffers[currentEndpoint].bufferStart
00A54C  9001A9     MOV [W9+4], W3
00A54E  510103     SUB W2, W3, W2
00A550  DE9142     ASR W2, #2, W2
00A552  510F81     SUB W2, W1, [W15]
00A554  35001E     BRA LT, .L5
247:                                           >= endpointBuffers[currentEndpoint].numOfMIDIPackets * MIDI_USB_BUFFER_SIZE)
248:                                           {
249:                                               // If so, then loop it back to the beginning of the array
250:                                               endpointBuffers[currentEndpoint].pBufWriteLocation = endpointBuffers[currentEndpoint].bufferStart;
00A556  9804C3     MOV W3, [W9+8]
00A558  37001C     BRA .L5
251:                                           }
252:                                       }
253:                                       break;
254:                                   
255:                                   /** Send OUT Data: Loops here for this endpoint until successfully sends data packet **/
256:                                   case TX_DATA_WAIT:
257:                                       // If the transfer is complete
258:                                       if(!USBHostMIDITransferIsBusy(deviceHandle, currentEndpoint))
00A55A  900124     MOV [W4+4], W2
00A55C  DD08C2     SL W1, #2, W1
00A55E  78C0E2     MOV.B [W2+W1], W1
00A560  E00401     CP0.B W1
00A562  3A0017     BRA NZ, .L5
259:                                       {
260:                                           // Update the transfer state to try and send another packet
261:                                           endpointBuffers[currentEndpoint].TransferState = TX_DATA;
00A564  EB0980     CLR [W3]
262:                                           
263:                                           // Then increment the read location pointer to the next USB buffer
264:                                           endpointBuffers[currentEndpoint].pBufReadLocation += endpointBuffers[currentEndpoint].numOfMIDIPackets;
00A566  780009     MOV W9, W0
00A568  B40FDA     ADD endpointBuffers, WREG
00A56A  780480     MOV W0, W9
00A56C  9040A9     MOV.B [W9+2], W1
00A56E  FB8081     ZE W1, W1
00A570  DD08C2     SL W1, #2, W1
00A572  900139     MOV [W9+6], W2
00A574  410101     ADD W2, W1, W2
00A576  9804B2     MOV W2, [W9+6]
265:                                               
266:                                           // Check to see if we've gotten to the end of the USB buffer array
267:                                           if(endpointBuffers[currentEndpoint].pBufReadLocation - endpointBuffers[currentEndpoint].bufferStart
00A578  9001A9     MOV [W9+4], W3
00A57A  510103     SUB W2, W3, W2
00A57C  DE9142     ASR W2, #2, W2
00A57E  510F81     SUB W2, W1, [W15]
00A580  350008     BRA LT, .L5
268:                                           >= endpointBuffers[currentEndpoint].numOfMIDIPackets * MIDI_USB_BUFFER_SIZE)
269:                                           {
270:                                               // If so, then loop it back to the beginning of the array
271:                                               endpointBuffers[currentEndpoint].pBufReadLocation = endpointBuffers[currentEndpoint].bufferStart;
00A582  9804B3     MOV W3, [W9+6]
00A584  370006     BRA .L5
272:                                           }
273:                                       }        
274:                                       break;
275:                                       
276:                                   case TX_REAL_TIME_DATA_WAIT:
277:                                       // If the transfer is complete
278:                                       if(!USBHostMIDITransferIsBusy(deviceHandle, currentEndpoint))
00A586  900124     MOV [W4+4], W2
00A588  DD08C2     SL W1, #2, W1
00A58A  78C0E2     MOV.B [W2+W1], W1
00A58C  E00401     CP0.B W1
00A58E  3A0001     BRA NZ, .L5
279:                                       {
280:                                           // Update the transfer state back to trying to send another packet
281:                                           endpointBuffers[currentEndpoint].TransferState = TX_DATA;
00A590  EB0980     CLR [W3]
282:                                       }
283:                                       break;    
284:                               }
285:                           }    
286:                       default:
287:                           break;
288:                   }
289:               
290:               }
00A59C  BE054F     MOV.D [--W15], W10
00A59E  BE044F     MOV.D [--W15], W8
00A5A0  060000     RETURN
291:               
292:               
293:               /*********************************************************************
294:               * Function: bool APP_HostMIDIBasicEventHandler( uint8_t address, USB_EVENT event, void *data, uint32_t size );
295:               *
296:               * Overview: Handles USB events for the USB host MIDI demo
297:               *
298:               * PreCondition: None
299:               *
300:               * Input: uint8_t - address of the device causing the event
301:               *        USB_EVENT - the event that occurred
302:               *        void* - data associated with the event
303:               *        uint32_t - size of the data for the event
304:               *
305:               * Output: None
306:               *
307:               ********************************************************************/
308:               bool APP_HostMIDIBasicEventHandler( uint8_t address, USB_EVENT event, void *data, uint32_t size )
309:               {
00A5A2  BE9F88     MOV.D W8, [W15++]
00A5A4  BE9F8A     MOV.D W10, [W15++]
310:               
311:                   uint8_t currentEndpoint;
312:                   ENDPOINT_DIRECTION direction;
313:                   
314:                   switch((int)event)
00A5A6  200720     MOV #0x72, W0
00A5A8  508F80     SUB W1, W0, [W15]
00A5AA  3C000B     BRA GT, .L23
00A5AC  500066     SUB W0, #0x6, W0
00A5AE  508F80     SUB W1, W0, [W15]
00A5B0  3D0016     BRA GE, .L20
00A5B2  500067     SUB W0, #0x7, W0
00A5B4  508F80     SUB W1, W0, [W15]
00A5B6  320013     BRA Z, .L20
00A5B8  350070     BRA LT, .L31
00A5BA  B10691     SUB #0x69, W1
00A5BC  508FE1     SUB W1, #0x1, [W15]
00A5BE  3E006D     BRA GTU, .L31
00A5C0  37000E     BRA .L20
00A5C2  203E80     MOV #0x3E8, W0
00A5C4  508F80     SUB W1, W0, [W15]
00A5C6  320014     BRA Z, .L21
00A5C8  3C0004     BRA GT, .L24
00A5CA  B10741     SUB #0x74, W1
00A5CC  508FE1     SUB W1, #0x1, [W15]
00A5CE  3E0065     BRA GTU, .L31
00A5D0  370006     BRA .L20
00A5D2  203E90     MOV #0x3E9, W0
00A5D4  508F80     SUB W1, W0, [W15]
00A5D6  320005     BRA Z, .L22
00A5D8  27FFF0     MOV #0x7FFF, W0
00A5DA  508F80     SUB W1, W0, [W15]
00A5DC  3A005E     BRA NZ, .L31
315:                   {
316:                       case EVENT_MIDI_ATTACH:
317:               
318:                           deviceHandle = data;
00A5F0  780402     MOV W2, W8
00A5F2  887EB8     MOV W8, deviceHandle
319:                           midiState = DEVICE_READY;
00A5F4  200010     MOV #0x1, W0
00A5F6  887EA0     MOV W0, midiState
320:                           
321:                           endpointBuffers = malloc( sizeof(ENDPOINT_BUFFER) * USBHostMIDINumberOfEndpoints(deviceHandle) );
00A5F8  9044A8     MOV.B [W8+2], W9
00A5FA  FB8009     ZE W9, W0
00A5FC  B9006A     MUL.SU W0, #10, W0
00A5FE  07AF29     RCALL 0x452
00A600  887ED0     MOV W0, endpointBuffers
322:                           
323:                           for( currentEndpoint = 0; currentEndpoint < USBHostMIDINumberOfEndpoints(deviceHandle); currentEndpoint++ )
00A604  E00409     CP0.B W9
00A606  32004A     BRA Z, .L19
00A608  EB4480     CLR.B W9
00A656  E84489     INC.B W9, W9
00A658  807EB8     MOV deviceHandle, W8
00A65A  904028     MOV.B [W8+2], W0
00A65C  504F89     SUB.B W0, W9, [W15]
00A65E  3EFFD7     BRA GTU, .L30
324:                           {
325:                               direction = USBHostMIDIEndpointDirection(deviceHandle, currentEndpoint);
00A60E  FB8089     ZE W9, W1
00A610  DD0842     SL W1, #2, W0
00A612  900128     MOV [W8+4], W2
00A614  410100     ADD W2, W0, W2
00A616  904012     MOV.B [W2+1], W0
00A618  FB0000     SE W0, W0
00A61A  DE004F     LSR W0, #15, W0
326:                               // For OUT endpoints
327:                               if(direction == OUT)
00A61C  3A0007     BRA NZ, .L27
328:                               {   
329:                                   // We only want to send NUM_MIDI_PKTS_IN_USB_PKT MIDI packet per USB packet
330:                                   endpointBuffers[currentEndpoint].numOfMIDIPackets = NUM_MIDI_PKTS_IN_USB_PKT;
00A60C  784500     MOV.B W0, W10
00A61E  B9096A     MUL.SU W1, #10, W2
00A620  780002     MOV W2, W0
00A622  B40FDA     ADD endpointBuffers, WREG
00A624  780100     MOV W0, W2
00A626  98412A     MOV.B W10, [W2+2]
331:                                   
332:                                   // And we want to start it off transmitting data
333:                                   endpointBuffers[currentEndpoint].TransferState = TX_DATA;
00A628  EB0900     CLR [W2]
00A62A  37000A     BRA .L28
334:                               }
335:                               // For IN endpoints
336:                               else if (direction == IN)
00A62C  500FE1     SUB W0, #0x1, [W15]
00A62E  3A0013     BRA NZ, .L29
337:                               {
338:                                   // We will accept however many will fit inside the maximum USB packet size
339:                                   endpointBuffers[currentEndpoint].numOfMIDIPackets = USBHostMIDISizeOfEndpoint(deviceHandle, currentEndpoint) / sizeof(USB_AUDIO_MIDI_PACKET);
00A630  B90A6A     MUL.SU W1, #10, W4
00A632  780004     MOV W4, W0
00A634  B40FDA     ADD endpointBuffers, WREG
00A636  780200     MOV W0, W4
00A638  900112     MOV [W2+2], W2
00A63A  DE1142     LSR W2, #2, W2
00A63C  984222     MOV.B W2, [W4+2]
340:                                   
341:                                   // And we want to start it off trying to read data
342:                                   endpointBuffers[currentEndpoint].TransferState = RX_DATA;
00A60A  20002B     MOV #0x2, W11
00A63E  780A0B     MOV W11, [W4]
343:                               }
344:                               else
345:                               {
346:                                   continue;
347:                               }
348:                               
349:                               // Allocate the 2D buffer, and keep track of the write and read locations
350:                               endpointBuffers[currentEndpoint].bufferStart = malloc( sizeof(USB_AUDIO_MIDI_PACKET) * endpointBuffers[currentEndpoint].numOfMIDIPackets * MIDI_USB_BUFFER_SIZE );
00A640  B9096A     MUL.SU W1, #10, W2
00A642  780002     MOV W2, W0
00A644  B40FDA     ADD endpointBuffers, WREG
00A646  780400     MOV W0, W8
00A648  904028     MOV.B [W8+2], W0
00A64A  FB8000     ZE W0, W0
00A64C  DD0044     SL W0, #4, W0
00A64E  07AF01     RCALL 0x452
00A650  980420     MOV W0, [W8+4]
351:                               endpointBuffers[currentEndpoint].pBufReadLocation = endpointBuffers[currentEndpoint].bufferStart;
00A652  980430     MOV W0, [W8+6]
352:                               endpointBuffers[currentEndpoint].pBufWriteLocation = endpointBuffers[currentEndpoint].bufferStart;
00A654  980440     MOV W0, [W8+8]
353:                           }    
354:                           
355:                           // Testing Purposes
356:               //            endpointOne = &endpointBuffers[0];
357:               //            endpointTwo = endpointBuffers+1;
358:                           
359:                           //UART2PrintString( "MIDI demo device attached - event, deviceAddress=" );
360:                           //UART2PutDec( address );
361:                           //UART2PrintString( "\r\n" );
362:                           //UART2PrintString( "\r\n" );
363:               
364:                           return true;
00A602  B3C010     MOV.B #0x1, W0
00A660  B3C010     MOV.B #0x1, W0
00A662  37001C     BRA .L19
365:                       case EVENT_MIDI_DETACH:
366:                           for( currentEndpoint = 0; currentEndpoint < USBHostMIDINumberOfEndpoints(deviceHandle); currentEndpoint++ )
00A5E2  807EB0     MOV deviceHandle, W0
00A5E4  904020     MOV.B [W0+2], W0
00A5E6  EB4400     CLR.B W8
00A5EA  E00400     CP0.B W0
00A5EC  3A003B     BRA NZ, .L34
00A5EE  37004E     BRA .L26
00A682  E84408     INC.B W8, W8
00A684  807EB0     MOV deviceHandle, W0
00A686  904020     MOV.B [W0+2], W0
00A688  504F88     SUB.B W0, W8, [W15]
00A68A  3EFFEC     BRA GTU, .L34
367:                           {
368:                               free(endpointBuffers[currentEndpoint].bufferStart);
00A664  784008     MOV.B W8, W0
00A666  B3C0A2     MOV.B #0xA, W2
00A668  BC4004     MUL.B WREG2
00A66A  780502     MOV W2, W10
00A66C  780002     MOV W2, W0
00A66E  B40FDA     ADD endpointBuffers, WREG
00A670  780080     MOV W0, W1
00A672  900021     MOV [W1+4], W0
00A674  07AE89     RCALL 0x388
369:                               endpointBuffers[currentEndpoint].bufferStart = NULL;
00A5E8  EB0480     CLR W9
00A676  78000A     MOV W10, W0
00A678  B40FDA     ADD endpointBuffers, WREG
00A67A  780500     MOV W0, W10
00A67C  980529     MOV W9, [W10+4]
370:                               endpointBuffers[currentEndpoint].pBufReadLocation = NULL;
00A67E  980539     MOV W9, [W10+6]
371:                               endpointBuffers[currentEndpoint].pBufWriteLocation = NULL;
00A680  980549     MOV W9, [W10+8]
372:                           }
373:                           
374:                           free(endpointBuffers);
00A68C  807ED0     MOV endpointBuffers, W0
00A68E  07AE7C     RCALL 0x388
375:                           endpointBuffers = NULL;
00A690  EF2FDA     CLR endpointBuffers
376:                           
377:                           deviceHandle = NULL;
00A692  EF2FD6     CLR deviceHandle
378:                           midiState = DEVICE_NOT_CONNECTED;
00A694  EF2FD4     CLR midiState
379:                           return true;
00A696  B3C010     MOV.B #0x1, W0
00A698  370001     BRA .L19
380:                           
381:                           
382:                       case EVENT_MIDI_TRANSFER_DONE:   // The main state machine will poll the driver.
383:                           break;
384:                       case EVENT_TRANSFER:
385:                       case EVENT_VBUS_REQUEST_POWER:
386:                       case EVENT_VBUS_RELEASE_POWER:
387:                       case EVENT_HUB_ATTACH:
388:                       case EVENT_UNSUPPORTED_DEVICE:
389:                       case EVENT_CANNOT_ENUMERATE:
390:                       case EVENT_CLIENT_INIT_ERROR:
391:                       case EVENT_OUT_OF_MEMORY:
392:                       case EVENT_UNSPECIFIED_ERROR:   // This should never be generated.
393:                       case EVENT_SUSPEND:
394:                       case EVENT_DETACH:
395:                       case EVENT_RESUME:
396:                       case EVENT_BUS_ERROR:
397:                           return true;
00A5DE  B3C010     MOV.B #0x1, W0
00A5E0  37005D     BRA .L19
398:                           break;
399:               
400:                       default:
401:                           break;
402:                   }
403:               
404:                   return false;
00A69A  EB4000     CLR.B W0
405:               }
00A69C  BE054F     MOV.D [--W15], W10
00A69E  BE044F     MOV.D [--W15], W8
00A6A0  060000     RETURN
406:               
407:               
408:               //-----------------------------------------------------------------------------
409:               //Check if any valid data is currently waiting in the endpoint buffers that needs
410:               // to be sent over the UART.
411:               //-----------------------------------------------------------------------------
412:               /*
413:               void MIDI_Host_OutJackTasks(void)
414:               {
415:                   int8_t currentEndpoint;
416:                   
417:                   // First, go through each IN endpoint and add packets from its USB buffer to the UART OUT FIFO
418:                   for(currentEndpoint = 0; currentEndpoint < USBHostMIDINumberOfEndpoints(deviceHandle); currentEndpoint++)
419:                   {
420:                       // Check to see if this is an IN endpoint, and if the buffer has any packets to be read
421:                       if((USBHostMIDIEndpointDirection(deviceHandle, currentEndpoint) == IN)
422:                       && (endpointBuffers[currentEndpoint].pBufReadLocation != endpointBuffers[currentEndpoint].pBufWriteLocation))
423:                       {
424:                           int8_t midiPkt;            
425:                               
426:                           // If so, then parse through the entire USB packet for each individual MIDI packet
427:                           for(midiPkt = 0; midiPkt < endpointBuffers[currentEndpoint].numOfMIDIPackets; midiPkt++)
428:                           {
429:                               if(endpointBuffers[currentEndpoint].pBufReadLocation->Val == 0ul)
430:                               {
431:                                   // If there's nothing in this MIDI packet, then skip the rest of the USB packet
432:                                   endpointBuffers[currentEndpoint].pBufReadLocation += endpointBuffers[currentEndpoint].numOfMIDIPackets - midiPkt;
433:                                   break;
434:                               }    
435:                               else
436:                               {
437:                                   // Otherwise add it to the UART OUT FIFO and increment both pointers
438:                                   *pTxBufWriteLocation = endpointBuffers[currentEndpoint].pBufReadLocation->Val;
439:                                   pTxBufWriteLocation++;
440:                                   endpointBuffers[currentEndpoint].pBufReadLocation++;
441:                                   MIDIOutByteCount += 4;
442:                                   
443:                                   // Check to see if we've gotten to the end of the UART OUT FIFO array
444:                                   if((unsigned int)pTxBufWriteLocation >= ((unsigned int)&MIDIOutTxBuffer[0] + (unsigned int)MIDI_UART_BUFFER_SIZE))
445:                                   {
446:                                       // If so, then loop it back to the beginning of the array
447:                                       pTxBufWriteLocation = (uint32_t*)&MIDIOutTxBuffer[0];
448:                                   }
449:                               }
450:                           }
451:                           
452:                           // After parsing through entire USB packet, check to see if we've gotten to the end of the USB array
453:                           if(endpointBuffers[currentEndpoint].pBufReadLocation - endpointBuffers[currentEndpoint].bufferStart
454:                           >= endpointBuffers[currentEndpoint].numOfMIDIPackets * MIDI_USB_BUFFER_SIZE)
455:                           {
456:                               // If so, then loop it back to the beginning of the array
457:                               endpointBuffers[currentEndpoint].pBufReadLocation = endpointBuffers[currentEndpoint].bufferStart;
458:                           }
459:                       }
460:                   }        
461:                   
462:                   
463:                   // Next, continue sending UART data from the FIFO UART OUT buffer
464:                   if((MIDIOutByteCount != 0u) && (U2STAbits.TRMT == 1)) 
465:                   {
466:                       //Check if the byte was not on a 4-byte boundary.  If so, that means we
467:                       //are currently pointing to a Cable#/CIN byte, which we shouldn't 
468:                       //re-transmit over the UART MIDI output port.  Just gobble it up/throw
469:                       //it away, since we are currently only implementing support for one MIDI
470:                       //OUT jack anyway.
471:                       //All other MIDI status/data bytes we re-transmit directly.
472:                       switch((unsigned int)(pTxBufReadLocation - &MIDIOutTxBuffer[0]) & 0x0003)
473:                       {
474:                           case 0:
475:                               //In this case, we are currently pointing to the Cable#/CIN byte.
476:                               //Just gobble it up from the FIFO and perform error case checking.
477:                               pTxBufReadLocation++;
478:                               //Check if time for read FIFO pointer wrap around
479:                               if(pTxBufReadLocation >= (&MIDIOutTxBuffer[0] + MIDI_UART_BUFFER_SIZE))
480:                               {
481:                                   pTxBufReadLocation = &MIDIOutTxBuffer[0];
482:                               }    
483:                               MIDIOutByteCount--; //Consumed a byte from the circular FIFO
484:                               
485:                               //Now error check, to make sure that the byte we are currently pointing
486:                               //a is a status byte (bit #7 set).  It always should be, unless the
487:                               //host sends an illegal MIDI data packet (not 32-bit fixed width
488:                               //like specifications require).  
489:                               if(!(*pTxBufReadLocation & 0x80))
490:                               {
491:                                   //In this scenario, we should flush the FIFO and re-inilize our
492:                                   //pointers.  This is draconian, but the data in the buffer
493:                                   //probably isn't trustworthy.  Additionally, during operation 
494:                                   //the FIFO wouldn't normally contain more than 1 MIDI command 
495:                                   //at a time anyway, so this shouldn't result in any major loss
496:                                   //of data.
497:                                   pTxBufWriteLocation = (uint32_t*)&MIDIOutTxBuffer[0];
498:                                   pTxBufReadLocation = &MIDIOutTxBuffer[0];
499:                                   MIDIOutByteCount = 0;
500:                               }
501:                               break;
502:                           case 1:
503:                               if(*pTxBufReadLocation == TxRunningStatusByte)
504:                               {
505:                                   pTxBufReadLocation++;
506:                                   MIDIOutByteCount--;
507:                                   break;
508:                               }   
509:                               else if(*pTxBufReadLocation < 0xF8u)
510:                               {
511:                                   TxRunningStatusByte = *pTxBufReadLocation;
512:                               }
513:                           default:  
514:                           case 2:
515:                           case 3:
516:                               U2TXREG = *pTxBufReadLocation;
517:                               pTxBufReadLocation++;
518:                               //Check if time for read FIFO pointer wrap around
519:                               if((unsigned int)pTxBufReadLocation >= ((unsigned int)&MIDIOutTxBuffer[0] + (unsigned int)MIDI_UART_BUFFER_SIZE))
520:                               {
521:                                   pTxBufReadLocation = &MIDIOutTxBuffer[0];
522:                               }    
523:                               MIDIOutByteCount--; //Consumed a byte from the circular FIFO
524:                               break;
525:                       }//switch((unsigned int)(pTxBufReadLocation - &MIDIOutTxBuffer[0]) & 0x0003)
526:                   }//if((MIDIOutByteCount != 0u) && (PIR3bits.TX2IF == 1)) 
527:               }//void MIDITasks(void)
528:               
529:                */
---  /home/sladekm/MPLABXProjects/USB_Device_Host_MIDI.X/src/app_device_midi_basic.c  -------------------
1:                 /*******************************************************************************
2:                 Copyright 2016 Microchip Technology Inc. (www.microchip.com)
3:                 
4:                 Licensed under the Apache License, Version 2.0 (the "License");
5:                 you may not use this file except in compliance with the License.
6:                 You may obtain a copy of the License at
7:                 
8:                     http://www.apache.org/licenses/LICENSE-2.0
9:                 
10:                Unless required by applicable law or agreed to in writing, software
11:                distributed under the License is distributed on an "AS IS" BASIS,
12:                WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
13:                See the License for the specific language governing permissions and
14:                limitations under the License.
15:                
16:                To request to license the code under the MLA license (www.microchip.com/mla_license), 
17:                please contact mla_licensing@microchip.com
18:                 *******************************************************************************/
19:                
20:                /** INCLUDES *******************************************************/
21:                #include <stdint.h>
22:                #include <stdbool.h>
23:                
24:                #include "system.h"
25:                
26:                #include "usb.h"
27:                #include "usb_device_midi.h"
28:                
29:                #include"leds.h"
30:                
31:                
32:                /** VARIABLES ******************************************************/
33:                /* Some processors have a limited range of RAM addresses where the USB module
34:                 * is able to access.  The following section is for those devices.  This section
35:                 * assigns the buffers that need to be used by the USB module into those
36:                 * specific areas.
37:                 */
38:                #if defined(FIXED_ADDRESS_MEMORY)
39:                #if defined(COMPILER_MPLAB_C18)
40:                #pragma udata DEVICE_AUDIO_MIDI_RX_DATA_BUFFER=DEVCE_AUDIO_MIDI_RX_DATA_BUFFER_ADDRESS
41:                static uint8_t ReceivedDataBuffer[64];
42:                #pragma udata DEVICE_AUDIO_MIDI_EVENT_DATA_BUFFER=DEVCE_AUDIO_MIDI_EVENT_DATA_BUFFER_ADDRESS
43:                static USB_AUDIO_MIDI_EVENT_PACKET midiData;
44:                #pragma udata
45:                #elif defined(__XC8)
46:                static uint8_t ReceivedDataBuffer[64] DEVCE_AUDIO_MIDI_RX_DATA_BUFFER_ADDRESS;
47:                static USB_AUDIO_MIDI_EVENT_PACKET midiData DEVCE_AUDIO_MIDI_EVENT_DATA_BUFFER_ADDRESS;
48:                #endif
49:                #else
50:                #define MIDI_USB_BUFFER_SIZE                (uint8_t)4
51:                #define MIDI_UART_BUFFER_SIZE (uint8_t)64
52:                
53:                static uint8_t ReceivedDataBuffer[MIDI_UART_BUFFER_SIZE];
54:                static USB_AUDIO_MIDI_EVENT_PACKET midiData;
55:                #endif
56:                
57:                // MIDI packet used to translate MIDI UART to MIDI USB, with flag
58:                USB_AUDIO_MIDI_EVENT_PACKET UARTDeviceTranslatedToUSB;
59:                extern bool        UARTmidiPacketTranslated;
60:                // MIDI packet used to translate MIDI UART to MIDI USB, with flag
61:                extern uint32_t UARTTranslatedToUSB;
62:                
63:                //A circular buffer for storing received bytes from the MIDI (UART), to be sent do attached USB MIDI device
64:                uint8_t        MIDIDeviceInRxBuffer[MIDI_UART_BUFFER_SIZE];
65:                uint8_t*       pRxUARTBufDeviceReadLocation;
66:                uint8_t*       pRxUARTBufDeviceWriteLocation;
67:                uint8_t        UARTDeviceInByteCount;
68:                
69:                // uint8_t        MIDIDeviceRxCommandState;
70:                bool           DeviceSysExCommandPending;
71:                bool           DeviceBytePending;
72:                //uint8_t        DeviceRxRunningStatusByte;
73:                //uint8_t        DeviceTxRunningStatusByte;
74:                
75:                // Read location of the buffer from which the data is read;
76:                static uint8_t*       pTxBufReadLocation;
77:                
78:                
79:                static USB_HANDLE USBTxHandle;
80:                static USB_HANDLE USBRxHandle;
81:                
82:                static uint8_t pitch;
83:                static bool sentNoteOff;
84:                
85:                static USB_VOLATILE uint8_t msCounter;
86:                
87:                void MIDI_Device_OutJackTasks(void);
88:                void MIDI_InJackTasks(void);
89:                void sendMessage(uint8_t*, uint8_t);
90:                
91:                /*********************************************************************
92:                 * Function: void APP_DeviceAudioMIDIInitialize(void);
93:                 *
94:                 * Overview: Initializes the demo code
95:                 *
96:                 * PreCondition: None
97:                 *
98:                 * Input: None
99:                 *
100:                * Output: None
101:                *
102:                ********************************************************************/
103:               void APP_DeviceAudioMIDIInitialize() {
104:                   USBTxHandle = NULL;
007070  EF2FF8     CLR USBTxHandle
105:                   USBRxHandle = NULL;
007072  EF2FFA     CLR USBRxHandle
106:               
107:               
108:                   // Setup circular FIFO for MIDI In port
109:                   UARTDeviceInByteCount = 0;
007074  EF6FF2     CLR.B UARTDeviceInByteCount
110:                   pRxUARTBufDeviceReadLocation = &MIDIDeviceInRxBuffer[0];
007076  2085C0     MOV #0x85C, W0
007078  887F70     MOV W0, pRxUARTBufDeviceReadLocation
111:                   pRxUARTBufDeviceWriteLocation = &MIDIDeviceInRxBuffer[0];
00707A  887F80     MOV W0, pRxUARTBufDeviceWriteLocation
112:                   
113:                   // Clear UART translation packet and real-time packet/buffer
114:                   UARTDeviceTranslatedToUSB.Val = 0;
00707C  EF2FEA     CLR UARTDeviceTranslatedToUSB
00707E  EF2FEC     CLR 0xFEC
115:                   
116:                   // Clear status flags
117:                   DeviceSysExCommandPending = false;
007080  EF6FF3     CLR.B DeviceSysExCommandPending
118:                   UARTmidiPacketTranslated = false;
007082  EF6FD0     CLR.B UARTmidiPacketTranslated
119:               
120:                   //enable the HID endpoint
121:                   USBEnableEndpoint(USB_DEVICE_AUDIO_MIDI_ENDPOINT, USB_OUT_ENABLED | USB_IN_ENABLED | USB_HANDSHAKE_ENABLED | USB_DISALLOW_SETUP);
007084  B3C1D1     MOV.B #0x1D, W1
007086  B3C010     MOV.B #0x1, W0
007088  07FD6E     RCALL USBEnableEndpoint
122:               
123:                   //Re-arm the OUT endpoint for the next packet
124:                   USBRxHandle = USBRxOnePacket(USB_DEVICE_AUDIO_MIDI_ENDPOINT, (uint8_t*) & ReceivedDataBuffer, 64);
00708A  B3C403     MOV.B #0x40, W3
00708C  2089C2     MOV #0x89C, W2
00708E  EB4080     CLR.B W1
007090  B3C010     MOV.B #0x1, W0
007092  07FD7F     RCALL USBTransferOnePacket
007094  887FD0     MOV W0, USBRxHandle
125:               
126:               
127:                   MIDI_Jack_Initialize();
007096  0718C0     RCALL MIDI_Jack_Initialize
128:               
129:               
130:               
131:               }
007098  060000     RETURN
132:               
133:               /*********************************************************************
134:                * Function: void APP_DeviceAudioMIDIInitialize(void);
135:                *
136:                * Overview: Initializes the demo code
137:                *
138:                * PreCondition: None
139:                *
140:                * Input: None
141:                *
142:                * Output: None
143:                *
144:                ********************************************************************/
145:               void APP_DeviceAudioMIDISOFHandler() {
146:                   if (msCounter != 0) {
00709A  BFCFFC     MOV.B msCounter, WREG
00709C  320002     BRA Z, .L2
147:                       msCounter--;
00709E  E94000     DEC.B W0, W0
0070A0  B7EFFC     MOV.B WREG, msCounter
148:                   }
149:               }
0070A2  060000     RETURN
150:               
151:               /*********************************************************************
152:                * Function: void APP_DeviceAudioMIDITasks(void);
153:                *
154:                * Overview: Keeps the Custom HID demo running.
155:                *
156:                * PreCondition: The demo should have been initialized and started via
157:                *   the APP_DeviceAudioMIDIInitialize() and APP_DeviceAudioMIDIStart() demos
158:                *   respectively.
159:                *
160:                * Input: None
161:                *
162:                * Output: None
163:                *
164:                ********************************************************************/
165:               void APP_DeviceAudioMIDITasks() {
166:                   /* If the device is not configured yet, or the device is suspended, then
167:                    * we don't need to run the demo since we can't send any data.
168:                    */
169:                   if ((USBGetDeviceState() < CONFIGURED_STATE) ||
00712C  807C20     MOV USBDeviceState, W0
00712E  500FFF     SUB W0, #0x1F, [W15]
007130  360018     BRA LEU, .L24
007132  AB2488     BTST U1PWRC, #1
007134  3A0016     BRA NZ, .L24
170:                           (USBIsDeviceSuspended() == true)) {
171:                       return;
172:                   }
173:               
174:                   MIDI_InJackTasks();
007136  07188F     RCALL MIDI_InJackTasks
175:                   // If UART packet is completely translated it can be sent to USB MIDI 
176:                   if(UARTmidiPacketTranslated == true){
007138  E24FD0     CP0.B UARTmidiPacketTranslated
00713A  320007     BRA Z, .L26
177:                       USBTxHandle = USBTxOnePacket(USB_DEVICE_AUDIO_MIDI_ENDPOINT,(uint8_t*)&UARTTranslatedToUSB,4);
00713C  B3C043     MOV.B #0x4, W3
00713E  20FCC2     MOV #0xFCC, W2
007140  B3C011     MOV.B #0x1, W1
007142  784001     MOV.B W1, W0
007144  07FD26     RCALL USBTransferOnePacket
007146  887FC0     MOV W0, USBTxHandle
178:                       UARTmidiPacketTranslated = false;
007148  EF6FD0     CLR.B UARTmidiPacketTranslated
179:                   }
180:               
181:               
182:                   if (!USBHandleBusy(USBRxHandle)) {
00714A  807FD0     MOV USBRxHandle, W0
00714C  E00000     CP0 W0
00714E  320002     BRA Z, .L27
007150  E00010     CP0 [W0]
007152  350007     BRA LT, .L24
183:                       //We have received a MIDI packet from the host, process it and then
184:                       //  prepare to receive the next packet
185:               
186:                       //INSERT MIDI PROCESSING CODE HERE
187:                       MIDI_Device_OutJackTasks();
007154  07FFB8     RCALL MIDI_Device_OutJackTasks
188:                       //Get ready for next packet (this will overwrite the old data)
189:                       USBRxHandle = USBRxOnePacket(USB_DEVICE_AUDIO_MIDI_ENDPOINT, (uint8_t*) & ReceivedDataBuffer, 64);
007156  B3C403     MOV.B #0x40, W3
007158  2089C2     MOV #0x89C, W2
00715A  EB4080     CLR.B W1
00715C  B3C010     MOV.B #0x1, W0
00715E  07FD19     RCALL USBTransferOnePacket
007160  887FD0     MOV W0, USBRxHandle
190:                   }
191:               }
007162  060000     RETURN
192:               
193:               void MIDI_Device_OutJackTasks(void) {
0070C6  BE9F88     MOV.D W8, [W15++]
0070C8  BE9F8A     MOV.D W10, [W15++]
0070CA  781F8C     MOV W12, [W15++]
007112  208DC2     MOV #0x8DC, W2
007114  2FFC00     MOV #0xFFC0, W0
007116  400002     ADD W0, W2, W0
194:               
195:                   pTxBufReadLocation = &ReceivedDataBuffer[0];
0070CC  2089C0     MOV #0x89C, W0
0070CE  887FB0     MOV W0, pTxBufReadLocation
196:                   
197:                   LED1_Set_State(LED_STATUS_BLINK_ONCE);
0070D0  200010     MOV #0x1, W0
0070D2  071C41     RCALL LED1_Set_State
198:                   while (pTxBufReadLocation < &ReceivedDataBuffer[MIDI_UART_BUFFER_SIZE]) {
0070D4  208DC8     MOV #0x8DC, W8
0070DE  370016     BRA .L21
00710C  807FB0     MOV pTxBufReadLocation, W0
00710E  500F88     SUB W0, W8, [W15]
007110  39FFE7     BRA NC, .L18
199:                       // There is something in the buffer
200:                       uint8_t cin = *pTxBufReadLocation & 0x0F;
0070E0  784110     MOV.B [W0], W2
0070E2  6140EF     AND.B W2, #0xF, W1
201:                       switch (cin) {
0070D6  200019     MOV #0x1, W9
0070D8  24F98A     MOV #0x4F98, W10
0070DA  23044B     MOV #0x3044, W11
0070DC  28020C     MOV #0x8020, W12
0070E4  FB0081     SE W1, W1
0070E6  DD4881     SL W9, W1, W1
0070E8  60810A     AND W1, W10, W2
0070EA  3A000B     BRA NZ, .L15
0070EC  60810B     AND W1, W11, W2
0070EE  3A0003     BRA NZ, .L14
0070F0  60808C     AND W1, W12, W1
0070F2  3A0004     BRA NZ, .L16
0070F4  370009     BRA .L23
202:                           case MIDI_CIN_2_uint8_t_MESSAGE:
203:                           case MIDI_CIN_SYSEX_ENDS_2:
204:                           case MIDI_CIN_PROGRAM_CHANGE:
205:                           case MIDI_CIN_CHANNEL_PREASURE:
206:                               sendMessage(pTxBufReadLocation, 2);
0070F6  B3C021     MOV.B #0x2, W1
0070F8  07FFD5     RCALL sendMessage
207:               //                pTxBufReadLocation = pTxBufReadLocation + 4;
208:                               break;
0070FA  370008     BRA .L21
209:                           case MIDI_CIN_SYSEX_ENDS_1:
210:                           case MIDI_CIN_SINGLE_uint8_t:
211:                               sendMessage(pTxBufReadLocation, 1);
0070FC  B3C011     MOV.B #0x1, W1
0070FE  07FFD2     RCALL sendMessage
212:               //                pTxBufReadLocation = pTxBufReadLocation + 4;
213:                               break;
007100  370005     BRA .L21
214:                           case MIDI_CIN_3_uint8_t_MESSAGE:
215:                           case MIDI_CIN_SYSEX_START:
216:                           case MIDI_CIN_SYSEX_ENDS_3:
217:                           case MIDI_CIN_NOTE_OFF:
218:                           case MIDI_CIN_NOTE_ON:
219:                           case MIDI_CIN_POLY_KEY_PRESS:
220:                           case MIDI_CIN_CONTROL_CHANGE:
221:                           case MIDI_CIN_PITCH_BEND_CHANGE:
222:                               sendMessage(pTxBufReadLocation, 3);
007102  B3C031     MOV.B #0x3, W1
007104  07FFCF     RCALL sendMessage
223:               //                pTxBufReadLocation = pTxBufReadLocation + 4;
224:                               break;
007106  370002     BRA .L21
225:                           default:
226:                               pTxBufReadLocation = pTxBufReadLocation + 4;
007108  400064     ADD W0, #0x4, W0
00710A  887FB0     MOV W0, pTxBufReadLocation
227:                               break;
228:                       }
229:                   }
230:                   // let's clear the buffer
231:                   pTxBufReadLocation = &ReceivedDataBuffer[0];
232:                   int i;
233:                   for (i = 0; i < MIDI_UART_BUFFER_SIZE; i++) {
00711C  510F80     SUB W2, W0, [W15]
00711E  3AFFFD     BRA NZ, .L19
007120  208DC0     MOV #0x8DC, W0
007122  887FB0     MOV W0, pTxBufReadLocation
234:                       *pTxBufReadLocation++ = 0x00;
007118  EB4080     CLR.B W1
00711A  785801     MOV.B W1, [W0++]
235:                   }
236:               }
007124  78064F     MOV [--W15], W12
007126  BE054F     MOV.D [--W15], W10
007128  BE044F     MOV.D [--W15], W8
00712A  060000     RETURN
237:               
238:               /**
239:                * Sends characters from MIDI buffer to serial port. It skips the first character as it is CIN 
240:                * @param buffer MIDI buffer
241:                * @param length Number of characters to be sent
242:                */
243:               void sendMessage(uint8_t* buffer, uint8_t length) {
0070A8  E80180     INC W0, W3
0070AA  E94081     DEC.B W1, W1
0070AC  FB8081     ZE W1, W1
0070AE  418181     ADD W3, W1, W3
244:                   uint8_t i;
245:                   //    if( (*(buffer+1) == 0xB0) && (*(buffer+2) == 0x06) ){
246:                   //        *(buffer+3) = 0x0F;
247:                   //    }
248:                   uint8_t* readFrom = buffer+1;
249:                   for (i = 0; i < length; i++) {
0070A4  E00401     CP0.B W1
0070A6  32000C     BRA Z, .L5
0070BC  500F83     SUB W0, W3, [W15]
0070BE  3AFFF9     BRA NZ, .L10
250:                       while (U2STAbits.TRMT == 0); // Wait for UART to be ready
0070B0  201002     MOV #0x100, W2
0070B2  801194     MOV U2STA, W4
0070B4  610084     AND W2, W4, W1
0070B6  32FFFD     BRA Z, .L10
251:                       U2TXREG = *readFrom++;
0070B8  FB80D0     ZE [++W0], W1
0070BA  8811A1     MOV W1, U2TXREG
252:                   }
253:                   pTxBufReadLocation +=4;
0070C0  200040     MOV #0x4, W0
0070C2  B42FF6     ADD pTxBufReadLocation
254:               }
0070C4  060000     RETURN
255:               
256:               //-----------------------------------------------------------------------------
257:               //Check the MIDI UART FIFO buffer to see if any MIDI traffic was received by
258:               // the interrupt. If so, we need to copy it from the UART FIFO buffer to the USB FIFO buffer,
259:               // and translate it into the USB MIDI packet.
260:               //-----------------------------------------------------------------------------
261:               /*
262:               void MIDI_Device_InJackTasks(void)
263:               {
264:                   static int8_t ExpectedDataBytes;
265:                   static int8_t WriteIndex;
266:                   
267:                   //If we have something within the UART MIDI Rx Buffer
268:                   if(UARTDeviceInByteCount > 0)
269:                   {
270:                       //Check if we received a new status (MIDI command) byte.  If so, regardless of previous state
271:                       //jump to the state where we are starting to receive a new MIDI command packet.
272:                       if(*pRxUARTBufDeviceReadLocation & 0x80) 
273:                       {
274:                           MIDIDeviceRxCommandState = STATE_WAIT_STATUS_BYTE;
275:                           DeviceRxRunningStatusByte = *pRxUARTBufDeviceReadLocation;   //Save the Status byte.
276:                           
277:                           //Reset write index pointer to to start of MIDI_x field of USB packet buffer,
278:                           //unless we just recevied the MIDI_STATUS_SYSEX_END, where we will still need the old
279:                           //WriteIndex value to know the proper CIN byte value of the next USB packet.
280:                           if(*pRxUARTBufDeviceReadLocation != MIDI_STATUS_SYSEX_END)
281:                           {
282:                               WriteIndex = 2;
283:                               UARTDeviceTranslatedToUSB.Val = 0;   //All pad bits/bytes = 0 according to MIDI-Audio USB specs.
284:                           }// if(*pRxUARTBufDeviceReadLocation != MIDI_STATUS_SYSEX_END)
285:                           
286:                           //We are eventually going to consume the byte we just received, 
287:                           //before returning in this scenario.
288:                           pRxUARTBufDeviceReadLocation++;
289:                           UARTDeviceInByteCount--;
290:                           if((unsigned int)pRxUARTBufDeviceReadLocation >= ((unsigned int)&MIDIDeviceInRxBuffer[0] + (unsigned int)MIDI_UART_BUFFER_SIZE))
291:                           {
292:                               pRxUARTBufDeviceReadLocation = &MIDIDeviceInRxBuffer[0];
293:                           }
294:                       }// if(*pRxUARTBufDeviceReadLocation & 0x80) 
295:                       else if(MIDIDeviceRxCommandState == STATE_WAIT_STATUS_BYTE)   //Now check for "Running Status"
296:                       {
297:                           //If we get to here, this means we just received the first data byte,
298:                           //that was part of a running status command.
299:                           //In this case, we don't want to consume the ReceivedByte yet.  For this
300:                           //iteration of this [if(UARTDeviceInByteCount > 0)] code, we just need to re-process 
301:                           //the previous DeviceRxRunningStatusByte (ex: don't write to buffer here).  Then on the
302:                           //next iteration we will actually consume the newest ReceivedByte.
303:                       }// else if(MIDIDeviceRxCommandState == STATE_WAIT_STATUS_BYTE)
304:                       else
305:                       {
306:                           //We are going to consume the (non-status) byte we just received, in this scenario.
307:                       }// else
308:                       
309:                       //Check if we already received the Status (MIDI command) byte already, and
310:                       //are currently waiting/expecting to receive data bytes.
311:                       if(MIDIDeviceRxCommandState == STATE_WAITING_BYTES)
312:                       {
313:                           //Check if we are handling a SysEx command, or a normal command.
314:                           if(DeviceSysExCommandPending == true)
315:                           {
316:                               //Handle the variable data length SysEx command.
317:                               *((int8_t*)&UARTDeviceTranslatedToUSB + WriteIndex) = *pRxUARTBufDeviceReadLocation;
318:                               pRxUARTBufDeviceReadLocation++;
319:                               UARTDeviceInByteCount--;
320:                               if((unsigned int)pRxUARTBufDeviceReadLocation >= ((unsigned int)&MIDIDeviceInRxBuffer[0] + (unsigned int)MIDI_UART_BUFFER_SIZE))
321:                               {
322:                                   pRxUARTBufDeviceReadLocation = &MIDIDeviceInRxBuffer[0];
323:                               }
324:                               if(WriteIndex < 3u)
325:                               {
326:                                   WriteIndex++;
327:                               }// if(WriteIndex < 3u)
328:                               else if(WriteIndex == 3)
329:                               {
330:                                   //We have accumulated a full USB-MIDI packet worth of data.
331:                                   //Prepare state machine to send the packet.
332:                                   UARTDeviceTranslatedToUSB.CodeIndexNumber = MIDI_CIN_SYSEX_START; //Might also be continuing instead of starting.
333:                                   
334:                                   UARTMidiDevicePacketTranslated = true; //Set boolean flag here to let USB code know it should prepare a packet.
335:                                   WriteIndex = 1; //Move write pointer/index back to start of MIDI_x field of USB packet buffer
336:                               }// else if(WriteIndex == 3)                 
337:                           }// if(DeviceSysExCommandPending == TRUE)
338:                           else
339:                           {    
340:                               *(int8_t*)(((int8_t*)&UARTDeviceTranslatedToUSB) + WriteIndex) = *pRxUARTBufDeviceReadLocation;
341:                               pRxUARTBufDeviceReadLocation++;
342:                               UARTDeviceInByteCount--;
343:                               if((unsigned int)pRxUARTBufDeviceReadLocation >= ((unsigned int)&MIDIDeviceInRxBuffer[0] + (unsigned int)MIDI_UART_BUFFER_SIZE))
344:                               {
345:                                   pRxUARTBufDeviceReadLocation = &MIDIDeviceInRxBuffer[0];
346:                               }
347:                               if(ExpectedDataBytes != 0)
348:                               {
349:                                   WriteIndex++;
350:                                   ExpectedDataBytes--;
351:                                   //Check if we finished receiving all expected bytes in the MIDI command
352:                                   if(ExpectedDataBytes == 0)
353:                                   {
354:                                       UARTMidiDevicePacketTranslated = true; //Set boolean flag here so we know to add packet to buffer OUT
355:                                       MIDIDeviceRxCommandState = STATE_WAIT_STATUS_BYTE;                
356:                                   }// if(ExpectedDataBytes == 0)
357:                               }// if(ExpectedDataBytes != 0)
358:                           }// else
359:                       }// if(MIDIDeviceRxCommandState == STATE_WAITING_BYTES)
360:                       else if(MIDIDeviceRxCommandState == STATE_WAIT_STATUS_BYTE)
361:                       {
362:                           ExpectedDataBytes = 0;  //Will get updated with correct value, once we have parsed the status byte and know how many data bytes to expect.
363:                           MIDIDeviceRxCommandState = STATE_WAITING_BYTES;   //Initialize UART recevier state machine
364:                           
365:                           //We presumably have just received a status byte (MIDI command byte)
366:                           if(DeviceRxRunningStatusByte & 0x80) //Check if we received a new status (MIDI command) byte, indicated by bit 7 of UART byte being set
367:                           {
368:                               //Check if it was a system common command of some kind (upper nibble = 0xF)
369:                               if((DeviceRxRunningStatusByte & 0xF0) == 0xF0) 
370:                               {
371:                                   UARTDeviceTranslatedToUSB.MIDI_0 = DeviceRxRunningStatusByte;
372:                                   //Check for system common commands
373:                                   switch(DeviceRxRunningStatusByte)
374:                                   {
375:                                       case(MIDI_STATUS_SYSEX_START):
376:                                           UARTDeviceTranslatedToUSB.CodeIndexNumber = MIDI_CIN_SYSEX_START;
377:                                           ExpectedDataBytes = 255;    //Not really expecting 255.  SysEx is variable/unknown length.
378:                                           DeviceSysExCommandPending = true; //Let state machine know to perform special handling for this command.
379:                                           break;
380:                                       case(MIDI_STATUS_SYSEX_END):
381:                                           //This case is special, since the actual data payload size is not fixed.
382:                                           //However, when we get this byte, this means the SysEx command is completing,
383:                                           //and therefore we can determine the residual number of bytes we need to send
384:                                           //based on the WriteIndex variable.
385:                                           if(WriteIndex == 1)
386:                                               UARTDeviceTranslatedToUSB.CodeIndexNumber = MIDI_CIN_SYSEX_ENDS_1;
387:                                           else if(WriteIndex == 2)
388:                                               UARTDeviceTranslatedToUSB.CodeIndexNumber = MIDI_CIN_SYSEX_ENDS_2;
389:                                           else if(WriteIndex == 3)
390:                                               UARTDeviceTranslatedToUSB.CodeIndexNumber = MIDI_CIN_SYSEX_ENDS_3;
391:                                           //Complete the request here, rather than the normal handler.
392:                                           WriteIndex = 2; //Move write pointer/index back to start of buffer for next MIDI command
393:                                           UARTMidiDevicePacketTranslated = true; //Set boolean flag here to let USB code know it should prepare a packet.
394:                                           MIDIDeviceRxCommandState = STATE_WAIT_STATUS_BYTE;  
395:                                           DeviceSysExCommandPending = false;        //No longer handling a SysEx data flow.
396:                                           ExpectedDataBytes = 0;
397:                                           break;
398:                                       case(MIDI_STATUS_MTC_QFRAME):
399:                                           UARTDeviceTranslatedToUSB.CodeIndexNumber = MIDI_CIN_2_BYTE_MESSAGE;
400:                                           ExpectedDataBytes = 1;
401:                                           break;
402:                                       case(MIDI_STATUS_SONG_POSITION):
403:                                           UARTDeviceTranslatedToUSB.CodeIndexNumber = MIDI_CIN_3_BYTE_MESSAGE;
404:                                           ExpectedDataBytes = 2;
405:                                           break;
406:                                       case(MIDI_STATUS_SONG_SELECT):
407:                                           UARTDeviceTranslatedToUSB.CodeIndexNumber = MIDI_CIN_2_BYTE_MESSAGE;
408:                                           ExpectedDataBytes = 1;
409:                                           break;
410:                                       case(MIDI_STATUS_TUNE_REQUEST):
411:                                           UARTDeviceTranslatedToUSB.CodeIndexNumber = MIDI_CIN_1_BYTE_MESSAGE;
412:                                           ExpectedDataBytes = 0;
413:                                           break;
414:                                       default:
415:                                           MIDIDeviceRxCommandState = STATE_WAIT_STATUS_BYTE;
416:                                           ExpectedDataBytes = 0;                            
417:                                           break;
418:                                   }//switch(DeviceRxRunningStatusByte)    
419:                                   
420:                                   //Check if we finished receiving all expected bytes in the MIDI command.
421:                                   //This would be the case for system commands that consist only of the status byte. 
422:                                   if((ExpectedDataBytes == 0) && (MIDIDeviceRxCommandState = STATE_WAITING_BYTES))  //Not note really waiting for extra bytes in this scenario.
423:                                   {
424:                                       //Prepare state machine to prepare USB transmit packet.
425:                                       UARTMidiDevicePacketTranslated = true; //Set boolean flag here to let USB code know it should prepare a packet.
426:                                       MIDIDeviceRxCommandState = STATE_WAIT_STATUS_BYTE;                
427:                                   } 
428:                               }//if((DeviceRxRunningStatusByte & 0xF0) == 0xF0) 
429:                               else
430:                               {
431:                                   //Must have been a normal MIDI command status byte
432:                                   UARTDeviceTranslatedToUSB.MIDI_0 = DeviceRxRunningStatusByte;
433:                                   WriteIndex = 2;
434:                                   DeviceRxRunningStatusByte &= 0xF0;   //Strip off the channel bits to get the command by itself
435:                                   switch(DeviceRxRunningStatusByte)
436:                                   {
437:                                       case(MIDI_CIN_NOTE_OFF << 4):
438:                                           ExpectedDataBytes = 2;      //Expect 2 data bytes to follow
439:                                           UARTDeviceTranslatedToUSB.CodeIndexNumber = MIDI_CIN_NOTE_OFF;
440:                                           break;
441:                                       case(MIDI_CIN_NOTE_ON << 4):
442:                                           ExpectedDataBytes = 2;      //Expect 2 data bytes to follow
443:                                           UARTDeviceTranslatedToUSB.CodeIndexNumber = MIDI_CIN_NOTE_ON;
444:                                           break;
445:                                       case(MIDI_CIN_POLY_KEY_PRESS << 4):
446:                                           ExpectedDataBytes = 2;      //Expect 2 data bytes to follow
447:                                           UARTDeviceTranslatedToUSB.CodeIndexNumber = MIDI_CIN_POLY_KEY_PRESS;
448:                                           break;
449:                                       case(MIDI_CIN_CONTROL_CHANGE << 4):
450:                                           ExpectedDataBytes = 2;      //Expect 2 data bytes to follow
451:                                           UARTDeviceTranslatedToUSB.CodeIndexNumber = MIDI_CIN_CONTROL_CHANGE;
452:                                           break;
453:                                       case(MIDI_CIN_PROGRAM_CHANGE << 4):
454:                                           ExpectedDataBytes = 1;      //Expect 1 data bytes to follow
455:                                           UARTDeviceTranslatedToUSB.CodeIndexNumber = MIDI_CIN_PROGRAM_CHANGE;
456:                                           break;
457:                                       case(MIDI_CIN_CHANNEL_PREASURE << 4):
458:                                           ExpectedDataBytes = 1;      //Expect 1 data bytes to follow
459:                                           UARTDeviceTranslatedToUSB.CodeIndexNumber = MIDI_CIN_CHANNEL_PREASURE;
460:                                           break;
461:                                       case(MIDI_CIN_PITCH_BEND_CHANGE << 4):
462:                                           ExpectedDataBytes = 2;      //Expect 2 data bytes to follow
463:                                           UARTDeviceTranslatedToUSB.CodeIndexNumber = MIDI_CIN_PITCH_BEND_CHANGE;
464:                                           break;
465:                                       default:
466:                                           MIDIDeviceRxCommandState = STATE_WAIT_STATUS_BYTE;
467:                                           ExpectedDataBytes = 0;
468:                                           break;
469:                                   }//switch(DeviceRxRunningStatusByte)                           
470:                               }//else        
471:                           }//if(DeviceRxRunningStatusByte & 0x80) 
472:                       }//else if(MIDIDeviceRxCommandState == STATE_WAIT_STATUS_BYTE)
473:                   }//if(UARTDeviceInByteCount > 0)
474:                   
475:                   // If the UART to USB translation has completed, then add packet to the OUT endpoint buffer(s)
476:                   if(UARTMidiDevicePacketTranslated == true)
477:                   {
478:                       // For now will keep empty. It will be handled in APP_DeviceAudioMIDITasks()
479:                   }// if(UARTMidiDevicePacketTranslated == TRUE)
480:               }//void MIDI_host_InJackTasks    
481:                */
482:               
---  /home/sladekm/MPLABXProjects/USB_Device_Host_MIDI.X/midi_jack.c  -----------------------------------
1:                 #include <stdint.h>
2:                 #include <stdbool.h>
3:                 
4:                 #include "system.h"
5:                 #include "midi_jack.h"
6:                 #include "usb_common.h"
7:                 #include "usb_host_midi.h"
8:                 #include "usb_device_midi.h"
9:                 
10:                //A circular buffer for storing received bytes from the host, out the UART to the attached device on the MIDI Out port
11:                uint8_t        MIDIOutTxBuffer[MIDI_UART_BUFFER_SIZE];
12:                uint8_t*       pTxBufReadLocation;
13:                uint32_t*      pTxBufWriteLocation;        // This is a double word (4 bytes), since we will be writing a double word at a time
14:                uint8_t        MIDIOutByteCount;
15:                
16:                //A circular buffer for storing received bytes from the MIDI (UART), to be sent do attached USB MIDI device
17:                uint8_t        MIDIInRxBuffer[MIDI_UART_BUFFER_SIZE];
18:                uint8_t*       pRxUARTBufReadLocation;
19:                uint8_t*       pRxUARTBufWriteLocation;
20:                uint8_t        UARTInByteCount;
21:                
22:                uint8_t        MIDIRxCommandState;
23:                bool           SysExCommandPending;
24:                bool           BytePending;
25:                uint8_t        RxRunningStatusByte;
26:                uint8_t        TxRunningStatusByte;
27:                
28:                typedef enum
29:                {
30:                    STATE_WAIT_STATUS_BYTE,
31:                    STATE_WAITING_BYTES
32:                } STATE_WAIT;
33:                
34:                typedef enum
35:                {
36:                    MIDI_CIN_1_BYTE_MESSAGE,
37:                    MIDI_CIN_2_BYTE_MESSAGE,
38:                    MIDI_CIN_3_BYTE_MESSAGE
39:                } MIDI_CIN_N;
40:                
41:                // MIDI packet used to translate MIDI UART to MIDI USB, with flag
42:                USB_AUDIO_MIDI_PACKET UARTTranslatedToUSB;
43:                bool        UARTmidiPacketTranslated;
44:                
45:                // MIDI packet used to translate MIDI UART to MIDI USB for real time messages, with flag, and buffer
46:                extern USB_AUDIO_MIDI_PACKET UARTRealTimeToUSB;
47:                extern USB_AUDIO_MIDI_PACKET UARTRealTimeToUSBBuffer;
48:                extern bool        UARTRealTimePacketTranslated;
49:                
50:                
51:                
52:                void MIDI_Jack_Initialize()
53:                {
54:                        // Setup circular FIFO for MIDI Out port
55:                    MIDIOutByteCount = 0;
00A218  EF6FC0     CLR.B MIDIOutByteCount
56:                    pTxBufReadLocation = &MIDIOutTxBuffer[0];
00A21A  208DC0     MOV #0x8DC, W0
00A21C  887DE0     MOV W0, pTxBufReadLocation
57:                    pTxBufWriteLocation = (uint32_t*)&MIDIOutTxBuffer[0];
00A21E  887DF0     MOV W0, pTxBufWriteLocation
58:                    
59:                    // Setup circular FIFO for MIDI In port
60:                    UARTInByteCount = 0;
00A220  EF6FC6     CLR.B UARTInByteCount
61:                    pRxUARTBufReadLocation = &MIDIInRxBuffer[0];
00A222  2091C0     MOV #0x91C, W0
00A224  887E10     MOV W0, pRxUARTBufReadLocation
62:                    pRxUARTBufWriteLocation = &MIDIInRxBuffer[0];
00A226  887E20     MOV W0, pRxUARTBufWriteLocation
63:                
64:                    // Clear UART translation packet and real-time packet/buffer
65:                    UARTTranslatedToUSB.Val = 0;
00A228  EF2FCC     CLR UARTTranslatedToUSB
00A22A  EF2FCE     CLR 0xFCE
66:                    UARTRealTimeToUSB.Val = 0;
00A22C  EF2FDC     CLR UARTRealTimeToUSB
00A22E  EF2FDE     CLR 0xFDE
67:                    UARTRealTimeToUSBBuffer.Val = 0;
00A230  EF2FE0     CLR UARTRealTimeToUSBBuffer
00A232  EF2FE2     CLR 0xFE2
68:                
69:                }
00A234  060000     RETURN
70:                
71:                
72:                void MIDI_U2RXInterruptHandler() 
73:                {
74:                    while (U2STAbits.URXDA) {
00A23C  370008     BRA .L8
00A24E  AB0232     BTST U2STA, #0
00A250  3AFFF6     BRA NZ, .L5
75:                
76:                        *pRxUARTBufWriteLocation++ = U2RXREG;
00A23E  8011B0     MOV U2RXREG, W0
00A240  807E21     MOV pRxUARTBufWriteLocation, W1
00A242  785880     MOV.B W0, [W1++]
00A244  887E21     MOV W1, pRxUARTBufWriteLocation
77:                        UARTInByteCount++;
00A246  EC6FC6     INC.B UARTInByteCount
78:                        if((unsigned int)pRxUARTBufWriteLocation >= ((unsigned int)&MIDIInRxBuffer[0] + (unsigned int)MIDI_UART_BUFFER_SIZE))
00A236  2095C2     MOV #0x95C, W2
00A248  508F82     SUB W1, W2, [W15]
00A24A  390001     BRA NC, .L8
79:                        {
80:                            pRxUARTBufWriteLocation = &MIDIInRxBuffer[0];
00A238  2FFC03     MOV #0xFFC0, W3
00A23A  418182     ADD W3, W2, W3
00A24C  887E23     MOV W3, pRxUARTBufWriteLocation
81:                        }
82:                    }
83:                    // Clear interrupt flag of rx
84:                    IFS1bits.U2RXIF = 0;
00A252  A9C087     BCLR 0x87, #6
85:                }
00A254  060000     RETURN
86:                
87:                //-----------------------------------------------------------------------------
88:                //Check the MIDI UART FIFO buffer to see if any MIDI traffic was received by
89:                // the interrupt. If so, we need to copy it from the UART FIFO buffer to the USB FIFO buffer,
90:                // and translate it into the USB MIDI packet.
91:                //-----------------------------------------------------------------------------
92:                void MIDI_InJackTasks(void)
93:                {
94:                    static int8_t ExpectedDataBytes;
95:                    static int8_t WriteIndex;
96:                    
97:                    //If we have something within the UART MIDI Rx Buffer
98:                    if(UARTInByteCount > 0)
00A256  BFCFC6     MOV.B UARTInByteCount, WREG
00A258  320104     BRA Z, .L9
99:                    {
100:                       //Check if we received a new status (MIDI command) byte.  If so, regardless of previous state
101:                       //jump to the state where we are starting to receive a new MIDI command packet.
102:                       if(*pRxUARTBufReadLocation & 0x80) 
00A25A  807E11     MOV pRxUARTBufReadLocation, W1
00A25C  E00411     CP0.B [W1]
00A25E  3D0015     BRA GE, .L11
103:                       {
104:                           MIDIRxCommandState = STATE_WAIT_STATUS_BYTE;
00A260  EF6FC7     CLR.B MIDIRxCommandState
105:                           RxRunningStatusByte = *pRxUARTBufReadLocation;   //Save the Status byte.
00A262  784191     MOV.B [W1], W3
00A264  20FCA2     MOV #0xFCA, W2
00A266  784903     MOV.B W3, [W2]
106:                           
107:                           //Reset write index pointer to to start of MIDI_x field of USB packet buffer,
108:                           //unless we just recevied the MIDI_STATUS_SYSEX_END, where we will still need the old
109:                           //WriteIndex value to know the proper CIN byte value of the next USB packet.
110:                           if(*pRxUARTBufReadLocation != MIDI_STATUS_SYSEX_END)
00A268  B3CF74     MOV.B #0xF7, W4
00A26A  124F91     SUBR.B W4, [W1], [W15]
00A26C  320005     BRA Z, .L12
111:                           {
112:                               WriteIndex = 2;
00A26E  B3C024     MOV.B #0x2, W4
00A270  20FD13     MOV #0xFD1, W3
00A272  784984     MOV.B W4, [W3]
113:                               UARTTranslatedToUSB.Val = 0;   //All pad bits/bytes = 0 according to MIDI-Audio USB specs.
00A274  EF2FCC     CLR UARTTranslatedToUSB
00A276  EF2FCE     CLR 0xFCE
114:                           }// if(*pRxUARTBufReadLocation != MIDI_STATUS_SYSEX_END)
115:                           
116:                           //We are eventually going to consume the byte we just received, 
117:                           //before returning in this scenario.
118:                           pRxUARTBufReadLocation++;
00A278  E80081     INC W1, W1
00A27A  887E11     MOV W1, pRxUARTBufReadLocation
119:                           UARTInByteCount--;
00A27C  E94000     DEC.B W0, W0
00A27E  B7EFC6     MOV.B WREG, UARTInByteCount
120:                           if((unsigned int)pRxUARTBufReadLocation >= ((unsigned int)&MIDIInRxBuffer[0] + (unsigned int)MIDI_UART_BUFFER_SIZE))
00A280  2095C0     MOV #0x95C, W0
00A282  508F80     SUB W1, W0, [W15]
00A284  390002     BRA NC, .L11
121:                           {
122:                               pRxUARTBufReadLocation = &MIDIInRxBuffer[0];
00A286  B10400     SUB #0x40, W0
00A288  887E10     MOV W0, pRxUARTBufReadLocation
123:                           }
124:                       }// if(*pRxUARTBufReadLocation & 0x80) 
125:                       else if(MIDIRxCommandState == STATE_WAIT_STATUS_BYTE)   //Now check for "Running Status"
126:                       {
127:                           //If we get to here, this means we just received the first data byte,
128:                           //that was part of a running status command.
129:                           //In this case, we don't want to consume the ReceivedByte yet.  For this
130:                           //iteration of this [if(UARTInByteCount > 0)] code, we just need to re-process 
131:                           //the previous RxRunningStatusByte (ex: don't write to buffer here).  Then on the
132:                           //next iteration we will actually consume the newest ReceivedByte.
133:                       }// else if(MIDIRxCommandState == STATE_WAIT_STATUS_BYTE)
134:                       else
135:                       {
136:                           //We are going to consume the (non-status) byte we just received, in this scenario.
137:                       }// else
138:                       
139:                       //Check if we already received the Status (MIDI command) byte already, and
140:                       //are currently waiting/expecting to receive data bytes.
141:                       if(MIDIRxCommandState == STATE_WAITING_BYTES)
00A28A  BFCFC7     MOV.B MIDIRxCommandState, WREG
00A28C  504FE1     SUB.B W0, #0x1, [W15]
00A28E  3A003A     BRA NZ, .L13
142:                       {
143:                           //Check if we are handling a SysEx command, or a normal command.
144:                           if(SysExCommandPending == true)
00A290  E24FC8     CP0.B SysExCommandPending
00A292  32001E     BRA Z, .L14
145:                           {
146:                               //Handle the variable data length SysEx command.
147:                               *((int8_t*)&UARTTranslatedToUSB + WriteIndex) = *pRxUARTBufReadLocation;
00A294  20FD12     MOV #0xFD1, W2
00A296  784112     MOV.B [W2], W2
00A298  FB0002     SE W2, W0
00A29A  807E11     MOV pRxUARTBufReadLocation, W1
00A29C  20FCC3     MOV #0xFCC, W3
00A29E  7871B1     MOV.B [W1++], [W3+W0]
148:                               pRxUARTBufReadLocation++;
00A2A0  887E11     MOV W1, pRxUARTBufReadLocation
149:                               UARTInByteCount--;
00A2A2  ED6FC6     DEC.B UARTInByteCount
150:                               if((unsigned int)pRxUARTBufReadLocation >= ((unsigned int)&MIDIInRxBuffer[0] + (unsigned int)MIDI_UART_BUFFER_SIZE))
00A2A4  2095C0     MOV #0x95C, W0
00A2A6  508F80     SUB W1, W0, [W15]
00A2A8  390002     BRA NC, .L15
151:                               {
152:                                   pRxUARTBufReadLocation = &MIDIInRxBuffer[0];
00A2AA  B10400     SUB #0x40, W0
00A2AC  887E10     MOV W0, pRxUARTBufReadLocation
153:                               }
154:                               if(WriteIndex < 3u)
00A2AE  514FE2     SUB.B W2, #0x2, [W15]
00A2B0  3E0005     BRA GTU, .L16
155:                               {
156:                                   WriteIndex++;
00A2B2  E84102     INC.B W2, W2
00A2B4  784082     MOV.B W2, W1
00A2B6  20FD10     MOV #0xFD1, W0
00A2B8  784801     MOV.B W1, [W0]
00A2BA  3700D3     BRA .L9
157:                               }// if(WriteIndex < 3u)
158:                               else if(WriteIndex == 3)
00A2BC  514FE3     SUB.B W2, #0x3, [W15]
00A2BE  3A00D1     BRA NZ, .L9
159:                               {
160:                                   //We have accumulated a full USB-MIDI packet worth of data.
161:                                   //Prepare state machine to send the packet.
162:                                   UARTTranslatedToUSB.CodeIndexNumber = MIDI_CIN_SYSEX_START; //Might also be continuing instead of starting.
00A2C0  A90FCC     BCLR UARTTranslatedToUSB, #0
00A2C2  A92FCC     BCLR UARTTranslatedToUSB, #1
00A2C4  A84FCC     BSET UARTTranslatedToUSB, #2
00A2C6  A96FCC     BCLR UARTTranslatedToUSB, #3
163:                                   
164:                                   UARTmidiPacketTranslated = true; //Set boolean flag here to let USB code know it should prepare a packet.
00A2C8  B3C010     MOV.B #0x1, W0
00A2CA  B7EFD0     MOV.B WREG, UARTmidiPacketTranslated
00A2CC  B7EFD1     MOV.B WREG, WriteIndex
00A2CE  3700C9     BRA .L9
165:                                   WriteIndex = 1; //Move write pointer/index back to start of MIDI_x field of USB packet buffer
166:                               }// else if(WriteIndex == 3)                 
167:                           }// if(SysExCommandPending == TRUE)
168:                           else
169:                           {    
170:                               *(int8_t*)(((int8_t*)&UARTTranslatedToUSB) + WriteIndex) = *pRxUARTBufReadLocation;
00A2D0  20FD12     MOV #0xFD1, W2
00A2D2  784112     MOV.B [W2], W2
00A2D4  FB0002     SE W2, W0
00A2D6  807E11     MOV pRxUARTBufReadLocation, W1
00A2D8  20FCC3     MOV #0xFCC, W3
00A2DA  7871B1     MOV.B [W1++], [W3+W0]
171:                               pRxUARTBufReadLocation++;
00A2DC  887E11     MOV W1, pRxUARTBufReadLocation
172:                               UARTInByteCount--;
00A2DE  ED6FC6     DEC.B UARTInByteCount
173:                               if((unsigned int)pRxUARTBufReadLocation >= ((unsigned int)&MIDIInRxBuffer[0] + (unsigned int)MIDI_UART_BUFFER_SIZE))
00A2E0  2095C0     MOV #0x95C, W0
00A2E2  508F80     SUB W1, W0, [W15]
00A2E4  390002     BRA NC, .L17
174:                               {
175:                                   pRxUARTBufReadLocation = &MIDIInRxBuffer[0];
00A2E6  B10400     SUB #0x40, W0
00A2E8  887E10     MOV W0, pRxUARTBufReadLocation
176:                               }
177:                               if(ExpectedDataBytes != 0)
00A2EA  BFCFD2     MOV.B ExpectedDataBytes, WREG
00A2EC  3200BA     BRA Z, .L9
178:                               {
179:                                   WriteIndex++;
00A2EE  E84102     INC.B W2, W2
00A2F0  784182     MOV.B W2, W3
00A2F2  20FD11     MOV #0xFD1, W1
00A2F4  784883     MOV.B W3, [W1]
180:                                   ExpectedDataBytes--;
00A2F6  E94000     DEC.B W0, W0
00A2F8  B7EFD2     MOV.B WREG, ExpectedDataBytes
181:                                   //Check if we finished receiving all expected bytes in the MIDI command
182:                                   if(ExpectedDataBytes == 0)
00A2FA  3A00B3     BRA NZ, .L9
183:                                   {
184:                                       UARTmidiPacketTranslated = true; //Set boolean flag here so we know to add packet to buffer OUT
00A2FC  B3C010     MOV.B #0x1, W0
00A2FE  B7EFD0     MOV.B WREG, UARTmidiPacketTranslated
185:                                       MIDIRxCommandState = STATE_WAIT_STATUS_BYTE;                
00A300  EF6FC7     CLR.B MIDIRxCommandState
00A302  3700AF     BRA .L9
186:                                   }// if(ExpectedDataBytes == 0)
187:                               }// if(ExpectedDataBytes != 0)
188:                           }// else
189:                       }// if(MIDIRxCommandState == STATE_WAITING_BYTES)
190:                       else if(MIDIRxCommandState == STATE_WAIT_STATUS_BYTE)
00A304  E00400     CP0.B W0
00A306  3A00AD     BRA NZ, .L9
191:                       {
192:                           ExpectedDataBytes = 0;  //Will get updated with correct value, once we have parsed the status byte and know how many data bytes to expect.
00A308  EF6FD2     CLR.B ExpectedDataBytes
193:                           MIDIRxCommandState = STATE_WAITING_BYTES;   //Initialize UART recevier state machine
00A30A  B3C010     MOV.B #0x1, W0
00A30C  B7EFC7     MOV.B WREG, MIDIRxCommandState
194:                           
195:                           //We presumably have just received a status byte (MIDI command byte)
196:                           if(RxRunningStatusByte & 0x80) //Check if we received a new status (MIDI command) byte, indicated by bit 7 of UART byte being set
00A30E  BFCFCA     MOV.B RxRunningStatusByte, WREG
00A310  3B00A8     BRA NN, .L9
197:                           {
198:                               //Check if it was a system common command of some kind (upper nibble = 0xF)
199:                               if((RxRunningStatusByte & 0xF0) == 0xF0) 
00A312  200F01     MOV #0xF0, W1
00A314  608100     AND W1, W0, W2
00A316  510F81     SUB W2, W1, [W15]
00A318  3A0053     BRA NZ, .L18
200:                               {
201:                                   UARTTranslatedToUSB.MIDI_0 = RxRunningStatusByte;
00A31A  B7EFCD     MOV.B WREG, 0xFCD
202:                                   //Check for system common commands
203:                                   switch(RxRunningStatusByte)
00A31C  404FEE     ADD.B W0, #0xE, [W15]
00A31E  320036     BRA Z, .L22
00A320  3E0005     BRA GTU, .L26
00A322  404FF0     ADD.B W0, #0x10, [W15]
00A324  32000A     BRA Z, .L20
00A326  404FEF     ADD.B W0, #0xF, [W15]
00A328  3A0044     BRA NZ, .L19
00A32A  370029     BRA .L41
00A32C  404FEA     ADD.B W0, #0xA, [W15]
00A32E  32003C     BRA Z, .L24
00A330  404FE9     ADD.B W0, #0x9, [W15]
00A332  32000B     BRA Z, .L25
00A334  404FED     ADD.B W0, #0xD, [W15]
00A336  3A003D     BRA NZ, .L19
00A338  370030     BRA .L42
204:                                   {
205:                                       case(MIDI_STATUS_SYSEX_START):
206:                                           UARTTranslatedToUSB.CodeIndexNumber = MIDI_CIN_SYSEX_START;
00A33A  A90FCC     BCLR UARTTranslatedToUSB, #0
00A33C  A92FCC     BCLR UARTTranslatedToUSB, #1
00A33E  A84FCC     BSET UARTTranslatedToUSB, #2
00A340  A96FCC     BCLR UARTTranslatedToUSB, #3
207:                                           ExpectedDataBytes = 255;    //Not really expecting 255.  SysEx is variable/unknown length.
00A342  EFEFD2     SETM.B ExpectedDataBytes
208:                                           SysExCommandPending = true; //Let state machine know to perform special handling for this command.
00A344  B3C010     MOV.B #0x1, W0
00A346  B7EFC8     MOV.B WREG, SysExCommandPending
209:                                           break;
00A348  370035     BRA .L27
210:                                       case(MIDI_STATUS_SYSEX_END):
211:                                           //This case is special, since the actual data payload size is not fixed.
212:                                           //However, when we get this byte, this means the SysEx command is completing,
213:                                           //and therefore we can determine the residual number of bytes we need to send
214:                                           //based on the WriteIndex variable.
215:                                           if(WriteIndex == 1)
00A34A  BFCFD1     MOV.B WriteIndex, WREG
00A34C  504FE1     SUB.B W0, #0x1, [W15]
00A34E  3A0005     BRA NZ, .L28
216:                                               UARTTranslatedToUSB.CodeIndexNumber = MIDI_CIN_SYSEX_ENDS_1;
00A350  A80FCC     BSET UARTTranslatedToUSB, #0
00A352  A92FCC     BCLR UARTTranslatedToUSB, #1
00A354  A84FCC     BSET UARTTranslatedToUSB, #2
00A356  A96FCC     BCLR UARTTranslatedToUSB, #3
00A358  37000D     BRA .L29
217:                                           else if(WriteIndex == 2)
00A35A  504FE2     SUB.B W0, #0x2, [W15]
00A35C  3A0005     BRA NZ, .L30
218:                                               UARTTranslatedToUSB.CodeIndexNumber = MIDI_CIN_SYSEX_ENDS_2;
00A35E  A90FCC     BCLR UARTTranslatedToUSB, #0
00A360  A82FCC     BSET UARTTranslatedToUSB, #1
00A362  A84FCC     BSET UARTTranslatedToUSB, #2
00A364  A96FCC     BCLR UARTTranslatedToUSB, #3
00A366  370006     BRA .L29
219:                                           else if(WriteIndex == 3)
00A368  504FE3     SUB.B W0, #0x3, [W15]
00A36A  3A0004     BRA NZ, .L29
220:                                               UARTTranslatedToUSB.CodeIndexNumber = MIDI_CIN_SYSEX_ENDS_3;
00A36C  A80FCC     BSET UARTTranslatedToUSB, #0
00A36E  A82FCC     BSET UARTTranslatedToUSB, #1
00A370  A84FCC     BSET UARTTranslatedToUSB, #2
00A372  A96FCC     BCLR UARTTranslatedToUSB, #3
221:                                           //Complete the request here, rather than the normal handler.
222:                                           WriteIndex = 2; //Move write pointer/index back to start of buffer for next MIDI command
00A374  B3C020     MOV.B #0x2, W0
00A376  B7EFD1     MOV.B WREG, WriteIndex
223:                                           UARTmidiPacketTranslated = true; //Set boolean flag here to let USB code know it should prepare a packet.
224:                                           MIDIRxCommandState = STATE_WAIT_STATUS_BYTE;  
225:                                           SysExCommandPending = false;        //No longer handling a SysEx data flow.
00A378  EF6FC8     CLR.B SysExCommandPending
226:                                           ExpectedDataBytes = 0;
00A37A  EF6FD2     CLR.B ExpectedDataBytes
00A37C  37001D     BRA .L31
227:                                           break;
228:                                       case(MIDI_STATUS_MTC_QFRAME):
229:                                           UARTTranslatedToUSB.CodeIndexNumber = MIDI_CIN_2_BYTE_MESSAGE;
00A37E  A80FCC     BSET UARTTranslatedToUSB, #0
00A380  A92FCC     BCLR UARTTranslatedToUSB, #1
00A382  A94FCC     BCLR UARTTranslatedToUSB, #2
00A384  A96FCC     BCLR UARTTranslatedToUSB, #3
230:                                           ExpectedDataBytes = 1;
00A386  B3C010     MOV.B #0x1, W0
00A388  B7EFD2     MOV.B WREG, ExpectedDataBytes
231:                                           break;
00A38A  37006B     BRA .L9
232:                                       case(MIDI_STATUS_SONG_POSITION):
233:                                           UARTTranslatedToUSB.CodeIndexNumber = MIDI_CIN_3_BYTE_MESSAGE;
00A38C  A90FCC     BCLR UARTTranslatedToUSB, #0
00A38E  A82FCC     BSET UARTTranslatedToUSB, #1
00A390  A94FCC     BCLR UARTTranslatedToUSB, #2
00A392  A96FCC     BCLR UARTTranslatedToUSB, #3
234:                                           ExpectedDataBytes = 2;
00A394  B3C020     MOV.B #0x2, W0
00A396  B7EFD2     MOV.B WREG, ExpectedDataBytes
235:                                           break;
00A398  370064     BRA .L9
236:                                       case(MIDI_STATUS_SONG_SELECT):
237:                                           UARTTranslatedToUSB.CodeIndexNumber = MIDI_CIN_2_BYTE_MESSAGE;
00A39A  A80FCC     BSET UARTTranslatedToUSB, #0
00A39C  A92FCC     BCLR UARTTranslatedToUSB, #1
00A39E  A94FCC     BCLR UARTTranslatedToUSB, #2
00A3A0  A96FCC     BCLR UARTTranslatedToUSB, #3
238:                                           ExpectedDataBytes = 1;
00A3A2  B3C010     MOV.B #0x1, W0
00A3A4  B7EFD2     MOV.B WREG, ExpectedDataBytes
239:                                           break;
00A3A6  37005D     BRA .L9
240:                                       case(MIDI_STATUS_TUNE_REQUEST):
241:                                           UARTTranslatedToUSB.CodeIndexNumber = MIDI_CIN_1_BYTE_MESSAGE;
00A3A8  A90FCC     BCLR UARTTranslatedToUSB, #0
00A3AA  A92FCC     BCLR UARTTranslatedToUSB, #1
00A3AC  A94FCC     BCLR UARTTranslatedToUSB, #2
00A3AE  A96FCC     BCLR UARTTranslatedToUSB, #3
242:                                           ExpectedDataBytes = 0;
243:                                           break;
00A3B0  370001     BRA .L27
244:                                       default:
245:                                           MIDIRxCommandState = STATE_WAIT_STATUS_BYTE;
00A3B2  EF6FC7     CLR.B MIDIRxCommandState
246:                                           ExpectedDataBytes = 0;                            
247:                                           break;
248:                                   }//switch(RxRunningStatusByte)    
249:                                   
250:                                   //Check if we finished receiving all expected bytes in the MIDI command.
251:                                   //This would be the case for system commands that consist only of the status byte. 
252:                                   if((ExpectedDataBytes == 0) && (MIDIRxCommandState = STATE_WAITING_BYTES))  //Not note really waiting for extra bytes in this scenario.
00A3B4  E24FD2     CP0.B ExpectedDataBytes
00A3B6  3A0055     BRA NZ, .L9
253:                                   {
254:                                       //Prepare state machine to prepare USB transmit packet.
255:                                       UARTmidiPacketTranslated = true; //Set boolean flag here to let USB code know it should prepare a packet.
00A3B8  B3C010     MOV.B #0x1, W0
00A3BA  B7EFD0     MOV.B WREG, UARTmidiPacketTranslated
256:                                       MIDIRxCommandState = STATE_WAIT_STATUS_BYTE;                
00A3BC  EF6FC7     CLR.B MIDIRxCommandState
00A3BE  370051     BRA .L9
257:                                   } 
258:                               }//if((RxRunningStatusByte & 0xF0) == 0xF0) 
259:                               else
260:                               {
261:                                   //Must have been a normal MIDI command status byte
262:                                   UARTTranslatedToUSB.MIDI_0 = RxRunningStatusByte;
00A3C0  B7EFCD     MOV.B WREG, 0xFCD
263:                                   WriteIndex = 2;
00A3C2  B3C022     MOV.B #0x2, W2
00A3C4  20FD14     MOV #0xFD1, W4
00A3C6  784A02     MOV.B W2, [W4]
264:                                   RxRunningStatusByte &= 0xF0;   //Strip off the channel bits to get the command by itself
00A3C8  B3CF01     MOV.B #0xF0, W1
00A3CA  604001     AND.B W0, W1, W0
00A3CC  B7EFCA     MOV.B WREG, RxRunningStatusByte
265:                                   switch(RxRunningStatusByte)
00A3CE  B3CB01     MOV.B #0xB0, W1
00A3D0  504F81     SUB.B W0, W1, [W15]
00A3D2  32002A     BRA Z, .L36
00A3D4  3E000A     BRA GTU, .L40
00A3D6  B3C901     MOV.B #0x90, W1
00A3D8  504F81     SUB.B W0, W1, [W15]
00A3DA  320018     BRA Z, .L34
00A3DC  40C0F0     ADD.B W1, #0x10, W1
00A3DE  504F81     SUB.B W0, W1, [W15]
00A3E0  32001C     BRA Z, .L35
00A3E2  B3C801     MOV.B #0x80, W1
00A3E4  504F81     SUB.B W0, W1, [W15]
00A3E6  3A003C     BRA NZ, .L32
00A3E8  37000A     BRA .L43
00A3EA  B3CD01     MOV.B #0xD0, W1
00A3EC  504F81     SUB.B W0, W1, [W15]
00A3EE  32002A     BRA Z, .L38
00A3F0  40C0F0     ADD.B W1, #0x10, W1
00A3F2  504F81     SUB.B W0, W1, [W15]
00A3F4  32002E     BRA Z, .L39
00A3F6  B3CC01     MOV.B #0xC0, W1
00A3F8  504F81     SUB.B W0, W1, [W15]
00A3FA  3A0032     BRA NZ, .L32
00A3FC  37001C     BRA .L44
266:                                   {
267:                                       case(MIDI_CIN_NOTE_OFF << 4):
268:                                           ExpectedDataBytes = 2;      //Expect 2 data bytes to follow
00A3FE  B3C020     MOV.B #0x2, W0
00A400  B7EFD2     MOV.B WREG, ExpectedDataBytes
269:                                           UARTTranslatedToUSB.CodeIndexNumber = MIDI_CIN_NOTE_OFF;
00A402  A90FCC     BCLR UARTTranslatedToUSB, #0
00A404  A92FCC     BCLR UARTTranslatedToUSB, #1
00A406  A94FCC     BCLR UARTTranslatedToUSB, #2
00A408  A86FCC     BSET UARTTranslatedToUSB, #3
270:                                           break;
00A40A  37002B     BRA .L9
271:                                       case(MIDI_CIN_NOTE_ON << 4):
272:                                           ExpectedDataBytes = 2;      //Expect 2 data bytes to follow
00A40C  B3C020     MOV.B #0x2, W0
00A40E  B7EFD2     MOV.B WREG, ExpectedDataBytes
273:                                           UARTTranslatedToUSB.CodeIndexNumber = MIDI_CIN_NOTE_ON;
00A410  A80FCC     BSET UARTTranslatedToUSB, #0
00A412  A92FCC     BCLR UARTTranslatedToUSB, #1
00A414  A94FCC     BCLR UARTTranslatedToUSB, #2
00A416  A86FCC     BSET UARTTranslatedToUSB, #3
274:                                           break;
00A418  370024     BRA .L9
275:                                       case(MIDI_CIN_POLY_KEY_PRESS << 4):
276:                                           ExpectedDataBytes = 2;      //Expect 2 data bytes to follow
00A41A  B3C020     MOV.B #0x2, W0
00A41C  B7EFD2     MOV.B WREG, ExpectedDataBytes
277:                                           UARTTranslatedToUSB.CodeIndexNumber = MIDI_CIN_POLY_KEY_PRESS;
00A41E  A90FCC     BCLR UARTTranslatedToUSB, #0
00A420  A82FCC     BSET UARTTranslatedToUSB, #1
00A422  A94FCC     BCLR UARTTranslatedToUSB, #2
00A424  A86FCC     BSET UARTTranslatedToUSB, #3
278:                                           break;
00A426  37001D     BRA .L9
279:                                       case(MIDI_CIN_CONTROL_CHANGE << 4):
280:                                           ExpectedDataBytes = 2;      //Expect 2 data bytes to follow
00A428  B3C020     MOV.B #0x2, W0
00A42A  B7EFD2     MOV.B WREG, ExpectedDataBytes
281:                                           UARTTranslatedToUSB.CodeIndexNumber = MIDI_CIN_CONTROL_CHANGE;
00A42C  A80FCC     BSET UARTTranslatedToUSB, #0
00A42E  A82FCC     BSET UARTTranslatedToUSB, #1
00A430  A94FCC     BCLR UARTTranslatedToUSB, #2
00A432  A86FCC     BSET UARTTranslatedToUSB, #3
282:                                           break;
00A434  370016     BRA .L9
283:                                       case(MIDI_CIN_PROGRAM_CHANGE << 4):
284:                                           ExpectedDataBytes = 1;      //Expect 1 data bytes to follow
00A436  B3C010     MOV.B #0x1, W0
00A438  B7EFD2     MOV.B WREG, ExpectedDataBytes
285:                                           UARTTranslatedToUSB.CodeIndexNumber = MIDI_CIN_PROGRAM_CHANGE;
00A43A  A90FCC     BCLR UARTTranslatedToUSB, #0
00A43C  A92FCC     BCLR UARTTranslatedToUSB, #1
00A43E  A84FCC     BSET UARTTranslatedToUSB, #2
00A440  A86FCC     BSET UARTTranslatedToUSB, #3
286:                                           break;
00A442  37000F     BRA .L9
287:                                       case(MIDI_CIN_CHANNEL_PREASURE << 4):
288:                                           ExpectedDataBytes = 1;      //Expect 1 data bytes to follow
00A444  B3C010     MOV.B #0x1, W0
00A446  B7EFD2     MOV.B WREG, ExpectedDataBytes
289:                                           UARTTranslatedToUSB.CodeIndexNumber = MIDI_CIN_CHANNEL_PREASURE;
00A448  A80FCC     BSET UARTTranslatedToUSB, #0
00A44A  A92FCC     BCLR UARTTranslatedToUSB, #1
00A44C  A84FCC     BSET UARTTranslatedToUSB, #2
00A44E  A86FCC     BSET UARTTranslatedToUSB, #3
290:                                           break;
00A450  370008     BRA .L9
291:                                       case(MIDI_CIN_PITCH_BEND_CHANGE << 4):
292:                                           ExpectedDataBytes = 2;      //Expect 2 data bytes to follow
00A452  B3C020     MOV.B #0x2, W0
00A454  B7EFD2     MOV.B WREG, ExpectedDataBytes
293:                                           UARTTranslatedToUSB.CodeIndexNumber = MIDI_CIN_PITCH_BEND_CHANGE;
00A456  A90FCC     BCLR UARTTranslatedToUSB, #0
00A458  A82FCC     BSET UARTTranslatedToUSB, #1
00A45A  A84FCC     BSET UARTTranslatedToUSB, #2
00A45C  A86FCC     BSET UARTTranslatedToUSB, #3
294:                                           break;
00A45E  370001     BRA .L9
295:                                       default:
296:                                           MIDIRxCommandState = STATE_WAIT_STATUS_BYTE;
00A460  EF6FC7     CLR.B MIDIRxCommandState
297:                                           ExpectedDataBytes = 0;
298:                                           break;
299:                                   }//switch(RxRunningStatusByte)                           
300:                               }//else        
301:                           }//if(RxRunningStatusByte & 0x80) 
302:                       }//else if(MIDIRxCommandState == STATE_WAIT_STATUS_BYTE)
303:                   }//if(UARTInByteCount > 0)
304:                   
305:               
306:                /* this will be handled separately in device host app. But for now I will keep it here 
307:               
308:                   // If the UART to USB translation has completed, then add packet to the OUT endpoint buffer(s)
309:                   if(UARTmidiPacketTranslated == true)
310:                   {
311:                       int8_t currentEndpoint;
312:                       
313:                       // Clear the flag
314:                       UARTmidiPacketTranslated = false;
315:                       
316:                       // Loop through the endpoints
317:                       for(currentEndpoint = 0; currentEndpoint < USBHostMIDINumberOfEndpoints(deviceHandle); currentEndpoint++)
318:                       {
319:                           // If this is an OUT endpoint
320:                           if(USBHostMIDIEndpointDirection(deviceHandle, currentEndpoint) == OUT)
321:                           {
322:                               // Then add the translated MIDI packet to its buffer and increment (we're only doing one MIDI packet per USB packet)
323:                               endpointBuffers[currentEndpoint].pBufWriteLocation->Val = UARTTranslatedToUSB.Val;
324:                               endpointBuffers[currentEndpoint].pBufWriteLocation += endpointBuffers[currentEndpoint].numOfMIDIPackets;
325:                               
326:                               // Check to see if we've gotten to the end of the USB buffer array
327:                               if(endpointBuffers[currentEndpoint].pBufWriteLocation - endpointBuffers[currentEndpoint].bufferStart
328:                               >= endpointBuffers[currentEndpoint].numOfMIDIPackets * MIDI_USB_BUFFER_SIZE)
329:                               {
330:                                   // If so, then loop it back to the beginning of the array
331:                                   endpointBuffers[currentEndpoint].pBufWriteLocation = endpointBuffers[currentEndpoint].bufferStart;
332:                               }
333:                               
334:                               // If we want to send the data to just one endpoint, then we'll break, otherwise we'll spam all of the OUT endpoints
335:                               #ifdef SEND_TO_ONE_EP
336:                                   break;
337:                               #endif
338:                           }// if(USBHostMIDIEndpointDirection(deviceHandle, currentEndpoint) == OUT)
339:                       }// for(currentEndpoint = 0; currentEndpoint < USBHostMIDINumberOfEndpoints(deviceHandle); currentEndpoint++)    
340:                   }// if(UARTmidiPacketTranslated == TRUE)
341:                 */
342:               
343:               }//void MIDI_host_InJackTasks    
00A462  060000     RETURN
344:                   
345:                   
---  /home/sladekm/MPLABXProjects/USB_Device_Host_MIDI.X/ezbl_integration/ex_boot_usb_msd.merge.S  ------
                                                  1:     /**
                                                  2:      * EZBL Bootloader Code and RAM Allocation
                                                  3:      *
                                                  4:      * Automatically generated file - not intended for manual editing. If changes 
                                                  5:      * are made here, they will normally be overwritten when you rebuild your 
                                                  6:      * Bootloader. If necessary, maintain a backup copy and manually merge your 
                                                  7:      * customizations back in.
                                                  8:      * 
                                                  9:      * Built for:
                                                  10:     *     PIC24FJ64GB002
                                                  11:     * From:
                                                  12:     *     dist/PIC24FJ64GB002/production/Newexp16_pic24fj64gb002_pim.x.production.elf
                                                  13:     * Using build configuration:
                                                  14:     *     PIC24FJ64GB002
                                                  15:     * 
                                                  16:     * Tool paths:
                                                  17:     *     /home/sladekm/software/microchip/XC16/v1.36
                                                  18:     *     /opt/microchip/mplabx/v5.15
                                                  19:     */
                                                  20:    
                                                  21:     ; Validate matching target processors between Bootloader and Application projects.
                                                  22:     ; If you get this error and wish to force the two dissimilar targets together anyway,
                                                  23:     ; you can comment out these .error statements. However, something will likely be
                                                  24:     ; broken at run time, so do so only if you are sure of what you are doing.
                                                  25:        .ifndef __24FJ64GB002
                                                  26:        .error "Bootloader's Newexp16_pic24fj64gb002_pim.x.merge.S/.gld files were generated for a different target processor."
                                                  27:        .error "Recompile this Application project or the Newexp16_pic24fj64gb002_pim.x Bootloader project for the same hardware."
                                                  28:        .endif
                                                  29:    
                                                  30:    
                                                  31:    ;----Target Bootloader ID and this Application Version meta data for .bl2 file header----
                                                  32:        .pushsection    .info.EZBL_metaParameters, info, keep
                                                  33:        .weak   _BOOTID_HASH0
                                                  34:        .weak   _BOOTID_HASH1
                                                  35:        .weak   _BOOTID_HASH2
                                                  36:        .weak   _BOOTID_HASH3
                                                  37:        .weak   _APPID_VER_BUILD
                                                  38:        .weak   _APPID_VER_MINOR
                                                  39:        .weak   _APPID_VER_MAJOR
                                                  40:    _BOOTID_HASH0 = 0x869CF88A
                                                  41:    _BOOTID_HASH1 = 0x93146779
                                                  42:    _BOOTID_HASH2 = 0x08A06801
                                                  43:    _BOOTID_HASH3 = 0x491B0C9D
                                                  44:    EZBL_metaAppIDVerBuild:
                                                  45:        .long   _APPID_VER_BUILD
                                                  46:    EZBL_metaAppIDVerMinor:
                                                  47:        .short  _APPID_VER_MINOR
                                                  48:    EZBL_metaAppIDVerMajor:
                                                  49:        .short  _APPID_VER_MAJOR
                                                  50:        .popsection
                                                  51:    
                                                  52:    ;----Bootloader reserved static RAM----
                                                  53:    #if defined(EZBL_HIDE_BOOT_SYMBOLS)
                                                  54:        ; Bootloader RAM block intended for data region
                                                  55:        ; 0x0A68 to 0x0004, length 0x0004 (4 bytes)
                                                  56:        .pushsection    EZBL_RAM_AT_0x0A68, address(0x0A68), persist, keep
                                                  57:        .global     _EZBL_ForwardBootloaderISR
                                                  58:        .type       _EZBL_ForwardBootloaderISR, @object
                                                  59:    _EZBL_ForwardBootloaderISR: ; This variable cannot be hidden since ISR dispatch code uses it
                                                  60:        .space      0x4
                                                  61:        .size       _EZBL_ForwardBootloaderISR, . - _EZBL_ForwardBootloaderISR
                                                  62:        .popsection
                                                  63:    #endif
                                                  64:    
                                                  65:    #if !defined(EZBL_HIDE_BOOT_SYMBOLS)
                                                  66:        ; Bootloader RAM block intended for 'data' region
                                                  67:        ; 0x0A50 to 0x0F7E, length 0x052E (1326 bytes)
                                                  68:        .pushsection    EZBL_RAM_AT_0x0A50, address(0x0A50), persist, keep
                                                  69:        .space      0x52E
                                                  70:        .popsection
                                                  71:        ; Bootloader RAM block intended for 'data' region
                                                  72:        ; 0x1000 to 0x15E8, length 0x05E8 (1512 bytes)
                                                  73:        .pushsection    EZBL_RAM_AT_0x1000, address(0x1000), persist, keep
                                                  74:        .space      0x5E8
                                                  75:        .popsection
                                                  76:    #endif
                                                  77:    
                                                  78:    ;----App erasable items that the Bootloader knows about----
                                                  79:        .pushsection    EZBL_AppErasable, address(0x004400), code, keep
                                                  80:        ; EZBL_appBootloadState - Base address of EZBL_INSTALLED_FLAGS structure (18 bytes/6 instruction words)
                                                  81:        .pword      0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0x12CDFF
                                                  82:    
                                                  83:        ; _EZBL_APP_RESET_BASE
                                                  84:        .extern     __reset
00440C  04A0B4     GOTO 0xA0B4                    85:        goto        __reset
                                                  86:    
                                                  87:        ; Interrupt Goto Table follows for 0x5C addresses (0x004410 to 0x00446C)
                                                  88:        ; The .igt section is defined in the linker script since this is an application
                                                  89:        ; erasable/updatable structure.
                                                  90:        .popsection
                                                  91:    
                                                  92:    
                                                  93:    ;----Bootloader reserved program memory----
                                                  94:    
                                                  95:        ; Bootloader code block intended for program region 'reset'
                                                  96:        ; 0x000000 to 0x000004, length 0x000004 (6 bytes; needs 0 pages)
                                                  97:        .pushsection    EZBL_ROM_AT_0x000000, address(0x000000), code, keep
                                                  98:        .pword      0x04023C, 0x000000                                                              /* 0x000000 <.....                   */
                                                  99:        .popsection
                                                  100:   
                                                  101:       ; Bootloader code block intended for program region 'ivt'
                                                  102:       ; 0x000004 to 0x000100, length 0x0000FC (378 bytes; needs 0 pages)
                                                  103:       .pushsection    EZBL_ROM_AT_0x000004, address(0x000004), code, keep
                                                  104:       .pword      0x00446A, 0x004410, 0x004412, 0x004414, 0x004416, 0x00446A, 0x00446A, 0x00446A  /* 0x000004 jD..D..D..D..D.jD.jD.jD. */
                                                  105:       .pword      0x004418, 0x00441A, 0x00441C, 0x000230, 0x00446A, 0x004420, 0x004422, 0x004424  /* 0x000014 .D..D..D.0..jD. D."D.$D. */
                                                  106:       .pword      0x004426, 0x004428, 0x00442A, 0x00442C, 0x00442E, 0x004430, 0x00446A, 0x00446A  /* 0x000024 &D.(D.*D.,D..D.0D.jD.jD. */
                                                  107:       .pword      0x004432, 0x004434, 0x004436, 0x004438, 0x00443A, 0x00446A, 0x00446A, 0x00446A  /* 0x000034 2D.4D.6D.8D.:D.jD.jD.jD. */
                                                  108:       .pword      0x00446A, 0x00443C, 0x00443E, 0x004440, 0x004442, 0x004444, 0x004446, 0x004448  /* 0x000044 jD.<D.>D.@D.BD.DD.FD.HD. */
                                                  109:       .pword      0x00444A, 0x00444C, 0x00446A, 0x00446A, 0x00446A, 0x00444E, 0x004450, 0x004452  /* 0x000054 JD.LD.jD.jD.jD.ND.PD.RD. */
                                                  110:       .pword      0x00446A, 0x004454, 0x00446A, 0x00446A, 0x00446A, 0x004456, 0x00446A, 0x00446A  /* 0x000064 jD.TD.jD.jD.jD.VD.jD.jD. */
                                                  111:       .pword      0x00446A, 0x004458, 0x00445A, 0x00446A, 0x00446A, 0x00446A, 0x00446A, 0x00446A  /* 0x000074 jD.XD.ZD.jD.jD.jD.jD.jD. */
                                                  112:       .pword      0x00446A, 0x00446A, 0x00446A, 0x00446A, 0x00446A, 0x00446A, 0x00445C, 0x00446A  /* 0x000084 jD.jD.jD.jD.jD.jD.\D.jD. */
                                                  113:       .pword      0x00446A, 0x00445E, 0x004460, 0x004462, 0x00446A, 0x00446A, 0x00446A, 0x00446A  /* 0x000094 jD.^D.`D.bD.jD.jD.jD.jD. */
                                                  114:       .pword      0x004464, 0x00446A, 0x00446A, 0x00446A, 0x00446A, 0x004466, 0x00446A, 0x00446A  /* 0x0000A4 dD.jD.jD.jD.jD.fD.jD.jD. */
                                                  115:       .pword      0x00446A, 0x00446A, 0x00446A, 0x00446A, 0x00446A, 0x00446A, 0x000236, 0xFFFFFF  /* 0x0000B4 jD.jD.jD.jD.jD.jD.6..... */
                                                  116:       .pword      0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF  /* 0x0000C4 ........................ */
                                                  117:       .pword      0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF  /* 0x0000D4 ........................ */
                                                  118:       .pword      0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF  /* 0x0000E4 ........................ */
                                                  119:       .pword      0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF                      /* 0x0000F4 ..................       */
                                                  120:       .popsection
                                                  121:   
                                                  122:       ; Bootloader code block intended for program region 'aivt'
                                                  123:       ; 0x000104 to 0x000200, length 0x0000FC (378 bytes; needs 0 pages)
                                                  124:       .pushsection    EZBL_ROM_AT_0x000104, address(0x000104), code, keep
                                                  125:       .pword      0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000  /* 0x000104 ........................ */
                                                  126:       .pword      0x000000, 0x000000, 0x000000, 0x00408E, 0x000000, 0x000000, 0x000000, 0x000000  /* 0x000114 ..........@............. */
                                                  127:       .pword      0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000  /* 0x000124 ........................ */
                                                  128:       .pword      0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000  /* 0x000134 ........................ */
                                                  129:       .pword      0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000  /* 0x000144 ........................ */
                                                  130:       .pword      0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000  /* 0x000154 ........................ */
                                                  131:       .pword      0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000  /* 0x000164 ........................ */
                                                  132:       .pword      0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000  /* 0x000174 ........................ */
                                                  133:       .pword      0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000  /* 0x000184 ........................ */
                                                  134:       .pword      0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000  /* 0x000194 ........................ */
                                                  135:       .pword      0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000  /* 0x0001A4 ........................ */
                                                  136:       .pword      0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000304, 0x000000  /* 0x0001B4 ........................ */
                                                  137:       .pword      0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000  /* 0x0001C4 ........................ */
                                                  138:       .pword      0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000  /* 0x0001D4 ........................ */
                                                  139:       .pword      0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000  /* 0x0001E4 ........................ */
                                                  140:       .pword      0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000                      /* 0x0001F4 ..................       */
                                                  141:       .popsection
                                                  142:   
                                                  143:       ; Bootloader code block intended for program region 'program'
                                                  144:       ; 0x000200 to 0x004400, length 0x004200 (25344 bytes; needs 16 pages)
                                                  145:       .pushsection    EZBL_ROM_AT_0x000200, address(0x000200), code, keep
                                                  146:       .pword      0x004400, 0x008000, 0x00A000, 0x00ABF8, 0x000000, 0x00440C, 0x008000, 0x00A000  /* 0x000200 .D..............D....... */
                                                  147:       .pword      0x00ABF8, 0x00AC00, 0x000000, 0x004400, 0x008000, 0x00A000, 0x004400, 0x00440C  /* 0x000210 ..........D........D..D. */
                                                  148:       .pword      0x00ABFE, 0x00AC00, 0x00ABF8, 0x00000C, 0x00FF33, 0x00FFC0, 0x003B8E, 0x003F60  /* 0x000220 ............3......;.`?. */
                                                  149:       .pword      0xAF0A68, 0x3720F5, 0x371F2C, 0xAF2A68, 0x372117, 0x370064, 0x215E8F, 0x227F0E  /* 0x000230 h... 7,.7h*..!7d.7.^!.." */
                                                  150:       .pword      0x88010E, 0x000000, 0x200000, 0xE00000, 0x320002, 0x200100, 0x880220, 0x070014  /* 0x000240 ........ .....2..  ..... */
                                                  151:       .pword      0x07008A, 0xE00000, 0x3A0003, 0x20E8A0, 0x200001, 0x370002, 0x200000, 0x200001  /* 0x000250 ........:.. .. ..7.. ..  */
                                                  152:       .pword      0x700F81, 0x320001, 0x070014, 0x200000, 0xE00000, 0x320002, 0x020000, 0x000000  /* 0x000260 ..p..2..... .....2...... */
                                                  153:       .pword      0x02418C, 0x000000, 0xDA4000, 0xFE0000, 0xA94044, 0x200540, 0xE00000, 0x320003  /* 0x000270 .A.....@....D@.@. .....2 */
                                                  154:       .pword      0x200010, 0x8801A0, 0xA84044, 0x060000, 0x781F8A, 0x781F8B, 0x060000, 0x880191  /* 0x000280 .. ...D@......x..x...... */
                                                  155:       .pword      0x780480, 0xEB0000, 0x37001A, 0x4484E2, 0xB4A032, 0xBA0599, 0x4484E2, 0xB4A032  /* 0x000290 ..x.....7..D2.......D2.. */
                                                  156:       .pword      0xBA0699, 0x4484E2, 0xB4A032, 0xEB0600, 0xDE6F47, 0xB207FD, 0xE16C63, 0x3A0003  /* 0x0002A0 .....D2.....Go....cl...: */
                                                  157:       .pword      0x07FFEB, 0xEB0000, 0x37000A, 0xE16C60, 0x3A0004, 0xEB5D00, 0xE9058B, 0x3EFFFD  /* 0x0002B0 ........7`l...:.]......> */
                                                  158:       .pword      0x370004, 0xE16861, 0x320001, 0xEB8600, 0x07000B, 0xBAC719, 0xBA0519, 0xE0040E  /* 0x0002C0 ..7ah...2............... */
                                                  159:       .pword      0x3A0003, 0xE0000A, 0x3AFFE0, 0x060000, 0xB207FE, 0x88019E, 0x78048A, 0x37FFF5  /* 0x0002D0 ..:.....:...........x..7 */
                                                  160:       .pword      0xBA5D39, 0xE9058B, 0x32000C, 0xBA5D29, 0xE9058B, 0x320008, 0xE0000C, 0x3A0003  /* 0x0002E0 9]......2)]......2.....: */
                                                  161:       .pword      0x4484E2, 0xB4A032, 0x37FFF5, 0xBADD19, 0xE9058B, 0x3AFFFA, 0xE80489, 0x4484E1  /* 0x0002F0 ..D2....7........:.....D */
                                                  162:       .pword      0xB4A032, 0x060000, 0xF80036, 0xBE9F80, 0xBE9F82, 0xBE9F84, 0xBE9F86, 0xF80034  /* 0x000300 2.....6..............4.. */
                                                  163:       .pword      0x200010, 0x8801A0, 0x0744FE, 0xF90034, 0xBE034F, 0xBE024F, 0xBE014F, 0xBE004F  /* 0x000310 .. ....D.4..O..O..O..O.. */
                                                  164:       .pword      0xF90036, 0x064000, 0xBE9F88, 0x780480, 0x807BE0, 0xE00000, 0x3A0004, 0x07000E  /* 0x000320 6...@......x.{......:... */
                                                  165:       .pword      0xEB8400, 0xE00000, 0x350008, 0x807BE8, 0xE00009, 0x320005, 0x440009, 0x070006  /* 0x000330 ........5.{......2..D... */
                                                  166:       .pword      0xE00000, 0x3D0001, 0xEB8400, 0x780008, 0xBE044F, 0x060000, 0x780080, 0xE00001  /* 0x000340 .....=.....xO.......x... */
                                                  167:       .pword      0x3A0003, 0x212000, 0x887BE0, 0x050000, 0xEB8000, 0x215E82, 0x508F82, 0x3E0002  /* 0x000350 ..:. !.{........^!..P..> */
                                                  168:       .pword      0x887BE1, 0xEB0000, 0x060000, 0x050000, 0xB82260, 0x200206, 0xD00000, 0xD28081  /* 0x000360 .{..........`"... ...... */
                                                  169:       .pword      0xD28204, 0xD28285, 0xA00000, 0x520202, 0x5A8283, 0x310003, 0x420202, 0x4A8283  /* 0x000370 ...........R..Z..1..B..J */
                                                  170:       .pword      0xA10000, 0xE90306, 0x3AFFF3, 0x060000, 0xE00000, 0x32002F, 0x7801C0, 0x518FE3  /* 0x000380 ........:....../.2..x..Q */
                                                  171:       .pword      0x36002C, 0xA30803, 0x3A002A, 0x807B61, 0xE00001, 0x320002, 0x500F81, 0x310004  /* 0x000390 ,.6...*.:a{......2..P..1 */
                                                  172:       .pword      0x980011, 0x887B60, 0x370016, 0x780082, 0x900111, 0xE00002, 0x320002, 0x510F80  /* 0x0003A0 ...`{...7..x........2..Q */
                                                  173:       .pword      0x39FFFA, 0x780211, 0x408284, 0x500F85, 0x390018, 0x528F80, 0x3A0003, 0x420883  /* 0x0003B0 ..9..x..@..P..9..R..:..B */
                                                  174:       .pword      0x780001, 0x370007, 0xE00002, 0x320003, 0x400183, 0x510F83, 0x39000E, 0x980012  /* 0x0003C0 ..x..7.....2..@..Q..9... */
                                                  175:       .pword      0x980090, 0x900090, 0xE00001, 0x320009, 0x400110, 0x508F82, 0x3A0006, 0x20F6A2  /* 0x0003D0 ...........2..@..P..:..  */
                                                  176:       .pword      0xEB0900, 0x780110, 0x410811, 0x900091, 0x980011, 0x060000, 0xBE9F88, 0x780400  /* 0x0003E0 .....x..A..............x */
                                                  177:       .pword      0x807B51, 0xE00001, 0x320002, 0x780001, 0x37000D, 0x807B61, 0x20F6C0, 0x370004  /* 0x0003F0 Q{......2..x..7a{... ..7 */
                                                  178:       .pword      0x540F91, 0x360025, 0xE88001, 0x900091, 0xE00001, 0x3AFFFA, 0x370010, 0x540F92  /* 0x000400 ..T%.6...........:..7..T */
                                                  179:       .pword      0x36001E, 0xE88002, 0x780110, 0xE00002, 0x3AFFFA, 0x780111, 0x807B61, 0x20F6C0  /* 0x000410 ..6.....x.....:..xa{...  */
                                                  180:       .pword      0x370004, 0x540F91, 0x360014, 0xE88001, 0x900091, 0x508F82, 0x3AFFFA, 0x807BD9  /* 0x000420 ..7..T..6........P..:.{. */
                                                  181:       .pword      0x548F88, 0x310001, 0x780488, 0x780009, 0x070067, 0xE00000, 0x3A0004, 0x548F88  /* 0x000430 ..T..1..x..xg.......:..T */
                                                  182:       .pword      0x320005, 0xD10489, 0x37FFF5, 0x781809, 0x07FF9F, 0x37FFD2, 0xEB0000, 0xBE044F  /* 0x000440 ..2.....7..x.....7...O.. */
                                                  183:       .pword      0x060000, 0x781F88, 0x400463, 0xA10008, 0xEB0080, 0x540F80, 0x360021, 0x540FE3  /* 0x000450 .....xc.@........T!.6..T */
                                                  184:       .pword      0x3E0001, 0x200048, 0x780008, 0x07FFC2, 0xEB0080, 0xE00000, 0x320019, 0x780090  /* 0x000460 ..>H. ..x...........2..x */
                                                  185:       .pword      0x780191, 0x518164, 0x510F88, 0x310003, 0x900111, 0x780802, 0x370007, 0x408108  /* 0x000470 ..xd.Q..Q..1.....x..7..@ */
                                                  186:       .pword      0x780802, 0x900191, 0x980113, 0x780110, 0x140911, 0x780888, 0x780110, 0xEB0000  /* 0x000480 ..x........x.....x..x... */
                                                  187:       .pword      0xE00002, 0x320004, 0x900192, 0xE00003, 0x320001, 0xE88002, 0x887B50, 0xE88081  /* 0x000490 .....2........2...P{.... */
                                                  188:       .pword      0x780001, 0x78044F, 0x060000, 0x370009, 0x784230, 0x7841B1, 0x524F83, 0x320004  /* 0x0004A0 ..xO.x.....70Bx.Ax.OR..2 */
                                                  189:       .pword      0x200010, 0x310006, 0xEB8000, 0x060000, 0xE90102, 0xE00002, 0x3AFFF5, 0xEB0000  /* 0x0004B0 .. ..1..............:... */
                                                  190:       .pword      0x060000, 0x780180, 0x370002, 0x7859B1, 0xE90102, 0xE00002, 0x3AFFFC, 0x060000  /* 0x0004C0 .....x..7.Yx........:... */
                                                  191:       .pword      0x780180, 0x370002, 0x785981, 0xE90102, 0xE00002, 0x3AFFFC, 0x060000, 0x780080  /* 0x0004D0 ..x..7.Yx........:.....x */
                                                  192:       .pword      0x780101, 0xE00431, 0x3AFFFD, 0x510000, 0x060000, 0x780180, 0x370002, 0x785984  /* 0x0004E0 ..x1....:..Q.....x..7.Yx */
                                                  193:       .pword      0xE90102, 0xE00002, 0x320006, 0x784231, 0xE00404, 0x3AFFF9, 0x370002, 0xEB5980  /* 0x0004F0 ........21Bx.....:..7.Y. */
                                                  194:       .pword      0xE90102, 0xE00002, 0x3AFFFC, 0x060000, 0x780080, 0xEB0000, 0xE00001, 0x340005  /* 0x000500 ........:.....x........4 */
                                                  195:       .pword      0x780001, 0x07FF08, 0x400FE1, 0x3A0001, 0xEB0000, 0x060000, 0xFA0034, 0xBE9F88  /* 0x000510 ..x.....@..:......4..... */
                                                  196:       .pword      0xBE9F8A, 0x780400, 0xB3C64A, 0xB3C25B, 0xEB4480, 0xE00418, 0x3A0003, 0x200010  /* 0x000520 .....xJ..[...D......:..  */
                                                  197:       .pword      0x885280, 0x370102, 0x9FCF8B, 0x9FCF99, 0x9FCFA9, 0x9FCFB9, 0x9FCFC9, 0x9FCFD9  /* 0x000530 .R...7.................. */
                                                  198:       .pword      0x9FCFE9, 0x9FCFF9, 0x9FD789, 0x9FD799, 0x200086, 0x200007, 0x2FFD35, 0x42828F  /* 0x000540 .............. .. 5./..B */
                                                  199:       .pword      0xB3C0A4, 0x2FFC83, 0x41818F, 0xB3C012, 0x784089, 0x784018, 0x07102B, 0x9FD7A0  /* 0x000550 ...../..A....@x.@x+..... */
                                                  200:       .pword      0xE00400, 0x320003, 0x370020, 0x073D76, 0x074199, 0x2FFC42, 0x41010F, 0x2FFD21  /* 0x000560 .....2 .7v=..A.B./..A!./ */
                                                  201:       .pword      0x40808F, 0x784018, 0x0719D7, 0xE00400, 0x32FFF6, 0x97D02F, 0xE00400, 0x3A0013  /* 0x000570 ..@.@x........2/.......: */
                                                  202:       .pword      0x20A500, 0x97D92F, 0xDD114C, 0x97D89F, 0xDD08C8, 0x410101, 0x97D0FF, 0xFB8081  /* 0x000580 .. /..L..........A...... */
                                                  203:       .pword      0x410101, 0x97D88F, 0xFB8081, 0xDD08C4, 0x410081, 0x980021, 0x900090, 0xA00001  /* 0x000590 ..A...........A!........ */
                                                  204:       .pword      0x980011, 0xEB0800, 0x3700C9, 0xB3C030, 0x9FCF80, 0x9FCF99, 0x9FCFA9, 0x9FCFB9  /* 0x0005A0 ........70.............. */
                                                  205:       .pword      0xB3C120, 0x9FCFC0, 0x9FCFD9, 0x200126, 0x200007, 0x2FFD35, 0x42828F, 0xB3C064  /* 0x0005B0  ........&. .. 5./..Bd.. */
                                                  206:       .pword      0x2FFC83, 0x41818F, 0xB3C012, 0x784089, 0x784018, 0x070FF4, 0x9FD7A0, 0xE00400  /* 0x0005C0 ../..A....@x.@x......... */
                                                  207:       .pword      0x320003, 0x37000A, 0x073D3F, 0x074162, 0x2FFC42, 0x41010F, 0x2FFD21, 0x40808F  /* 0x0005D0 ..2..7?=.bA.B./..A!./..@ */
                                                  208:       .pword      0x784018, 0x0719A0, 0xE00400, 0x32FFF6, 0xE9450A, 0x3AFFA4, 0xB3C64A, 0xB3C039  /* 0x0005E0 .@x........2.E...:J..9.. */
                                                  209:       .pword      0xB3C25B, 0x9FCF89, 0xEB4000, 0x9FCF90, 0x9FCFA0, 0x9FCFB0, 0xB3C121, 0x9FCFC1  /* 0x0005F0 [......@..........!..... */
                                                  210:       .pword      0x9FCFD0, 0x200126, 0x200007, 0x2FFD35, 0x42828F, 0xB3C064, 0x2FFC83, 0x41818F  /* 0x000600 ...&. .. 5./..Bd..../..A */
                                                  211:       .pword      0xB3C012, 0x784080, 0x784018, 0x070FCE, 0x9FD7A0, 0xE00400, 0x320003, 0x37000A  /* 0x000610 ....@x.@x...........2..7 */
                                                  212:       .pword      0x073D19, 0x07413C, 0x2FFC42, 0x41010F, 0x2FFD21, 0x40808F, 0x784018, 0x07197A  /* 0x000620 .=.<A.B./..A!./..@.@xz.. */
                                                  213:       .pword      0xE00400, 0x32FFF6, 0x780008, 0x071817, 0x9FCF89, 0xEB4000, 0x9FCF90, 0x9FCFA0  /* 0x000630 .....2..x.......@....... */
                                                  214:       .pword      0x9FCFB0, 0xB3C121, 0x9FCFC1, 0x9FCFD0, 0x200126, 0x200007, 0x2FFD35, 0x42828F  /* 0x000640 ...!........&. .. 5./..B */
                                                  215:       .pword      0xB3C064, 0x2FFC83, 0x41818F, 0xB3C012, 0x784080, 0x784018, 0x070FAB, 0x9FD7A0  /* 0x000650 d..../..A....@x.@x...... */
                                                  216:       .pword      0xE00400, 0x320003, 0x37000A, 0x073CF6, 0x074119, 0x2FFC42, 0x41010F, 0x2FFD21  /* 0x000660 .....2..7.<..A.B./..A!./ */
                                                  217:       .pword      0x40808F, 0x784018, 0x071957, 0xE00400, 0x32FFF6, 0x9FCF8B, 0xEB4000, 0x9FCF90  /* 0x000670 ..@.@xW.......2....@.... */
                                                  218:       .pword      0x9FCFA0, 0x9FCFB0, 0x9FCFC0, 0x9FCFD0, 0x9FCFE0, 0x9FCFF0, 0x9FD780, 0x9FD790  /* 0x000680 ........................ */
                                                  219:       .pword      0x200086, 0x200007, 0x2FFD35, 0x42828F, 0xB3C0A4, 0x2FFC83, 0x41818F, 0xB3C012  /* 0x000690 .. .. 5./..B...../..A... */
                                                  220:       .pword      0x784080, 0x784018, 0x070F87, 0x9FD7A0, 0xE00400, 0x320003, 0x370020, 0x073CD2  /* 0x0006A0 .@x.@x...........2 .7.<. */
                                                  221:       .pword      0x0740F5, 0x2FFC42, 0x41010F, 0x2FFD21, 0x40808F, 0x784018, 0x071933, 0xE00400  /* 0x0006B0 .@.B./..A!./..@.@x3..... */
                                                  222:       .pword      0x32FFF6, 0x97D02F, 0xE00400, 0x3A0013, 0x20A500, 0x97D92F, 0xDD114C, 0x97D89F  /* 0x0006C0 ..2/.......:.. /..L..... */
                                                  223:       .pword      0xDD08C8, 0x410101, 0x97D0FF, 0xFB8081, 0x410101, 0x97D88F, 0xFB8081, 0xDD08C4  /* 0x0006D0 .....A........A......... */
                                                  224:       .pword      0x410081, 0x980021, 0x900090, 0xA00001, 0x980011, 0xEB0800, 0x370025, 0x9FCF89  /* 0x0006E0 ..A!..............%.7... */
                                                  225:       .pword      0xEB4000, 0x9FCF90, 0x9FCFA0, 0x9FCFB0, 0xB3C121, 0x9FCFC1, 0x9FCFD0, 0x200126  /* 0x0006F0 .@..........!........&.  */
                                                  226:       .pword      0x200007, 0x2FFD35, 0x42828F, 0xB3C064, 0x2FFC83, 0x41818F, 0xB3C012, 0x784080  /* 0x000700 .. 5./..Bd..../..A....@x */
                                                  227:       .pword      0x784018, 0x070F50, 0x9FD7A0, 0xE00400, 0x320003, 0x37000A, 0x073C9B, 0x0740BE  /* 0x000710 .@xP..........2..7.<..@. */
                                                  228:       .pword      0x2FFC42, 0x41010F, 0x2FFD21, 0x40808F, 0x784018, 0x0718FC, 0xE00400, 0x32FFF6  /* 0x000720 B./..A!./..@.@x........2 */
                                                  229:       .pword      0xE9450A, 0x3AFF5F, 0x200020, 0x885280, 0x20A500, 0xBE054F, 0xBE044F, 0xFA8000  /* 0x000730 .E._.: . .R... O..O..... */
                                                  230:       .pword      0x060000, 0x4787EE, 0xBE9F88, 0xBE9F8A, 0xBE9F8C, 0x781F8E, 0x780700, 0x9FB7E4  /* 0x000740 .....G...........x..x... */
                                                  231:       .pword      0x9FB7F5, 0x9013AE, 0x9FBF87, 0x90686E, 0xE94200, 0x2FFFF8, 0x20FFF9, 0x524FE2  /* 0x000750 .........nh..B.../.. .OR */
                                                  232:       .pword      0x3E00E1, 0x504FE3, 0x320002, 0x2FFFF8, 0x200009, 0xE00401, 0x320005, 0x200011  /* 0x000760 ..>.OP..2../.. .....2..  */
                                                  233:       .pword      0x78000E, 0x071219, 0xB84460, 0x3700D6, 0x504FE1, 0x320009, 0x504FE3, 0x3A000F  /* 0x000770 ..x...`D...7.OP..2.OP..: */
                                                  234:       .pword      0xDD1D42, 0xDE15CE, 0x75058B, 0xDD1542, 0xEB4000, 0x9FE7E0, 0x37000C, 0xB91863  /* 0x000780 B.......uB...@......7c.. */
                                                  235:       .pword      0xB81163, 0x400183, 0x6140E1, 0x9FE7E1, 0xD10583, 0xD38502, 0x370004, 0x410502  /* 0x000790 c....@.@a...........7..A */
                                                  236:       .pword      0x498583, 0xEB4100, 0x9FE7E2, 0x900E4E, 0x900EDE, 0xBE010C, 0xBE000A, 0x07FDDC  /* 0x0007A0 ..I.A....N.............. */
                                                  237:       .pword      0x90012E, 0x9001BE, 0x410200, 0x498281, 0x9FB7C4, 0x9FB7D5, 0x97BA8F, 0x900025  /* 0x0007B0 ........A..I.........%.. */
                                                  238:       .pword      0x9000B5, 0x97B34F, 0x97B3DF, 0x500F86, 0x588F87, 0x320019, 0x200011, 0x78000E  /* 0x0007C0 ...O.......P..X..2.. ..x */
                                                  239:       .pword      0x0711EA, 0xE00400, 0x3200A7, 0x90113E, 0x90109E, 0x90104E, 0x900242, 0x97B14F  /* 0x0007D0 ........2>.....N..B..O.. */
                                                  240:       .pword      0x97B1DF, 0x010004, 0xE00400, 0x3A0006, 0xEB8000, 0xEB8080, 0x97BB8F, 0x9803A0  /* 0x0007E0 ...........:............ */
                                                  241:       .pword      0x9803B1, 0x370098, 0x97B04F, 0x97B0DF, 0x97B90F, 0x980120, 0x980131, 0x560661  /* 0x0007F0 .....7O........ ..1..a.V */
                                                  242:       .pword      0x5E86E0, 0x66010A, 0x66800B, 0xEB0080, 0xDD02C0, 0x200004, 0xB81061, 0x720200  /* 0x000800 ..^..f..f........ a....r */
                                                  243:       .pword      0x728281, 0x90686E, 0x504FE3, 0x3A001D, 0x90101E, 0x97E9CF, 0x7A7003, 0x90109E  /* 0x000810 ..rnh..OP..:.......pz... */
                                                  244:       .pword      0x408084, 0x97B07F, 0x2FF002, 0x97B2EF, 0x610105, 0xEB0180, 0xDD1B48, 0xDE1148  /* 0x000820 ..@...../.....a...H..H.. */
                                                  245:       .pword      0x730102, 0xDE19C8, 0x984092, 0x90109E, 0x408084, 0x9840A0, 0x90109E, 0x408204  /* 0x000830 ..s....@......@.@......@ */
                                                  246:       .pword      0x20F001, 0x600001, 0xEB0080, 0xDD0BC8, 0xDE0048, 0x738000, 0xDE08C8, 0x984230  /* 0x000840 .. ..`......H....s...0B. */
                                                  247:       .pword      0x370064, 0x504FE2, 0x3A000F, 0x90101E, 0x97E8CF, 0x7A7001, 0x90101E, 0x400204  /* 0x000850 d.7.OP..:.......pz.....@ */
                                                  248:       .pword      0x2FF000, 0x97B16F, 0x600002, 0xEB0080, 0xDD09C8, 0xDE0048, 0x718000, 0xDE08C8  /* 0x000860 ../o....`......H....q... */
                                                  249:       .pword      0x984210, 0x370053, 0x504FE1, 0x3A0051, 0x90101E, 0x400004, 0x784090, 0x97E36F  /* 0x000870 .B.S.7.OPQ.:.....@.@xo.. */
                                                  250:       .pword      0xE00406, 0x320006, 0x60C0EF, 0x200042, 0x97EBCF, 0xDD3902, 0x70C082, 0x370001  /* 0x000880 .....2..`B. ....9...p..7 */
                                                  251:       .pword      0x97E8CF, 0x784801, 0x420261, 0x4A82E0, 0x90084E, 0x9008DE, 0x500061, 0x5880E0  /* 0x000890 ....Hxa.B..JN.....a.P..X */
                                                  252:       .pword      0x600104, 0x608005, 0xEB0080, 0xDD06C0, 0x20000C, 0xB81061, 0x760600, 0x768681  /* 0x0008A0 ..`..`........ a....v..v */
                                                  253:       .pword      0x560FE0, 0x5E8FE0, 0x3A001A, 0x200011, 0x78000E, 0x071175, 0xE00400, 0x320032  /* 0x0008B0 ..V..^..:.. ..xu.....2.2 */
                                                  254:       .pword      0x97B04F, 0x97B0DF, 0x400561, 0x4885E0, 0x90113E, 0x90109E, 0x90104E, 0x900242  /* 0x0008C0 O.....a.@..H>.....N..B.. */
                                                  255:       .pword      0xBE010A, 0x010004, 0xE00400, 0x3A0006, 0xEB8000, 0xEB8080, 0x97B90F, 0x980120  /* 0x0008D0 ...........:......... .. */
                                                  256:       .pword      0x980131, 0x370020, 0x97B98F, 0x9801AA, 0x9801BB, 0x90101E, 0x40060C, 0x78401C  /* 0x0008E0 1.. .7..............@.@x */
                                                  257:       .pword      0x97E26F, 0xE00404, 0x320007, 0x97B36F, 0x97B3FF, 0xDD394C, 0xDE3044, 0x710000  /* 0x0008F0 o.......2o.....L9.D0...q */
                                                  258:       .pword      0xDE38C4, 0x37000A, 0xB3CF01, 0x604001, 0x97B26F, 0x97B2FF, 0xDD2B48, 0xDE2148  /* 0x000900 .8...7....@`o.....H+.H!. */
                                                  259:       .pword      0x730102, 0xDE29C8, 0x6140EF, 0x704001, 0x784E00, 0x97BB8F, 0x900047, 0xA01000  /* 0x000910 ..s.)..@a.@p.Nx...G..... */
                                                  260:       .pword      0x9803C0, 0xB84460, 0xBE0008, 0x78074F, 0xBE064F, 0xBE054F, 0xBE044F, 0xB100EF  /* 0x000920 ...`D....O.xO..O..O..... */
                                                  261:       .pword      0x060000, 0x4787E4, 0xBE9F88, 0xBE9F8A, 0xBE9F8C, 0x781F8E, 0x780700, 0xBE0402  /* 0x000930 .....G...........x..x... */
                                                  262:       .pword      0x780501, 0x90084E, 0x9FBF80, 0x0718CB, 0x780080, 0xEB8000, 0xE00001, 0x3A00A7  /* 0x000940 ..xN..........x........: */
                                                  263:       .pword      0x550FE1, 0x320003, 0x550FE2, 0x3A000B, 0x370005, 0x900D2E, 0x900DBE, 0x450508  /* 0x000950 ..U..2..U..:..7........E */
                                                  264:       .pword      0x4D8589, 0x370006, 0x900D0E, 0x900D9E, 0x550508, 0x5D8589, 0x370001, 0xBE0508  /* 0x000960 ..M..7........U..]..7... */
                                                  265:       .pword      0x90084E, 0xEB0080, 0x071118, 0xE00400, 0x3A0005, 0xB3C090, 0x97B88F, 0x987080  /* 0x000970 N.............:.......p. */
                                                  266:       .pword      0xEB8000, 0x37008D, 0x90004E, 0x9000DE, 0x980760, 0x980771, 0x90080E, 0x90089E  /* 0x000980 .....7N.....`..q........ */
                                                  267:       .pword      0x550F80, 0x5D8F81, 0x360005, 0xB3C210, 0x97B88F, 0x987080, 0xEB8000, 0x37007F  /* 0x000990 ..U..]..6.......p......7 */
                                                  268:       .pword      0x980F2A, 0x980F3B, 0x97B98F, 0x900E43, 0x900ED3, 0xBE010C, 0xBE000A, 0x07FCDC  /* 0x0009A0 *..;.....C.............. */
                                                  269:       .pword      0xBE0400, 0xB9C80C, 0xB9E908, 0x410000, 0xB8460C, 0x40068D, 0x55060C, 0x5D868D  /* 0x0009B0 ...........A.F...@..U..] */
                                                  270:       .pword      0x980F6C, 0x97B80F, 0x906E50, 0xFB860C, 0xEB0680, 0xBE010C, 0xBE0008, 0x07FCCC  /* 0x0009C0 l.....Pn................ */
                                                  271:       .pword      0xBE0500, 0xB9D80C, 0xB8560C, 0x40068D, 0x54060C, 0x5C868D, 0x980F5C, 0x550FE0  /* 0x0009D0 .......V...@..T..\\....U */
                                                  272:       .pword      0x5D8FE0, 0x320041, 0xBE010A, 0x78000E, 0x071090, 0xE00400, 0x32003C, 0xB3C261  /* 0x0009E0 ..]A.2.....x......<.2a.. */
                                                  273:       .pword      0x504F81, 0x3A0034, 0x90181E, 0xA30800, 0x320016, 0x90004E, 0x9000DE, 0x980760  /* 0x0009F0 .OP4.:........2N.....`.. */
                                                  274:       .pword      0x980771, 0x550FE1, 0x5D8FE0, 0x320004, 0x550161, 0x5D81E0, 0x78000E, 0x07107D  /* 0x000A00 q....U..]..2a.U..]..x}.. */
                                                  275:       .pword      0x4700EC, 0xEB4100, 0x97B80F, 0x071489, 0xE00000, 0x320025, 0xB3C100, 0x97B88F  /* 0x000A10 ..G.A..........%.2...... */
                                                  276:       .pword      0x987080, 0xEB8000, 0x37003C, 0x90004E, 0x9000DE, 0x980760, 0x980771, 0x550FE1  /* 0x000A20 .p....<.7N.....`..q....U */
                                                  277:       .pword      0x5D8FE0, 0x32000B, 0x550161, 0x5D81E0, 0x78000E, 0x071067, 0xE00400, 0x320005  /* 0x000A30 ..]..2a.U..]..xg.......2 */
                                                  278:       .pword      0xB3C100, 0x97B88F, 0x987080, 0xEB8000, 0x37002A, 0x97B98F, 0x9009C3, 0x980F63  /* 0x000A40 .......p....*.7......c.. */
                                                  279:       .pword      0x97B88F, 0x906851, 0xFB8000, 0xE90000, 0x980F50, 0x370005, 0xB3C100, 0x97B98F  /* 0x000A50 ...Qh.......P....7...... */
                                                  280:       .pword      0x987180, 0xEB8000, 0x37001C, 0x90016E, 0x9001FE, 0x97B80F, 0x0717A7, 0x900C5E  /* 0x000A60 .q......7n...........^.. */
                                                  281:       .pword      0x440400, 0x4884E0, 0x97B80F, 0x901130, 0x901080, 0x780180, 0x901043, 0x900242  /* 0x000A70 ..D..H...0.......xC..B.. */
                                                  282:       .pword      0xBE0108, 0x010004, 0xE00400, 0x3A0005, 0xB3C1D0, 0x97B88F, 0x987080, 0xEB8000  /* 0x000A80 ...........:.......p.... */
                                                  283:       .pword      0x370006, 0x97B98F, 0x901023, 0xBE8808, 0xEB4000, 0x987180, 0xEB0000, 0x78074F  /* 0x000A90 ..7...#......@..q....O.x */
                                                  284:       .pword      0xBE064F, 0xBE054F, 0xBE044F, 0xB1004F, 0x060000, 0x4787F2, 0xBE9F88, 0xBE9F8A  /* 0x000AA0 O..O..O..O.......G...... */
                                                  285:       .pword      0xBE9F8C, 0x781F8E, 0x780400, 0x780603, 0x900ECC, 0x90181C, 0xA31800, 0x3A0005  /* 0x000AB0 .....x..x..x...........: */
                                                  286:       .pword      0xB3C200, 0x987680, 0xEB0000, 0x9FB7B0, 0x370094, 0xB99101, 0x780702, 0xE0000E  /* 0x000AC0 ....v.........7.....x... */
                                                  287:       .pword      0x3A0005, 0xEB4000, 0x987680, 0xEB0080, 0x9FB7B1, 0x37008B, 0x78000D, 0x0717FF  /* 0x000AD0 ..:.@..v.........7..x... */
                                                  288:       .pword      0xEB0100, 0x9FB7B2, 0xE00000, 0x3A0085, 0x9FB7C8, 0x20001A, 0x20000B, 0x90096C  /* 0x000AE0 ...........:..... .. l.. */
                                                  289:       .pword      0xEB0180, 0x90084D, 0x9008DD, 0x510F80, 0x598F81, 0x3A0011, 0xEB0180, 0x980E63  /* 0x000AF0 ...M.......Q..Y..:...c.. */
                                                  290:       .pword      0x90085C, 0xE80000, 0x980E50, 0x9068DD, 0xFB8081, 0x500F81, 0x3A0008, 0x980E53  /* 0x000B00 \.....P...h......P..:S.. */
                                                  291:       .pword      0xBE010A, 0x78000C, 0x070FFA, 0xE00000, 0x320002, 0x987680, 0x37006A, 0x90016C  /* 0x000B10 .....x........2.v.j.7l.. */
                                                  292:       .pword      0x9001FC, 0x78000D, 0x07174B, 0x900C5C, 0x440400, 0x4884E0, 0x90102D, 0x140FB0  /* 0x000B20 .....xK..\....D..H-..... */
                                                  293:       .pword      0x1C8FA0, 0x320019, 0xEB0080, 0x78000D, 0x071036, 0xE00400, 0x3A0005, 0xB3C090  /* 0x000B30 .....2.....x6.......:... */
                                                  294:       .pword      0x987680, 0x200096, 0x9FB7B6, 0x370055, 0x90113D, 0x90108D, 0x90104D, 0x900242  /* 0x000B40 .v... ...U.7=.....M..B.. */
                                                  295:       .pword      0xBE0108, 0x010004, 0xE00400, 0x3A0003, 0xB3C080, 0x987680, 0x37004A, 0x90102D  /* 0x000B50 ...........:....v.J.7-.. */
                                                  296:       .pword      0xBE8808, 0x90102D, 0x98005D, 0x90086C, 0x90094D, 0x9009DD, 0x510100, 0x5981E0  /* 0x000B60 ...-..]..l..M.......Q..Y */
                                                  297:       .pword      0xB87461, 0x540F82, 0x5C8F83, 0x360001, 0xBE0402, 0x900A0C, 0x900A9C, 0x90092C  /* 0x000B70 at...T..\..6.........,.. */
                                                  298:       .pword      0x9009BC, 0x9FB7F2, 0x9FBF83, 0x520302, 0x5A8383, 0x9FB796, 0x9FB7A7, 0xB84161  /* 0x000B80 ...........R..Z......aA. */
                                                  299:       .pword      0x9FB7D2, 0x9FB7E3, 0x530F82, 0x5B8F83, 0x310015, 0x97B17F, 0x97B98F, 0x520402  /* 0x000B90 ........S..[..1........R */
                                                  300:       .pword      0x90108D, 0x408080, 0x780108, 0x97B04F, 0x07FC8C, 0x90086C, 0x400008, 0x980E60  /* 0x000BA0 .....@..xO.....l....@`.. */
                                                  301:       .pword      0x90082C, 0x9008BC, 0x440000, 0x4880E0, 0x980E20, 0x980E31, 0x97B1BF, 0x418188  /* 0x000BB0 ,.......D..H ..1.......A */
                                                  302:       .pword      0x9FB7B3, 0x370017, 0x90108D, 0x408080, 0x780108, 0x97B04F, 0x07FC7A, 0x90086C  /* 0x000BC0 .....7.....@..xO..z..l.. */
                                                  303:       .pword      0x400008, 0x980E60, 0x90082C, 0x9008BC, 0x440000, 0x4880E0, 0x980E20, 0x980E31  /* 0x000BD0 ..@`..,.......D..H ..1.. */
                                                  304:       .pword      0x97B33F, 0x430308, 0x9FB7B6, 0x570708, 0x320004, 0x97B3CF, 0x438388, 0x9FB7C7  /* 0x000BE0 ?....C.....W..2.....C... */
                                                  305:       .pword      0x37FF7E, 0x97B03F, 0x78074F, 0xBE064F, 0xBE054F, 0xBE044F, 0xB1012F, 0x060000  /* 0x000BF0 ~.7?..O.xO..O..O../..... */
                                                  306:       .pword      0xFE0000, 0xB82260, 0xE00003, 0x3200A1, 0xDE0BC8, 0x3A009F, 0x203E57, 0x781F87  /* 0x000C00 ...`"......2.....:W> ..x */
                                                  307:       .pword      0xF80032, 0xBE9F88, 0xBE9F8A, 0xBE9F8C, 0xA37801, 0x3A0006, 0xA3D804, 0x320002  /* 0x000C10 2............x...:.....2 */
                                                  308:       .pword      0xAF4761, 0xA26001, 0xA7C004, 0xA06001, 0x24003B, 0x20002D, 0xA0F004, 0x20000C  /* 0x000C20 aG..`.....`.;.$-. .....  */
                                                  309:       .pword      0xE0000C, 0x320006, 0xA1F004, 0x24000B, 0x40CFE8, 0x320002, 0x20004D, 0x24001B  /* 0x000C30 .....2.....$..@..2M. ..$ */
                                                  310:       .pword      0xFA0006, 0xD0060D, 0x47878C, 0x78038E, 0x781B8B, 0xBE9B80, 0x78040F, 0xEB0480  /* 0x000C40 ........G..x..x.....x... */
                                                  311:       .pword      0x2DEADC, 0xE1280C, 0x320011, 0xDD2AC2, 0x320003, 0xE90285, 0x098005, 0x781FB6  /* 0x000C50 ..-.(...2.*...2........x */
                                                  312:       .pword      0x200006, 0x880196, 0x202085, 0x2000C6, 0xAFE761, 0x37FFFE, 0x370002, 0xBA1F95  /* 0x000C60 .. ....  .. a....7..7... */
                                                  313:       .pword      0xBA9FB5, 0xE98306, 0x31FFFC, 0x578488, 0xF80A9A, 0xEF2A9A, 0x370055, 0x78058F  /* 0x000C70 ........1..W....*.U.7..x */
                                                  314:       .pword      0xE9060D, 0x09800C, 0xEB9F80, 0xE90003, 0x098000, 0x785DB2, 0x558103, 0xEB0180  /* 0x000C80 ................]x..U... */
                                                  315:       .pword      0xD0008D, 0xA7000F, 0xEB0080, 0xD1000D, 0x090002, 0x785BB2, 0xEBDB80, 0xE90000  /* 0x000C90 ................[x...... */
                                                  316:       .pword      0x3AFFFB, 0x578781, 0xE9060D, 0x09800C, 0x480FC7, 0x31003A, 0x7805C7, 0x780547  /* 0x000CA0 ..:..W........H:.1..xG.x */
                                                  317:       .pword      0x45008D, 0x4D8660, 0x540364, 0x780389, 0x430364, 0x5383E8, 0x390007, 0xE10836  /* 0x000CB0 ..E`.Md.T..xd.C..S..96.. */
                                                  318:       .pword      0xE1E036, 0x34FFFA, 0xE15036, 0xE1D836, 0x31FFF8, 0x37002A, 0x200000, 0x200FA1  /* 0x000CC0 6....46P.6....1*.7.. ..  */
                                                  319:       .pword      0x470362, 0xA7F004, 0xBE0036, 0x880191, 0xD1008D, 0x78038E, 0x207606, 0xAFE761  /* 0x000CD0 b.G...6..........x.v a.. */
                                                  320:       .pword      0x37FFFE, 0x090002, 0x781B37, 0xBB0837, 0xBB9837, 0xE90081, 0x3AFFFC, 0x21326A  /* 0x000CE0 ..7...7.x7..7.......:j2! */
                                                  321:       .pword      0x97B0FE, 0x97B87F, 0xB80001, 0x50038A, 0x20000A, 0xA0001A, 0xEB0000, 0xA7001A  /* 0x000CF0 ...........P.. ......... */
                                                  322:       .pword      0x37FFFE, 0xA7A004, 0xFE6000, 0x024352, 0x000000, 0x780B07, 0xB009B1, 0x780B01  /* 0x000D00 ..7....`.RC......x.....x */
                                                  323:       .pword      0xA8E761, 0x000000, 0x000000, 0xA3B804, 0xAFE761, 0x3AFFFE, 0x024368, 0x000000  /* 0x000D10 a...........a....:hC.... */
                                                  324:       .pword      0x4703E2, 0xEB0000, 0x469B97, 0x481B97, 0xD1000D, 0x468000, 0x518180, 0x31FFB2  /* 0x000D20 ..G.....F..H.....F..Q..1 */
                                                  325:       .pword      0x418180, 0x3AFFA5, 0x23FF00, 0xB62760, 0xEB2780, 0x90001E, 0x9000AE, 0xFA8000  /* 0x000D30 ..A..:..#`'..'.......... */
                                                  326:       .pword      0xBE064F, 0xBE054F, 0xBE044F, 0xF90032, 0xEB2780, 0xEF2A9A, 0x060000, 0x4787E4  /* 0x000D40 O..O..O..2...'..*......G */
                                                  327:       .pword      0xBE9F88, 0xBE9F8A, 0xBE9F8C, 0x781F8E, 0x780700, 0x780583, 0x900D4B, 0x90181B  /* 0x000D50 ...........x..x..xK..... */
                                                  328:       .pword      0xA30800, 0x3A0004, 0xB3C1F0, 0x987500, 0xEB0680, 0x370088, 0xB99601, 0xE0000C  /* 0x000D60 .....:....u......7...... */
                                                  329:       .pword      0x3A0004, 0xEB4000, 0x987500, 0xEB0680, 0x370081, 0x78000A, 0x0716B0, 0xEB0680  /* 0x000D70 ..:.@..u......7..x...... */
                                                  330:       .pword      0xE00000, 0x3A007C, 0x9010BA, 0x90104A, 0x9000E1, 0x010001, 0xE00400, 0x320003  /* 0x000D80 ...|.:...J.............2 */
                                                  331:       .pword      0xB3C1A0, 0x987500, 0x370073, 0xEB0680, 0x45806C, 0x9FBF80, 0x90096B, 0xEB0180  /* 0x000D90 ....u.s.7...l.E...k..... */
                                                  332:       .pword      0x90084A, 0x9008DA, 0x510F80, 0x598F81, 0x3A001E, 0xEB0000, 0x980DE0, 0x90085B  /* 0x000DA0 J.......Q..Y..:......[.. */
                                                  333:       .pword      0xE80000, 0x980DD0, 0x9068DA, 0xFB8081, 0x500F81, 0x3A0015, 0x90046B, 0x9004FB  /* 0x000DB0 .......h......P..:k..... */
                                                  334:       .pword      0xEB0000, 0x980DD0, 0x200012, 0x200003, 0x78000B, 0x070E9F, 0x200261, 0x500F81  /* 0x000DC0 ........ .. ..x...a. ..P */
                                                  335:       .pword      0x3A0006, 0x9805E8, 0x9805F9, 0xEB4100, 0x97B88F, 0x78000A, 0x0712A6, 0xE00000  /* 0x000DD0 ..:.......A......x...... */
                                                  336:       .pword      0x320002, 0x987500, 0x37004B, 0x90016B, 0x9001FB, 0x78000A, 0x0715E7, 0x900C5B  /* 0x000DE0 ..2.u.K.7k.......x...[.. */
                                                  337:       .pword      0x440400, 0x4884E0, 0x90102A, 0x140FB0, 0x1C8FA0, 0x320018, 0xEB0080, 0x78000A  /* 0x000DF0 ..D..H*..........2.....x */
                                                  338:       .pword      0x070ED2, 0xE00400, 0x3A0004, 0xB3C090, 0x987500, 0x20009D, 0x370037, 0x90113A  /* 0x000E00 ........:....u... 7.7:.. */
                                                  339:       .pword      0x90108A, 0x90104A, 0x900242, 0xBE0108, 0x010004, 0xE00400, 0x3A0003, 0xB3C080  /* 0x000E10 ...J..B.............:... */
                                                  340:       .pword      0x987500, 0x37002C, 0x90102A, 0xBE8808, 0x90102A, 0x98005A, 0x90086B, 0x900A4A  /* 0x000E20 .u.,.7*.....*..Z..k..J.. */
                                                  341:       .pword      0x900ADA, 0x520200, 0x5A82E0, 0xB86161, 0x510F84, 0x598F85, 0x360001, 0xBE0104  /* 0x000E30 .....R..Zaa...Q..Y..6... */
                                                  342:       .pword      0x780402, 0x90108A, 0x408000, 0x78008E, 0x07FB3C, 0x90102A, 0x9000C0, 0xA00001  /* 0x000E40 ..x.....@..x<..*........ */
                                                  343:       .pword      0x980041, 0x90086B, 0x400008, 0x980DE0, 0x468688, 0x560608, 0x320002, 0x470708  /* 0x000E50 A..k....@.....F..V..2..G */
                                                  344:       .pword      0x37FF9D, 0xB86861, 0x90090B, 0x90099B, 0x400102, 0x488183, 0x980D82, 0x980D93  /* 0x000E60 ..7ah.........@..H...... */
                                                  345:       .pword      0x90092B, 0x9009BB, 0x400002, 0x488083, 0x980DA0, 0x980DB1, 0x78000D, 0x78074F  /* 0x000E70 +.......@..H........xO.x */
                                                  346:       .pword      0xBE064F, 0xBE054F, 0xBE044F, 0xB1004F, 0x060000, 0x000EDE, 0x000032, 0x000000  /* 0x000E80 O..O..O..O........2..... */
                                                  347:       .pword      0x000A74, 0x000002, 0x000000, 0x000A76, 0x000002, 0x000000, 0x000AA4, 0x000200  /* 0x000E90 t........v.............. */
                                                  348:       .pword      0x000000, 0x000CA4, 0x000200, 0x000000, 0x000F34, 0x00000C, 0x000000, 0x000F64  /* 0x000EA0 ............4........d.. */
                                                  349:       .pword      0x000006, 0x000000, 0x000A78, 0x000002, 0x000000, 0x000A7A, 0x000002, 0x000000  /* 0x000EB0 ......x........z........ */
                                                  350:       .pword      0x000A7C, 0x000002, 0x000000, 0x000A7E, 0x000002, 0x000000, 0x000A80, 0x000002  /* 0x000EC0 |........~.............. */
                                                  351:       .pword      0x000000, 0x000A82, 0x000002, 0x000000, 0x000A58, 0x000004, 0x000000, 0x001000  /* 0x000ED0 ............X........... */
                                                  352:       .pword      0x000200, 0x000000, 0x000F10, 0x000014, 0x000000, 0x000A84, 0x000002, 0x000000  /* 0x000EE0 ........................ */
                                                  353:       .pword      0x000A86, 0x000002, 0x000000, 0x000A88, 0x000002, 0x000000, 0x000A8A, 0x000002  /* 0x000EF0 ........................ */
                                                  354:       .pword      0x000000, 0x000A8C, 0x000002, 0x000000, 0x000A8E, 0x000002, 0x000000, 0x000EA4  /* 0x000F00 ........................ */
                                                  355:       .pword      0x00003A, 0x000000, 0x000A5C, 0x000004, 0x000002, 0x345678, 0x000012, 0x000A50  /* 0x000F10 :.....\........xV4...P.. */
                                                  356:       .pword      0x000008, 0x000000, 0x000A90, 0x000002, 0x000000, 0x000A92, 0x000002, 0x000000  /* 0x000F20 ........................ */
                                                  357:       .pword      0x000A94, 0x000002, 0x000000, 0x000A60, 0x000004, 0x000000, 0x000A64, 0x000004  /* 0x000F30 .........`........d..... */
                                                  358:       .pword      0x000000, 0x000A96, 0x000002, 0x000000, 0x000A98, 0x000002, 0x000000, 0x000F50  /* 0x000F40 .....................P.. */
                                                  359:       .pword      0x00000A, 0x000002, 0x064372, 0x000034, 0x000000, 0x000000, 0x000F5A, 0x00000A  /* 0x000F50 ......rC.4........Z..... */
                                                  360:       .pword      0x000002, 0x2A1D9E, 0x000038, 0x000000, 0x000000, 0x000F24, 0x000010, 0x000002  /* 0x000F60 .....*8........$........ */
                                                  361:       .pword      0x500608, 0x000000, 0x080002, 0x005005, 0x020000, 0x000000, 0x000A68, 0x000004  /* 0x000F70 ..P.......P.......h..... */
                                                  362:       .pword      0x000000, 0x000F6E, 0x000002, 0x000000, 0x000F70, 0x000002, 0x000000, 0x000F72  /* 0x000F80 ...n........p........r.. */
                                                  363:       .pword      0x000002, 0x000000, 0x000F74, 0x000002, 0x000000, 0x000F76, 0x000002, 0x000000  /* 0x000F90 ......t........v........ */
                                                  364:       .pword      0x000A9A, 0x000002, 0x000000, 0x000F7A, 0x000002, 0x000002, 0x000004, 0x000F6A  /* 0x000FA0 .........z...........j.. */
                                                  365:       .pword      0x000004, 0x000000, 0x000F7C, 0x000002, 0x000000, 0x000000, 0xFA0042, 0xBE9F88  /* 0x000FB0 ......|...........B..... */
                                                  366:       .pword      0x780481, 0xEB0080, 0x9FBFD1, 0xEB4100, 0x780080, 0x578070, 0x0708A8, 0x780400  /* 0x000FC0 ..x.......A...xp.W.....x */
                                                  367:       .pword      0xE00008, 0x3A0005, 0xB3C211, 0x807B40, 0x987001, 0xEB8000, 0x370084, 0x97B80F  /* 0x000FD0 .....:...@{..p......7... */
                                                  368:       .pword      0x97B89F, 0x9FBFB0, 0x9FBFC1, 0x97B82F, 0x9010B0, 0x901040, 0x9000E1, 0x010001  /* 0x000FE0 ........./.....@........ */
                                                  369:       .pword      0xE00400, 0x320005, 0xB3C1A1, 0x97B82F, 0x987001, 0xEB8000, 0x370074, 0xEB4080  /* 0x000FF0 .....2.../...p....t.7.@. */
                                                  370:       .pword      0x780009, 0x0704DD, 0xE00400, 0x320002, 0x504FE3, 0x3A0005, 0xB3C131, 0x97B82F  /* 0x001000 ..x........2.OP..:1../.. */
                                                  371:       .pword      0x987001, 0xEB8000, 0x370068, 0x504FE1, 0x3A0015, 0x97B90F, 0x97B99F, 0x9FBFB2  /* 0x001010 .p....h.7.OP..:......... */
                                                  372:       .pword      0x9FBFC3, 0xEB0000, 0x9FBFD0, 0x2FFBA1, 0x40808F, 0x780009, 0x070FBA, 0x200027  /* 0x001020 .........../..@..x...'.  */
                                                  373:       .pword      0xEB0300, 0xEB0280, 0x578266, 0x5781EA, 0x57817F, 0x2FFBA1, 0x40808F, 0x578070  /* 0x001030 ......f.W..W..W../..@p.W */
                                                  374:       .pword      0x070214, 0x9FB7F0, 0x97B07F, 0xE00000, 0x3A0005, 0xB3C121, 0x97B82F, 0x987001  /* 0x001040 ..............:!../...p. */
                                                  375:       .pword      0xEB8000, 0x370049, 0xEB4080, 0x780008, 0x0704B2, 0xEB0080, 0x9FBFD1, 0x97B90F  /* 0x001050 ...I.7.@...x............ */
                                                  376:       .pword      0x97B99F, 0x9FBFB2, 0x9FBFC3, 0xE00400, 0x320002, 0x504FE3, 0x3A0005, 0xB3C131  /* 0x001060 ..............2.OP..:1.. */
                                                  377:       .pword      0x97B82F, 0x987001, 0xEB8000, 0x370037, 0x504FE1, 0x3A000F, 0x2FFBA1, 0x40808F  /* 0x001070 /...p....7.7.OP..:../..@ */
                                                  378:       .pword      0x780008, 0x070F8F, 0x200027, 0xEB0300, 0xEB0280, 0x578266, 0x5781EA, 0x57817F  /* 0x001080 ..x...'. ......f.W..W..W */
                                                  379:       .pword      0x2FFBA1, 0x40808F, 0x578070, 0x0701E9, 0x9FB7F0, 0x97B07F, 0xE00000, 0x320005  /* 0x001090 ../..@p.W..............2 */
                                                  380:       .pword      0xB3C0C1, 0x97B82F, 0x987001, 0xEB8000, 0x37001E, 0x97AA4F, 0x5781E6, 0x57816A  /* 0x0010A0 .../...p......7O....Wj.W */
                                                  381:       .pword      0x5780F2, 0x578070, 0x070269, 0x780400, 0x2FFBA1, 0x40808F, 0x780009, 0x070F71  /* 0x0010B0 ..Wp.Wi....x../..@..xq.. */
                                                  382:       .pword      0x5781FF, 0x09000A, 0x785C33, 0xB100B8, 0x97B82F, 0x9010A0, 0x900141, 0xA00002  /* 0x0010C0 ..W...3\x.../.....A..... */
                                                  383:       .pword      0x9800C2, 0xEB0080, 0x070D68, 0x784080, 0xEB0000, 0xE00401, 0x3A0004, 0xB3C091  /* 0x0010D0 ......h...@x........:... */
                                                  384:       .pword      0x97B82F, 0x987001, 0xEB8000, 0xBE044F, 0xFA8000, 0x060000, 0xFA000E, 0xBE9F88  /* 0x0010E0 /...p....O.............. */
                                                  385:       .pword      0x781F8A, 0x780400, 0x780482, 0xEB0000, 0x9FBFC0, 0xEB4100, 0x578072, 0x07080F  /* 0x0010F0 ..x..x..x.......A.r.W... */
                                                  386:       .pword      0x780500, 0xEB8000, 0xE0000A, 0x320085, 0x97B07F, 0x97B88F, 0x9FBFA0, 0x9FBFB1  /* 0x001100 ..x........2............ */
                                                  387:       .pword      0x97B81F, 0x9010B0, 0x901040, 0x9000E1, 0x010001, 0xE00400, 0x320007, 0x64806E  /* 0x001110 ......@.............2n.d */
                                                  388:       .pword      0x320005, 0xB3C1A1, 0x97B81F, 0x987001, 0xEB8000, 0x370073, 0xE00008, 0x3A0005  /* 0x001120 ..2.......p....s.7.....: */
                                                  389:       .pword      0xB3C221, 0x97B81F, 0x987001, 0xEB8000, 0x37006C, 0xEB4080, 0x78000A, 0x07043F  /* 0x001130 !......p....l.7.@...x?.. */
                                                  390:       .pword      0x504FE1, 0x3A0016, 0x97B07F, 0x97B88F, 0x9FBFA0, 0x9FBFB1, 0xEB0000, 0x9FBFC0  /* 0x001140 .OP..:.................. */
                                                  391:       .pword      0x780088, 0x78000A, 0x070F26, 0x200272, 0x410108, 0x200027, 0xEB0300, 0xEB0280  /* 0x001150 ..x..x&..r. ..A'. ...... */
                                                  392:       .pword      0x578268, 0x5781EC, 0x780088, 0x578072, 0x070180, 0xE00000, 0x320006, 0x370017  /* 0x001160 h.W..W..xr.W........2..7 */
                                                  393:       .pword      0xB3C131, 0x97B81F, 0x987001, 0xEB8000, 0x37004C, 0xA33809, 0x3A0005, 0x780088  /* 0x001170 1......p....L.7.8...:..x */
                                                  394:       .pword      0x578072, 0x0714D0, 0xE00400, 0x3A0009, 0x9008F8, 0x9FB7E1, 0xB3C012, 0x5780F4  /* 0x001180 r.W........:...........W */
                                                  395:       .pword      0x780008, 0x07058A, 0xE00000, 0x32000F, 0x370039, 0xA12009, 0x37000D, 0x500FEF  /* 0x001190 ..x........29.7. ...7..P */
                                                  396:       .pword      0x3A0035, 0xA32809, 0x320033, 0x97B81F, 0x980C40, 0x97B07F, 0x97B88F, 0xBE8C00  /* 0x0011A0 5.:.(.3.2...@........... */
                                                  397:       .pword      0x980420, 0x980431, 0x370001, 0xA02009, 0xA32809, 0x32000A, 0xEB0080, 0x9FB7E1  /* 0x0011B0  ..1....7. ..(...2...... */
                                                  398:       .pword      0xB3C013, 0xEB4100, 0x5780F4, 0x780008, 0x071532, 0xE00000, 0x3A001F, 0xA04009  /* 0x0011C0 ....A...W..x2.......:.@. */
                                                  399:       .pword      0xA30809, 0x320004, 0x901818, 0xA01000, 0x981C10, 0x370003, 0x901818, 0xA11000  /* 0x0011D0 .....2...........7...... */
                                                  400:       .pword      0x981C10, 0xA31809, 0x320004, 0x901818, 0xA00000, 0x981C10, 0x370003, 0x901818  /* 0x0011E0 ........2...........7... */
                                                  401:       .pword      0xA10000, 0x981C10, 0xEB0000, 0xA34809, 0x32000C, 0x200021, 0xB81160, 0x780008  /* 0x0011F0 ..........H...2!. `....x */
                                                  402:       .pword      0x07FB98, 0x780080, 0xEB0000, 0xE00001, 0x320004, 0x2001C0, 0x97B89F, 0x987080  /* 0x001200 .....x........2.. ....p. */
                                                  403:       .pword      0xEB8000, 0x78054F, 0xBE044F, 0xFA8000, 0x060000, 0xBE9F88, 0x781F8A, 0xBE9F8C  /* 0x001210 ...O.xO.............x... */
                                                  404:       .pword      0x780400, 0x784001, 0x071804, 0x780500, 0xE0000A, 0x3A0003, 0x200020, 0x980410  /* 0x001220 ..x.@x.....x.....: . ... */
                                                  405:       .pword      0x370084, 0x78000A, 0x071454, 0xE00000, 0x320003, 0x200010, 0x980410, 0x37007D  /* 0x001230 ..7..xT.......2.. ...}.7 */
                                                  406:       .pword      0x904018, 0xE00400, 0x32003B, 0xB80060, 0x980470, 0x980C01, 0xEB4000, 0x984410  /* 0x001240 .@....;.2`..p......@..D. */
                                                  407:       .pword      0x200FF0, 0x980410, 0x9068EA, 0x984441, 0x90084A, 0x980430, 0x9068DA, 0x984C01  /* 0x001250 .. ....h.AD.J..0...h..L. */
                                                  408:       .pword      0x90082A, 0x9008BA, 0x980450, 0x980461, 0x90686A, 0x504FE2, 0x32000E, 0x504FE3  /* 0x001260 *.....P..a..jh..OP..2.OP */
                                                  409:       .pword      0x320003, 0x504FE1, 0x3A001B, 0x370012, 0x2FFF70, 0x20FFF1, 0x980C50, 0x980C61  /* 0x001270 ..2.OP..:..7p./.. P..a.. */
                                                  410:       .pword      0x2FFFF0, 0x20FFF1, 0x980C70, 0x981401, 0x370011, 0x2FFF70, 0x200001, 0x980C50  /* 0x001280 ../.. p.......7p./.. P.. */
                                                  411:       .pword      0x980C61, 0x2FFFF0, 0x200001, 0x980C70, 0x981401, 0x370008, 0x20FF70, 0x200001  /* 0x001290 a..../.. p.......7p. ..  */
                                                  412:       .pword      0x980C50, 0x980C61, 0x2FFFF0, 0x200001, 0x980C70, 0x981401, 0x200022, 0x200003  /* 0x0012A0 P..a..../.. p.....". ..  */
                                                  413:       .pword      0x980C12, 0x980C23, 0x980C32, 0x980C43, 0x78000A, 0x07435A, 0x900098, 0x200FF0  /* 0x0012B0 ...#..2..C....xZC......  */
                                                  414:       .pword      0x508F80, 0x3A003B, 0xEB4480, 0x20002C, 0x20000D, 0x900918, 0x9009A8, 0x78000A  /* 0x0012C0 ..P;.:.D.,. .. ........x */
                                                  415:       .pword      0x07434F, 0x900978, 0x901188, 0x500F82, 0x588F83, 0x3A0003, 0x200030, 0x980410  /* 0x0012D0 OC.x.......P..X..:0. ... */
                                                  416:       .pword      0x37002C, 0x500FE0, 0x588FE0, 0x3A0006, 0x900178, 0x900988, 0x410161, 0x4981E0  /* 0x0012E0 ,.7..P..X..:x.....a.A..I */
                                                  417:       .pword      0x980472, 0x980C03, 0x900918, 0x9009A8, 0x410161, 0x4981E0, 0x980C12, 0x980C23  /* 0x0012F0 r...........a.A..I...#.. */
                                                  418:       .pword      0x900A58, 0x900AE8, 0x520F80, 0x5A8F81, 0x320007, 0x900058, 0x9000E8, 0x400062  /* 0x001300 X.......R..Z..2X.....b.@ */
                                                  419:       .pword      0x4880E0, 0x510F80, 0x598F81, 0x390002, 0x980C1C, 0x980C2D, 0x900918, 0x9009A8  /* 0x001310 ..H..Q..Y..9...-........ */
                                                  420:       .pword      0x900838, 0x9008C8, 0x510F80, 0x598F81, 0x3A0003, 0xEB0000, 0x980410, 0x370005  /* 0x001320 8.......Q..Y..:........7 */
                                                  421:       .pword      0xE84489, 0x44CFE1, 0x3AFFCA, 0x200FF0, 0x980410, 0xBE064F, 0x78054F, 0xBE044F  /* 0x001330 .D...D..:.. ...O..O.xO.. */
                                                  422:       .pword      0x060000, 0xFA0034, 0xBE9F88, 0x781F8A, 0xE24A98, 0x320002, 0xE00000, 0x32001C  /* 0x001340 ...4.......x.J...2.....2 */
                                                  423:       .pword      0xEF2A68, 0xEF2A6A, 0xEF2F76, 0xEF2A9A, 0xEF2A92, 0xEF6A96, 0x071684, 0x885300  /* 0x001350 h*.j*.v/..*..*..j.....S. */
                                                  424:       .pword      0x885311, 0x805382, 0x805393, 0x410200, 0x498281, 0x885324, 0x885335, 0xB3C010  /* 0x001360 .S..S..S...A..I$S.5S.... */
                                                  425:       .pword      0xB7EA98, 0x803A00, 0x8854A0, 0x2C2101, 0x600081, 0x320006, 0xB3C0A2, 0x20A985  /* 0x001370 ....:..T..!,..`..2.....  */
                                                  426:       .pword      0x784A82, 0x23DEF1, 0x600181, 0x883A03, 0x280368, 0xB3C01A, 0x07166C, 0x805302  /* 0x001380 .Jx..#..`.:.h.(...l...S. */
                                                  427:       .pword      0x805313, 0x500102, 0x588183, 0x33000E, 0x200020, 0x0717E3, 0x805380, 0x805391  /* 0x001390 .S...P..X..3 . ....S..S. */
                                                  428:       .pword      0xDD0A4C, 0xDE0044, 0x720000, 0xDE08C4, 0x805302, 0x805313, 0x400102, 0x488183  /* 0x0013A0 L..D....r....S..S...@..H */
                                                  429:       .pword      0x885302, 0x885313, 0x07150C, 0xE00000, 0x32000C, 0x071655, 0x805322, 0x805333  /* 0x0013B0 .S..S.........2U.."S.3S. */
                                                  430:       .pword      0x500002, 0x588083, 0x330006, 0xEB0000, 0x07179C, 0xF80A94, 0xF90740, 0x07174F  /* 0x0013C0 ..P..X..3.........@..O.. */
                                                  431:       .pword      0xFE0000, 0x20A901, 0x780008, 0x0717B9, 0xEAC080, 0x20A963, 0x60C093, 0x320002  /* 0x0013D0 ..... ..x......c. ..`..2 */
                                                  432:       .pword      0x20A984, 0x784A0A, 0xB7EA96, 0xE00400, 0x32003C, 0xBFCA98, 0x504FE1, 0x3A0039  /* 0x0013E0 .. .Jx......<.2....OP9.: */
                                                  433:       .pword      0x20A902, 0x780088, 0xB3C410, 0x070A92, 0xE00000, 0x3A0033, 0x200012, 0x280281  /* 0x0013F0 .. ..x.........3.:.. ..( */
                                                  434:       .pword      0x2FFC60, 0x40000F, 0x07FE73, 0x400FE1, 0x3A0006, 0xB3C410, 0x07115C, 0x07162B  /* 0x001400 `./..@s....@..:...\..+.. */
                                                  435:       .pword      0x885320, 0x885331, 0x37FFBB, 0x0714DB, 0xE00000, 0x320007, 0xEB0080, 0x2FFC60  /* 0x001410  S.1S...7........2...`./ */
                                                  436:       .pword      0x40000F, 0x073FD9, 0x780480, 0x548FE1, 0x3A0005, 0x200011, 0x2FFC60, 0x40000F  /* 0x001420 ..@.?...x..T..:.. `./..@ */
                                                  437:       .pword      0x073FD2, 0x780480, 0x780009, 0x071765, 0x071616, 0x885320, 0x885331, 0x2FFC60  /* 0x001430 .?...x..xe..... S.1S.`./ */
                                                  438:       .pword      0x40000F, 0x07170B, 0xB3C410, 0x07113F, 0xE00009, 0x3DFFA0, 0xEC6A98, 0x805382  /* 0x001440 ..@......?.......=.j..S. */
                                                  439:       .pword      0x805393, 0xDD1842, 0xDE10CE, 0x700081, 0xDD1042, 0x0715F1, 0xEB0000, 0x071751  /* 0x001450 .S.B.......pB........Q.. */
                                                  440:       .pword      0x37FF95, 0x78054F, 0xBE044F, 0xFA8000, 0x060000, 0x4787EE, 0xBE9F88, 0xBE9F8A  /* 0x001460 ..7O.xO..........G...... */
                                                  441:       .pword      0xBE9F8C, 0x781F8E, 0x780600, 0x9FB7C1, 0x9FB7F2, 0x780583, 0x780684, 0x780485  /* 0x001470 .....x..x........x..x..x */
                                                  442:       .pword      0x9FB7D6, 0x9FBF87, 0xEB0000, 0x9FB7B0, 0xBE001B, 0x500FE0, 0x588FE0, 0x3A000D  /* 0x001480 .................P..X..: */
                                                  443:       .pword      0x90002C, 0x900160, 0x9001F0, 0xBE8D82, 0x370008, 0x78048A, 0x370008, 0x78048A  /* 0x001490 ,..`..........7..x..7..x */
                                                  444:       .pword      0x370006, 0x78048A, 0x370004, 0x78048A, 0x370002, 0x97B98F, 0x618768, 0x780209  /* 0x0014A0 ..7..x..7..x..7...h.a..x */
                                                  445:       .pword      0x78018D, 0x78010B, 0x5780FA, 0x78000C, 0x070067, 0x780400, 0x97B03F, 0x500FEF  /* 0x0014B0 ..x..x..W..xg....x?....P */
                                                  446:       .pword      0x320057, 0x500FFD, 0x3A0004, 0x9000AC, 0xB3C1D2, 0x987082, 0x370054, 0xE80509  /* 0x0014C0 W.2..P..:.......p.T.7... */
                                                  447:       .pword      0x904838, 0x504FEF, 0x320006, 0x504FE8, 0x320004, 0xB3CE51, 0x10CF98, 0x3A0051  /* 0x0014D0 8H..OP..2.OP..2Q.....Q.: */
                                                  448:       .pword      0x37FFDC, 0xE00418, 0x3AFFDC, 0x2000F0, 0x370046, 0xE0000E, 0x320005, 0xFB8000  /* 0x0014E0 ..7.....:.. F.7.....2... */
                                                  449:       .pword      0x97B15F, 0x610080, 0x500F81, 0x3AFFD5, 0x9FB7E8, 0x97F10F, 0x780088, 0x97B07F  /* 0x0014F0 _....a..P..:........x... */
                                                  450:       .pword      0x070DD4, 0xE00400, 0x32FFD0, 0x97B04F, 0x97B0EF, 0x200272, 0x400102, 0x09000A  /* 0x001500 ........2O.....r. ..@... */
                                                  451:       .pword      0x785931, 0xB100B1, 0x9001AC, 0x980843, 0x780008, 0x074569, 0x97B14F, 0x980140  /* 0x001510 1Yx......C....xiE.O..@.. */
                                                  452:       .pword      0x980151, 0x980160, 0x980171, 0xEB0000, 0x980950, 0x980960, 0xB80060, 0x980920  /* 0x001520 Q..`..q.....P..`..`.. .. */
                                                  453:       .pword      0x980931, 0x900868, 0x9008F8, 0x980900, 0x980911, 0x904838, 0xFB8000, 0x981100  /* 0x001530 1..h...........8H....... */
                                                  454:       .pword      0xA34800, 0x320007, 0x9049D8, 0x986163, 0x900078, 0x981110, 0x900C08, 0x981128  /* 0x001540 .H...2.I.ca.x........(.. */
                                                  455:       .pword      0x370005, 0x900938, 0x97B0CF, 0x981092, 0x900C48, 0x9810A8, 0x97B1CF, 0x9809F9  /* 0x001550 ..78........H........... */
                                                  456:       .pword      0x7819BC, 0x7811AC, 0xBE001C, 0x780103, 0x980120, 0x980131, 0xEB0000, 0x370003  /* 0x001560 ..x..x.....x ..1.......7 */
                                                  457:       .pword      0x2000F0, 0x370001, 0x2000F0, 0x78074F, 0xBE064F, 0xBE054F, 0xBE044F, 0xB100EF  /* 0x001570 .. ..7.. O.xO..O..O..... */
                                                  458:       .pword      0x060000, 0xE00418, 0x3AFFB2, 0x37FFF6, 0x4787E4, 0xBE9F88, 0xBE9F8A, 0xBE9F8C  /* 0x001580 ........:..7..G......... */
                                                  459:       .pword      0x781F8E, 0x780280, 0x9FBF81, 0xBE0402, 0x780684, 0x900525, 0x90094A, 0x9009DA  /* 0x001590 ..x..x........x%..J..... */
                                                  460:       .pword      0xDD184B, 0xDE1145, 0x700102, 0xDE19C5, 0xFB8702, 0x090011, 0xD8868E, 0x780580  /* 0x0015A0 K..E....p..............x */
                                                  461:       .pword      0x9068EA, 0x50CFE3, 0x320012, 0xBE0118, 0x510FE0, 0x598FE0, 0x3A000E, 0x9010DA  /* 0x0015B0 .h...P..2.....Q..Y..:... */
                                                  462:       .pword      0x568F81, 0x390005, 0x2000F0, 0x97B88F, 0x780880, 0xEB0000, 0x370064, 0xBE0115  /* 0x0015C0 ..V..9.. .....x...d.7... */
                                                  463:       .pword      0x78000A, 0x0711F4, 0x458400, 0x4884E0, 0x370038, 0x906E5A, 0xFB860C, 0x090011  /* 0x0015D0 ..x.....E..H8.7Zn....... */
                                                  464:       .pword      0xD8858C, 0x780600, 0x560F99, 0x310003, 0xEB0C80, 0x781C35, 0x781425, 0x780019  /* 0x0015E0 .....x..V..1...5.x%.x..x */
                                                  465:       .pword      0x90695A, 0xFB8102, 0xB98102, 0x558582, 0x560F80, 0x360022, 0xBE0118, 0x78000A  /* 0x0015F0 Zi.........U..V".6.....x */
                                                  466:       .pword      0x0741B7, 0xBE8C00, 0x90696A, 0x514FE3, 0x3A000A, 0x2FFF82, 0x20FFF3, 0x500F82  /* 0x001600 .A....ji..OQ..:../.. ..P */
                                                  467:       .pword      0x588F83, 0x3A000F, 0x2000F0, 0x97B98F, 0x780980, 0xEB0000, 0x37003C, 0x2FFF82  /* 0x001610 ..X..:.. .....x...<.7../ */
                                                  468:       .pword      0x200003, 0x500F82, 0x588F83, 0x3A0005, 0x2000F0, 0x97B98F, 0x780980, 0xEB0000  /* 0x001620 .. ..P..X..:.. .....x... */
                                                  469:       .pword      0x370032, 0xE80019, 0x780C80, 0x9068DA, 0xFB8081, 0x558581, 0x560F80, 0x3EFFDE  /* 0x001630 2.7.....x.h......U..V..> */
                                                  470:       .pword      0xBE0118, 0x78000A, 0x0711BB, 0x458400, 0x4884E0, 0x90102A, 0x140FB0, 0x1C8FA0  /* 0x001640 .....x.....E..H*........ */
                                                  471:       .pword      0x32001B, 0xEB0080, 0x78000A, 0x070AA7, 0xE00400, 0x3A0005, 0x200090, 0x97B88F  /* 0x001650 ..2.....x........:.. ... */
                                                  472:       .pword      0x780880, 0xEB0000, 0x370018, 0x90113A, 0x90108A, 0x90104A, 0x900242, 0xBE0108  /* 0x001660 ..x.....7:.....J..B..... */
                                                  473:       .pword      0x010004, 0xE00400, 0x3A0005, 0x200080, 0x97B90F, 0x780900, 0xEB0000, 0x37000B  /* 0x001670 ........:.. .....x.....7 */
                                                  474:       .pword      0x90102A, 0xBE8808, 0x90102A, 0x98005A, 0x090011, 0xD8868E, 0xDD0EC5, 0x90100A  /* 0x001680 *.....*..Z.............. */
                                                  475:       .pword      0x40000D, 0x97B98F, 0xEB0980, 0x78074F, 0xBE064F, 0xBE054F, 0xBE044F, 0xB1004F  /* 0x001690 ..@......O.xO..O..O..O.. */
                                                  476:       .pword      0x060000, 0xBE9F88, 0x504FE9, 0x3A000F, 0x807912, 0x210041, 0xA34802, 0x3A0001  /* 0x0016A0 .......OP..:.y.A.!.H...: */
                                                  477:       .pword      0x5080E4, 0x20F222, 0x780192, 0xDE19C4, 0xEA8183, 0x6181E1, 0xDD19C4, 0x780212  /* 0x0016B0 ..P". ..x........a.....x */
                                                  478:       .pword      0xA14004, 0x720903, 0x370023, 0x807912, 0x2100C1, 0xA35802, 0x3A0001, 0x5080E4  /* 0x0016C0 .@...r#.7.y...!.X...:..P */
                                                  479:       .pword      0x20F222, 0x780192, 0xDE19C5, 0xEA8183, 0x6181E1, 0xDD19C5, 0x780212, 0xA15004  /* 0x0016D0 ". ..x........a.....x.P. */
                                                  480:       .pword      0x720903, 0x504FED, 0x3A0013, 0x805412, 0x900372, 0x900C02, 0x900C92, 0x900242  /* 0x0016E0 ..r.OP..:.T.r........B.. */
                                                  481:       .pword      0xEB0380, 0x530308, 0x5B8389, 0xEB0280, 0x530F84, 0x5B8F85, 0x360002, 0x900042  /* 0x0016F0 .....S..[.....S..[..6B.. */
                                                  482:       .pword      0x370026, 0x900072, 0x900A02, 0x900A92, 0x500004, 0x370021, 0x805412, 0x900A52  /* 0x001700 &.7r..........P!.7.T.R.. */
                                                  483:       .pword      0xB23004, 0x201003, 0x520F83, 0x3A0008, 0x504FE9, 0x3A0002, 0x900042, 0x370041  /* 0x001710 .0... ..R..:.OP..:B..A.7 */
                                                  484:       .pword      0x900A02, 0x900A92, 0x780004, 0x37003D, 0x900452, 0x9004E2, 0x900B02, 0x900B92  /* 0x001720 ........x=.7R........... */
                                                  485:       .pword      0x900242, 0x540306, 0x5C8387, 0xEB0280, 0x530F84, 0x5B8F85, 0x360002, 0x900042  /* 0x001730 B....T..\.....S..[..6B.. */
                                                  486:       .pword      0x370030, 0x900352, 0x9003E2, 0x900A02, 0x900A92, 0x530004, 0x37002A, 0x900922  /* 0x001740 0.7R.............S*.7".. */
                                                  487:       .pword      0x980092, 0x37000E, 0x900A32, 0x900932, 0x904112, 0xFB8102, 0xE80102, 0xB91166  /* 0x001750 .....72..2...A.......f.. */
                                                  488:       .pword      0x790264, 0x980094, 0x370005, 0x900A32, 0x900992, 0x900902, 0x420102, 0x980092  /* 0x001760 d.y.....72..........B... */
                                                  489:       .pword      0xEB4100, 0x984092, 0xB23FF0, 0x2FC002, 0x610111, 0x700002, 0x780880, 0x805412  /* 0x001770 .A..@..?.../..a..p..x.T. */
                                                  490:       .pword      0x900192, 0xDE19CB, 0x6181E1, 0xDD19CE, 0xA1E000, 0x718000, 0x780880, 0x900112  /* 0x001780 ........a........q..x... */
                                                  491:       .pword      0xDE114A, 0x610161, 0xDD114B, 0xA1B000, 0x710000, 0xA0F000, 0x780880, 0xBE044F  /* 0x001790 J..a.aK.......q.....xO.. */
                                                  492:       .pword      0x060000, 0x900A52, 0xB23004, 0x201003, 0x520F83, 0x3AFFDD, 0x37FFD3, 0x4787EA  /* 0x0017A0 ...R...0... ..R..:..7..G */
                                                  493:       .pword      0xBE9F88, 0xBE9F8A, 0xBE9F8C, 0x781F8E, 0x8053D9, 0x20F220, 0xA16010, 0xA17010  /* 0x0017B0 ...........x.S. . .`..p. */
                                                  494:       .pword      0x20F258, 0xE80588, 0xEB0500, 0xE90688, 0x780600, 0x20040E, 0xDD5043, 0x400066  /* 0x0017C0 X. ...........x.. CP.f.@ */
                                                  495:       .pword      0x78006D, 0xA31800, 0x32000C, 0x97F8F8, 0x904049, 0x50CF80, 0x3A004C, 0x904059  /* 0x0017D0 m.x.....2...I@...PL.:Y@. */
                                                  496:       .pword      0x104F98, 0x3A0049, 0x904069, 0x104F9B, 0x3A0046, 0xA0601C, 0x370044, 0x780008  /* 0x0017E0 .O.I.:i@..O.F.:.`.D.7..x */
                                                  497:       .pword      0x904909, 0xFB8102, 0x904899, 0xDD08C8, 0x710081, 0xE90108, 0x108F92, 0x3A001A  /* 0x0017F0 .I.....H......q........: */
                                                  498:       .pword      0x904929, 0xFB8102, 0x9048B9, 0xDD08C8, 0x710081, 0x108F9B, 0x3A0013, 0xDD50C3  /* 0x001800 )I.....H......q.....:.P. */
                                                  499:       .pword      0x4080E6, 0x7880ED, 0xA37801, 0x32000D, 0xA0701C, 0x904148, 0x20F181, 0x784882  /* 0x001810 ..@..x.x...2.p.HA... .Hx */
                                                  500:       .pword      0xDD50C3, 0x4080E6, 0x7880ED, 0xA32801, 0x320005, 0x904138, 0x20F121, 0x784882  /* 0x001820 .P...@..x.(...28A.!. .Hx */
                                                  501:       .pword      0x370001, 0xA0601C, 0xE90080, 0xEB8100, 0x110F91, 0x3A001D, 0x110F9B, 0x3A001B  /* 0x001830 ..7.`............:.....: */
                                                  502:       .pword      0x904909, 0xFB8102, 0x904999, 0xDD19C8, 0x718182, 0x9FB7D3, 0x904929, 0xFB8102  /* 0x001840 .I.....I......q...)I.... */
                                                  503:       .pword      0x9049B9, 0xDD19C8, 0x710103, 0x9FB7E2, 0x97F970, 0x9FEFE2, 0x784010, 0x9FEFF0  /* 0x001850 .I......q...p......@x... */
                                                  504:       .pword      0x78409B, 0x9FF781, 0x200084, 0x200005, 0x578176, 0x200791, 0xEBC000, 0x071294  /* 0x001860 .@x..... .. v.W.. ...... */
                                                  505:       .pword      0xE00400, 0x3A0001, 0xA0601C, 0x67001C, 0x320012, 0xDD50C3, 0x20F240, 0x400181  /* 0x001870 .....:.`...g..2.P.@. ..@ */
                                                  506:       .pword      0x20F172, 0x9041D3, 0x784903, 0x4080E6, 0x7880E0, 0xB3C010, 0xA32801, 0x32000D  /* 0x001880 r. .A..Ix..@..x....(...2 */
                                                  507:       .pword      0xDD50C3, 0x4080E4, 0x20F242, 0x20F120, 0x78C862, 0xB3C010, 0x370006, 0xE8050A  /* 0x001890 .P...@B.  . b.x.....7... */
                                                  508:       .pword      0x440468, 0x4585E8, 0x550FE2, 0x3AFF92, 0xEB4000, 0x78074F, 0xBE064F, 0xBE054F  /* 0x0018A0 h.D..E..U..:.@.O.xO..O.. */
                                                  509:       .pword      0xBE044F, 0xB100AF, 0x060000, 0xE8878F, 0xBE9F88, 0xBE9F8A, 0xBE9F8C, 0x781F8E  /* 0x0018B0 O......................x */
                                                  510:       .pword      0x784681, 0x784602, 0x780483, 0x780404, 0x780505, 0x780586, 0x784707, 0xB3C061  /* 0x0018C0 .Fx.Fx..x..x..x..x.Gxa.. */
                                                  511:       .pword      0x20F152, 0x104F92, 0x3A0066, 0x20F002, 0x805400, 0x610100, 0xB3C011, 0x204000  /* 0x0018D0 R. .O.f.:.. .T...a....@  */
                                                  512:       .pword      0x510F80, 0x3A005F, 0x807900, 0x900010, 0xB3C101, 0xA39800, 0x32005A, 0x564FEB  /* 0x0018E0 ..Q_.:.y..........Z.2.OV */
                                                  513:       .pword      0x3A002E, 0x8078F0, 0xB3C031, 0xE00000, 0x320054, 0x9040E0, 0xFB8081, 0x508F88  /* 0x0018F0 ..:.x.1.....T.2.@......P */
                                                  514:       .pword      0x320057, 0x780010, 0xE00000, 0x320048, 0x9040E0, 0xFB8081, 0x508F88, 0x3AFFF9  /* 0x001900 W.2..x...H.2.@......P..: */
                                                  515:       .pword      0x37004F, 0x900122, 0xE00002, 0x32000B, 0x900192, 0xB3C031, 0xA39803, 0x3A0004  /* 0x001910 O.7".......2...1.......: */
                                                  516:       .pword      0x370040, 0x900092, 0xA39801, 0x32003A, 0x780112, 0xE00002, 0x3AFFFA, 0x900110  /* 0x001920 @.7......:.2..x.....:... */
                                                  517:       .pword      0xB3C031, 0xE00002, 0x320036, 0x9040A2, 0xFB8081, 0x508F89, 0x32003E, 0x780112  /* 0x001930 1.....6.2.@......P>.2..x */
                                                  518:       .pword      0xE00002, 0x32002E, 0x9040A2, 0xFB8081, 0x508F89, 0x3AFFF9, 0x370036, 0x564FE1  /* 0x001940 .....2.@......P..:6.7.OV */
                                                  519:       .pword      0x3A0006, 0xE00009, 0x3A0004, 0x56CFE2, 0x3E0002, 0x784008, 0x0711A6, 0x805421  /* 0x001950 ..:.....:..V..>.@x...!T. */
                                                  520:       .pword      0x78488D, 0x98409C, 0x9840A9, 0xDE4CC8, 0x9840B9, 0x9840C8, 0xDE4448, 0x9840D8  /* 0x001960 .Hx.@..@..L..@..@.HD..@. */
                                                  521:       .pword      0x9840EA, 0xDE5048, 0x9840F0, 0x807900, 0x97E92F, 0x985812, 0xE0040E, 0x3A0006  /* 0x001970 .@.HP..@..y./...X......: */
                                                  522:       .pword      0x78020A, 0x78018B, 0x200082, 0x070FA5, 0xEB4080, 0x37000B, 0x78020A, 0x78018B  /* 0x001980 ..x..x.. ....@...7..x..x */
                                                  523:       .pword      0x200082, 0x07105D, 0xEB4080, 0x370005, 0xB3C031, 0x370003, 0xB3C031, 0x370001  /* 0x001990 .. ]...@...71....71....7 */
                                                  524:       .pword      0xB3C031, 0x784001, 0x78074F, 0xBE064F, 0xBE054F, 0xBE044F, 0xB1002F, 0x060000  /* 0x0019A0 1...@xO.xO..O..O../..... */
                                                  525:       .pword      0x900120, 0xB3C031, 0xE00002, 0x3AFFAD, 0x37FFF4, 0x980022, 0x37FFD0, 0xBE9F88  /* 0x0019B0  ..1.......:..7"....7... */
                                                  526:       .pword      0xBE9F8A, 0xBE9F8C, 0x781F8E, 0xEB4380, 0x784487, 0x200015, 0xB3C2E2, 0x114F90  /* 0x0019C0 ........x.C..Dx.. ....O. */
                                                  527:       .pword      0x3A0058, 0x904110, 0xB3C035, 0xE00402, 0x320065, 0xB3C2F3, 0x514F83, 0x320062  /* 0x0019D0 X.:.A.5.....e.2....OQb.2 */
                                                  528:       .pword      0x784387, 0x784487, 0x200015, 0xE94183, 0x514F83, 0x3A004B, 0x904120, 0xB3C035  /* 0x0019E0 .Cx.Dx.. .A..OQK.: A.5.. */
                                                  529:       .pword      0xE00402, 0x320058, 0xE84183, 0x514F83, 0x320055, 0x784387, 0x784487, 0x200015  /* 0x0019F0 ...X.2.A..OQU.2.Cx.Dx..  */
                                                  530:       .pword      0x370040, 0x528FE1, 0x3A0030, 0xE84387, 0x41C70B, 0x574FF9, 0x360024, 0x41C70D  /* 0x001A00 @.7..R0.:.C...A.OW$.6..A */
                                                  531:       .pword      0x574FE9, 0x360021, 0xE00402, 0x35001F, 0xB3C2E2, 0x51CF82, 0x320004, 0x51416D  /* 0x001A10 .OW!.6.....5.....Q..2mAQ */
                                                  532:       .pword      0x51CF82, 0x3A0005, 0x370018, 0xE00409, 0x320043, 0x200025, 0x370016, 0x28003E  /* 0x001A20 ..Q..:..7...C.2%. ..7>.( */
                                                  533:       .pword      0xB3C012, 0x11CFDE, 0x320004, 0xE84102, 0x514FF1, 0x3AFFFB, 0x370002, 0x514FF1  /* 0x001A30 ........2.A..OQ..:..7.OQ */
                                                  534:       .pword      0x3A000A, 0xE00401, 0x320005, 0x51CF88, 0x320006, 0x51CF8A, 0x3A0003, 0x370003  /* 0x001A40 ..:.....2..Q..2..Q..:..7 */
                                                  535:       .pword      0x200025, 0x370001, 0x200025, 0xE00409, 0x320004, 0xB3C019, 0x53CFE3, 0x3E002A  /* 0x001A50 %. ..7%. .....2.....S*.> */
                                                  536:       .pword      0x370002, 0x53CFE8, 0x3E0027, 0x528FE2, 0x3A0013, 0x78010C, 0x11CFD2, 0x3A0006  /* 0x001A60 ..7..S'.>..R..:..x.....: */
                                                  537:       .pword      0xE00401, 0x320015, 0x51CF88, 0x320002, 0x51CF8A, 0x3A0013, 0x510F84, 0x3AFFF6  /* 0x001A70 .....2..Q..2..Q..:..Q..: */
                                                  538:       .pword      0x370007, 0xB3C2F6, 0x28013C, 0x460269, 0xB3C3F8, 0xB3C2AA, 0xB3CBFB, 0xB3CD0D  /* 0x001A80 ..7...<.(i.F............ */
                                                  539:       .pword      0x784130, 0x784182, 0xE00402, 0x320006, 0x514F86, 0x3AFFB3, 0x370003, 0xEB4280  /* 0x001A90 0Ax.Ax.....2.OQ..:..7.B. */
                                                  540:       .pword      0x370001, 0xEB4280, 0x784005, 0x78074F, 0xBE064F, 0xBE054F, 0xBE044F, 0x060000  /* 0x001AA0 ..7.B..@xO.xO..O..O..... */
                                                  541:       .pword      0xEB4380, 0x37FFD3, 0x200025, 0x37FFD9, 0xFA0010, 0x781F88, 0x780400, 0x901138  /* 0x001AB0 .C...7%. ..7.....x..x8.. */
                                                  542:       .pword      0x901088, 0x901048, 0x900242, 0xB81160, 0x010004, 0x784080, 0x200080, 0xE00401  /* 0x001AC0 ...H..B..`......@x.. ... */
                                                  543:       .pword      0x32006C, 0x901028, 0xEB0800, 0x781030, 0x901088, 0x93F9E1, 0x200040, 0xB3C552  /* 0x001AD0 l.2(.....0.x......@. R.. */
                                                  544:       .pword      0x51CF82, 0x3A0063, 0x93F9F1, 0xB3CAA2, 0x51CF82, 0x3A005F, 0x907161, 0xB3C460  /* 0x001AE0 ..Qc.:........Q_.:aq.`.. */
                                                  545:       .pword      0x514F80, 0x3A0016, 0x907171, 0x504065, 0x514F80, 0x3A0012, 0x907901, 0x404073  /* 0x001AF0 .OQ..:qq.e@P.OQ..:.y.s@@ */
                                                  546:       .pword      0x514F80, 0x3A000E, 0x907911, 0xB3C310, 0x514F80, 0x3A000A, 0x906161, 0x504068  /* 0x001B00 .OQ..:.y.....OQ..:aa.h@P */
                                                  547:       .pword      0x514F80, 0x3A0006, 0xEB0C00, 0x781438, 0xB3C020, 0x986C60, 0xEB0000, 0x370045  /* 0x001B10 .OQ..:...8.x ..`l....E.7 */
                                                  548:       .pword      0x90D121, 0xB3C460, 0x514F80, 0x3A0016, 0x90D131, 0x504065, 0x514F80, 0x3A0012  /* 0x001B20 !..`...OQ..:1..e@P.OQ..: */
                                                  549:       .pword      0x90D141, 0x404073, 0x514F80, 0x3A000E, 0x90D151, 0xB3C330, 0x514F80, 0x3A000A  /* 0x001B30 A..s@@.OQ..:Q..0...OQ..: */
                                                  550:       .pword      0x90C121, 0x50406A, 0x514F80, 0x3A0006, 0xEB0C00, 0x781438, 0xB3C030, 0x986C60  /* 0x001B40 !..j@P.OQ..:...8.x0..`l. */
                                                  551:       .pword      0xEB0000, 0x37002B, 0xEB4000, 0x986C60, 0x201BE0, 0x400001, 0xB01EE1, 0x200014  /* 0x001B50 ...+.7.@.`l... ..@.....  */
                                                  552:       .pword      0x240503, 0x218005, 0x578172, 0x09000F, 0x785930, 0xB10100, 0x97BB3F, 0x97BBCF  /* 0x001B60 ..$..!r.W...0Yx...?..... */
                                                  553:       .pword      0xBE8C06, 0x97F12F, 0x514FEE, 0x3E0014, 0xFB0102, 0xDD2102, 0x610303, 0x3A0008  /* 0x001B70 .../...OQ..>....!...a..: */
                                                  554:       .pword      0x610305, 0x3A000A, 0xA31802, 0x32000C, 0xB3C010, 0x986C60, 0xEB0000, 0x37000D  /* 0x001B80 ..a..:.....2...`l......7 */
                                                  555:       .pword      0xB3C020, 0x986C60, 0xEB0000, 0x370009, 0xB3C030, 0x986C60, 0xEB0000, 0x370005  /* 0x001B90  ..`l......70..`l......7 */
                                                  556:       .pword      0x500F81, 0x320002, 0x400070, 0x37FFDE, 0x200050, 0x78044F, 0xFA8000, 0x060000  /* 0x001BA0 ..P..2p.@..7P. O.x...... */
                                                  557:       .pword      0xFA0044, 0xBE9F88, 0x781F8A, 0xBE9F8C, 0x780500, 0x780481, 0xEB0000, 0x9FB7F0  /* 0x001BB0 D.......x.....x..x...... */
                                                  558:       .pword      0x9FBFA0, 0xBE001A, 0x9F9FA0, 0x9F9FB1, 0x500FE0, 0x588FE0, 0x3A0005, 0x90002A  /* 0x001BC0 ..............P..X..:*.. */
                                                  559:       .pword      0x900160, 0x9001F0, 0x9F9FA2, 0x9F9FB3, 0x90042A, 0x9FA7E8, 0xEB4080, 0x780009  /* 0x001BD0 `...........*......@...x */
                                                  560:       .pword      0x07FEEE, 0xE00400, 0x320002, 0x504FE3, 0x3A0004, 0xB3C130, 0x987400, 0xEB8000  /* 0x001BE0 ........2.OP..:0...t.... */
                                                  561:       .pword      0x370056, 0x504FE1, 0x3A000F, 0x2FFB41, 0x40808F, 0x780009, 0x0709D2, 0xB3C013  /* 0x001BF0 V.7.OP..:A./..@..x...... */
                                                  562:       .pword      0xB3C102, 0x5780F2, 0x2FFB40, 0x40000F, 0x071012, 0x780080, 0xEB8000, 0xE00001  /* 0x001C00 .....W@./..@.....x...... */
                                                  563:       .pword      0x320005, 0x370045, 0xB3C130, 0x987400, 0xEB8000, 0x370041, 0x97982F, 0x9798BF  /* 0x001C10 ..2E.70...t....A.7/..... */
                                                  564:       .pword      0x97A16F, 0x9001F2, 0x900162, 0xB86660, 0x500F82, 0x588F83, 0x320001, 0xBE0600  /* 0x001C20 o.....b..`f...P..X..2... */
                                                  565:       .pword      0x9F9FC0, 0x9F9FD1, 0xBE8D00, 0x9FBF80, 0x9FBF91, 0x97B27F, 0x5781EC, 0x578170  /* 0x001C30 ....................Wp.W */
                                                  566:       .pword      0x2FFB21, 0x40808F, 0x78000A, 0x07FCA0, 0xE00000, 0x3A0005, 0x90002A, 0x9771AF  /* 0x001C40 !./..@..x........:*...q. */
                                                  567:       .pword      0x987003, 0xEB8000, 0x370024, 0x9048D0, 0x9FEFC1, 0x900170, 0x9FB7D2, 0x900980  /* 0x001C50 .p....$.7.H....p........ */
                                                  568:       .pword      0x9FB7C3, 0x0741C5, 0xBE0400, 0x97986F, 0x9798FF, 0xBE8D00, 0x9FBF80, 0x9FBF91  /* 0x001C60 ....A....o.............. */
                                                  569:       .pword      0xEB0000, 0x9FBFA0, 0x9FB7F0, 0xEB0200, 0x5781EC, 0x578170, 0x2FFB21, 0x40808F  /* 0x001C70 ..............Wp.W!./..@ */
                                                  570:       .pword      0x78000A, 0x07FC82, 0x97982F, 0x9798BF, 0xBE8D00, 0x90002A, 0x5780F8, 0xBE020C  /* 0x001C80 ..x.../........*....W... */
                                                  571:       .pword      0xBE0108, 0x0708B3, 0x780080, 0xEB8000, 0xE00001, 0x320001, 0xEB0000, 0xBE064F  /* 0x001C90 ........x........2...O.. */
                                                  572:       .pword      0x78054F, 0xBE044F, 0xFA8000, 0x060000, 0xFA000E, 0xBE9F88, 0xBE9F8A, 0xBE9F8C  /* 0x001CA0 O.xO.................... */
                                                  573:       .pword      0x780500, 0x784682, 0x900CCA, 0x780411, 0x200010, 0x9FB7B0, 0x9FB7E9, 0xBE001A  /* 0x001CB0 ..x.Fx.....x.. ......... */
                                                  574:       .pword      0x9FB7C0, 0x9FB7D1, 0x9FB7F0, 0x9FBF81, 0x500FE0, 0x588FE0, 0x3A0004, 0x900069  /* 0x001CC0 ..............P..X..:i.. */
                                                  575:       .pword      0x9000F9, 0x9FB7F0, 0x9FBF81, 0xEB0000, 0x9FBF90, 0x780208, 0x5781EE, 0x578172  /* 0x001CD0 .................x..Wr.W */
                                                  576:       .pword      0x5780FA, 0x578078, 0x07FC51, 0xE00000, 0x32000A, 0x784090, 0x40CFFB, 0x32000F  /* 0x001CE0 ..Wx.WQ.......2.@x..@..2 */
                                                  577:       .pword      0xB3CE5B, 0x20040C, 0xE00401, 0x3A000F, 0x37000A, 0xE00000, 0x3A0003, 0x97B03F  /* 0x001CF0 [.... .....:..7.....:?.. */
                                                  578:       .pword      0x987480, 0x370048, 0x784090, 0x40CFFB, 0x320002, 0xE00401, 0x3A0004, 0xB3C0C0  /* 0x001D00 .t.H.7.@x..@..2.....:... */
                                                  579:       .pword      0x987480, 0x2000C0, 0x37003F, 0x78480B, 0x901129, 0x9001C2, 0xA00003, 0x980143  /* 0x001D10 .t... ?.7.Hx)........C.. */
                                                  580:       .pword      0x904830, 0x504FEF, 0x3A0002, 0x660081, 0x3A000C, 0xE00008, 0x32000A, 0xE90408  /* 0x001D20 0H..OP..:..f..:.....2... */
                                                  581:       .pword      0x780208, 0x5781EE, 0x578172, 0x5780FA, 0x578078, 0x07FC26, 0x9048B0, 0x50CFEF  /* 0x001D30 ..x..Wr.W..Wx.W&...H...P */
                                                  582:       .pword      0x32FFDC, 0x97B0BF, 0xE00001, 0x3A0010, 0x90004A, 0x9000DA, 0x900169, 0x9001F9  /* 0x001D40 ..2........:J.....i..... */
                                                  583:       .pword      0x500F82, 0x588F83, 0x320009, 0xE0040D, 0x320007, 0x780109, 0x070313, 0xA7F000  /* 0x001D50 ..P..X..2.....2..x...... */
                                                  584:       .pword      0xEA0000, 0xE90000, 0xDE004F, 0x9FB7B0, 0x90084A, 0xEB0080, 0x07071C, 0xE00400  /* 0x001D60 ......O.....J........... */
                                                  585:       .pword      0x3A0005, 0x90084A, 0xB3C091, 0x987001, 0xEB8000, 0x37000C, 0x90084A, 0x200011  /* 0x001D70 ..:J......p......7J....  */
                                                  586:       .pword      0x070712, 0xE00400, 0x3A0005, 0x90084A, 0xB3C091, 0x987001, 0xEB8000, 0x370002  /* 0x001D80 ........:J......p......7 */
                                                  587:       .pword      0x97B03F, 0x987480, 0xBE064F, 0xBE054F, 0xBE044F, 0xFA8000, 0x060000, 0xBE9F88  /* 0x001D90 ?...t.O..O..O........... */
                                                  588:       .pword      0x781F8A, 0x784400, 0xEB4000, 0x20EC32, 0xE00412, 0x3A0065, 0x8053C3, 0x780203  /* 0x001DA0 ..x.Dx.@.2. ...e.:.S...x */
                                                  589:       .pword      0x904023, 0xFB8000, 0x904133, 0xDD1148, 0x700102, 0xEB4000, 0x32005C, 0xEB0100  /* 0x001DB0 #@....3A.H....p.@.\.2... */
                                                  590:       .pword      0xB3C506, 0x20ECAA, 0x784380, 0x418002, 0x904010, 0x504FE4, 0x3A0049, 0x418002  /* 0x001DC0 ..... .Cx..A.@..OPI.:..A */
                                                  591:       .pword      0x904050, 0x504FE8, 0x3A0045, 0x418002, 0x904060, 0x504065, 0x504FE1, 0x3E0040  /* 0x001DD0 P@..OPE.:..A`@.e@P.OP@.> */
                                                  592:       .pword      0x418002, 0x904070, 0x504F86, 0x3A003C, 0x418002, 0x904020, 0x784D00, 0x794063  /* 0x001DE0 ..Ap@..OP<.:..A @..Mxc@y */
                                                  593:       .pword      0xFB8000, 0x410100, 0x418002, 0x904010, 0x504FE5, 0x3A0032, 0x784487, 0x784007  /* 0x001DF0 .....A..A.@..OP2.:.Dx.@x */
                                                  594:       .pword      0x418282, 0x9042B5, 0x52CFE2, 0x3A000A, 0x418282, 0x9042A5, 0xE00405, 0x3D0003  /* 0x001E00 ..A.B...R..:..A.B......= */
                                                  595:       .pword      0xE00400, 0x320034, 0x370003, 0xE00409, 0x3A0001, 0x784485, 0x7942E3, 0xFB8285  /* 0x001E10 ...4.2..7.....:.Dx.By... */
                                                  596:       .pword      0x410105, 0x418282, 0x904295, 0x52CFE5, 0x32FFEB, 0xE00400, 0x320019, 0xE00409  /* 0x001E20 ..A..A.B...R..2.....2... */
                                                  597:       .pword      0x320017, 0x20EC32, 0x784908, 0xE80102, 0x784901, 0x4100E7, 0x784880, 0xE80081  /* 0x001E30 ..22. .Ix....Ix..A.Hx... */
                                                  598:       .pword      0x784889, 0x24E203, 0x200012, 0x784080, 0x784008, 0x071088, 0x24E203, 0x200012  /* 0x001E40 .Hx..$.. .@x.@x.....$..  */
                                                  599:       .pword      0x784089, 0x784008, 0x071083, 0xB3C101, 0x20EC60, 0x784801, 0xB3C010, 0x37000B  /* 0x001E50 .@x.@x......`. .Hx.....7 */
                                                  600:       .pword      0x794063, 0xFB8000, 0x410100, 0x9042A4, 0xFB8285, 0x904034, 0xDD0048, 0x728000  /* 0x001E60 c@y.....A.B....4@.H....r */
                                                  601:       .pword      0x500F82, 0x3EFFA9, 0xEB4000, 0x78054F, 0xBE044F, 0x060000, 0x784005, 0x37FFCE  /* 0x001E70 ..P..>.@.O.xO......@x..7 */
                                                  602:       .pword      0xFA0014, 0xBE9F88, 0xBE9F8A, 0xBE9F8C, 0x780400, 0x780501, 0x784582, 0xBE0604  /* 0x001E80 ..............x..x.Ex... */
                                                  603:       .pword      0xEB0000, 0x9FB780, 0x9FB7E0, 0xBE0018, 0x9FB790, 0x9FB7A1, 0x900948, 0x9FB7B2  /* 0x001E90 ..................H..... */
                                                  604:       .pword      0x9FB7C0, 0x9FB7D1, 0x78021A, 0x5781F4, 0x578178, 0x2FFE01, 0x40808F, 0x57807E  /* 0x001EA0 ........x..Wx.W../..@~.W */
                                                  605:       .pword      0x07FB6B, 0x780480, 0xE00009, 0x3A0005, 0x900848, 0xB3C1D1, 0x987001, 0x2001D0  /* 0x001EB0 k....x.....:H......p...  */
                                                  606:       .pword      0x37004A, 0x200271, 0x408088, 0x2000B2, 0x780009, 0x07F30F, 0x984CBB, 0xEB4000  /* 0x001EC0 J.7q. ..@.. ..x....L..@. */
                                                  607:       .pword      0x984CC0, 0x980CDC, 0x20FFF0, 0x60000D, 0xEB0080, 0xDD00C0, 0x200000, 0x980CA1  /* 0x001ED0 .L...... ..`........ ... */
                                                  608:       .pword      0xB80060, 0x980CE0, 0x980CF1, 0x8053B1, 0xE00001, 0x320002, 0x578072, 0x010001  /* 0x001EE0 `.........S......2r.W... */
                                                  609:       .pword      0x97F0AF, 0x984CD1, 0x97B88F, 0x9804F1, 0x97B07F, 0x980C80, 0x980CB1, 0x980CC0  /* 0x001EF0 ....L................... */
                                                  610:       .pword      0x98044C, 0x98045D, 0x98046C, 0x98047D, 0xEB0000, 0x980C50, 0x980C60, 0xB80060  /* 0x001F00 L..]..l..}.....P..`..`.. */
                                                  611:       .pword      0x980C20, 0x980C31, 0x900869, 0x9008F9, 0x980C00, 0x980C11, 0x904839, 0xFB8000  /* 0x001F10  ..1..i...........9H.... */
                                                  612:       .pword      0x981400, 0xA34800, 0x320007, 0x9048D9, 0x986461, 0x900179, 0x981412, 0x900C89  /* 0x001F20 ....H...2.H.ad.y........ */
                                                  613:       .pword      0x981429, 0x370004, 0x900839, 0x981410, 0x900CC9, 0x981429, 0x78051A, 0x980C7A  /* 0x001F30 )....79........)....xz.. */
                                                  614:       .pword      0x97B01F, 0x97B0AF, 0xBE8C00, 0x980420, 0x980431, 0x900848, 0x901020, 0x9000C0  /* 0x001F40 ......... ..1..H.. ..... */
                                                  615:       .pword      0xA00001, 0x980041, 0x97B00F, 0xBE064F, 0xBE054F, 0xBE044F, 0xFA8000, 0x060000  /* 0x001F50 ...A.....O..O..O........ */
                                                  616:       .pword      0x4787EE, 0xBE9F88, 0xBE9F8A, 0xBE9F8C, 0x781F8E, 0x780600, 0x20400D, 0x8054DE  /* 0x001F60 ..G...........x..x.@ .T. */
                                                  617:       .pword      0xEF2A9A, 0x202000, 0x200001, 0x9FB7B0, 0x9FB7C1, 0x57807A, 0x024128, 0x000000  /* 0x001F70 .*..  .. ......z.W(A.... */
                                                  618:       .pword      0x9FB7D0, 0x9FB7E1, 0x9FB7F2, 0x9FBF83, 0x200089, 0xEB0400, 0x37002E, 0x97EACF  /* 0x001F80 .............. .....7... */
                                                  619:       .pword      0x42CFE9, 0x360005, 0x200010, 0x0229C2, 0x000000, 0xEB0000, 0x37004B, 0x97B57F  /* 0x001F90 ..B..6.. .).......K.7... */
                                                  620:       .pword      0x97BD8F, 0xE9000D, 0x97B37F, 0x600086, 0x320005, 0xEB0080, 0x70000A, 0x70808B  /* 0x001FA0 ...........`..2.....p..p */
                                                  621:       .pword      0x400561, 0x4885E0, 0xB86861, 0x97B15F, 0x97B1EF, 0x410000, 0x498081, 0x9FB7D0  /* 0x001FB0 a.@..Hah._.......A..I... */
                                                  622:       .pword      0x9FB7E1, 0x500F8A, 0x588F8B, 0x390010, 0x202080, 0x200001, 0x97B2BF, 0x528F80  /* 0x001FC0 .....P..X..9.  .. .....R */
                                                  623:       .pword      0x310030, 0x57807A, 0x024128, 0x000000, 0x9FB7D0, 0x9FB7E1, 0x9FB7F2, 0x9FBF83  /* 0x001FD0 0.1z.W(A................ */
                                                  624:       .pword      0x550F80, 0x5D8F81, 0x360001, 0xE90408, 0xE80408, 0x78001C, 0x540F80, 0x39FFCF  /* 0x001FE0 ..U..]..6........x..T..9 */
                                                  625:       .pword      0xE80E00, 0x97B05F, 0x97B0EF, 0x0240DC, 0x000000, 0xE00000, 0x3A0016, 0x97B25F  /* 0x001FF0 ..._......@.........:_.. */
                                                  626:       .pword      0x97B2EF, 0x200082, 0x200003, 0x202140, 0x200001, 0x023BEE, 0x000000, 0xE00000  /* 0x002000 ..... .. @! .. .;....... */
                                                  627:       .pword      0x3A000C, 0x207BE0, 0x470700, 0x8854DE, 0x97B05F, 0x97B0EF, 0x024016, 0x000000  /* 0x002010 ..:.{ ..G.T._......@.... */
                                                  628:       .pword      0xEB0000, 0x0229C2, 0x000000, 0x200010, 0x370005, 0xE90489, 0x3AFFDE, 0x200010  /* 0x002020 ....)...... ..7.....:..  */
                                                  629:       .pword      0x370001, 0xEB0000, 0x78074F, 0xBE064F, 0xBE054F, 0xBE044F, 0xB100EF, 0x060000  /* 0x002030 ..7...O.xO..O..O........ */
                                                  630:       .pword      0xFA003A, 0xBE9F88, 0xBE9F8A, 0xBE0500, 0x780402, 0xE00403, 0x32001C, 0xEB4100  /* 0x002040 :.............x.....2.A. */
                                                  631:       .pword      0x78008A, 0x2FFBE0, 0x40000F, 0x070063, 0x780480, 0xE00009, 0x3A0005, 0xB3C211  /* 0x002050 ..x../..@c....x.....:... */
                                                  632:       .pword      0x807B40, 0x987001, 0xEB8000, 0x370057, 0x54850A, 0x98142A, 0xEB0000, 0x981400  /* 0x002060 @{..p....W.7..T*........ */
                                                  633:       .pword      0x97997F, 0x97A18F, 0x980C62, 0x980C73, 0x980C42, 0x980C53, 0x97A09F, 0x907091  /* 0x002070 ......b..s..B..S......p. */
                                                  634:       .pword      0x986461, 0x981410, 0x370011, 0x906068, 0x0710D2, 0x9FA790, 0x900948, 0x9009D8  /* 0x002080 ad......7h`.......H..... */
                                                  635:       .pword      0x9F9FF2, 0x9FA783, 0x070D24, 0xE00000, 0x320005, 0xB3C091, 0x97A01F, 0x987001  /* 0x002090 ......$.......2.......p. */
                                                  636:       .pword      0xEB8000, 0x370039, 0x9014A8, 0x450489, 0xB3C011, 0x780009, 0x07FC88, 0xE00400  /* 0x0020A0 ...9.7.....E.....x...... */
                                                  637:       .pword      0x320002, 0x504FE3, 0x3A0005, 0xB3C131, 0x97A01F, 0x987001, 0xEB8000, 0x37002B  /* 0x0020B0 ..2.OP..:1......p....+.7 */
                                                  638:       .pword      0x504FE1, 0x3A0016, 0x2FFC41, 0x40808F, 0x780009, 0x07076B, 0x2000C7, 0x78030B  /* 0x0020C0 .OP..:A./..@..xk.... ..x */
                                                  639:       .pword      0x901298, 0x200204, 0x420208, 0x4401FC, 0x578175, 0x2FFC41, 0x40808F, 0x2FFBE0  /* 0x0020D0 ..... ..B..Du.WA./..@../ */
                                                  640:       .pword      0x40000F, 0x07F9C3, 0xE00000, 0x320004, 0x97A09F, 0x987080, 0xEB8000, 0x370013  /* 0x0020E0 ..@........2....p......7 */
                                                  641:       .pword      0x5780F5, 0x780008, 0x070952, 0x97E1CF, 0x984C53, 0x97A82F, 0x97A8BF, 0x980470  /* 0x0020F0 ..W..xR.....SL./.....p.. */
                                                  642:       .pword      0x980C01, 0x97B0CF, 0x980C11, 0x97B13F, 0x980C22, 0x97E9AF, 0x985463, 0x97B01F  /* 0x002100 .........?..".....cT.... */
                                                  643:       .pword      0xE80000, 0x981410, 0xEB0000, 0xBE054F, 0xBE044F, 0xFA8000, 0x060000, 0xBE9F88  /* 0x002110 .........O..O........... */
                                                  644:       .pword      0xBE9F8A, 0x781F8C, 0x780580, 0x780481, 0x784602, 0x780009, 0x07F1D8, 0x780400  /* 0x002120 .....x..x..x.Fx..x.....x */
                                                  645:       .pword      0xE00008, 0x32004E, 0x807B20, 0x807B31, 0xBE8D80, 0x807B41, 0x9805A1, 0x540FE1  /* 0x002130 ...N.2 {.1{....A{......T */
                                                  646:       .pword      0x3A0006, 0x90002B, 0x070CCC, 0xE00000, 0x320050, 0xEB0480, 0x37004E, 0x904099  /* 0x002140 ..:+........P.2...N.7.@. */
                                                  647:       .pword      0xB3C3A0, 0x50CF80, 0x3A0015, 0x784019, 0x07106A, 0x9805A0, 0xE00000, 0x32003A  /* 0x002150 .....P..:.@xj........:.2 */
                                                  648:       .pword      0x070CBE, 0xE00000, 0x3A0039, 0x90002B, 0x900160, 0x9001F0, 0xBE8D82, 0xE88489  /* 0x002160 ......9.:+..`........... */
                                                  649:       .pword      0xE98408, 0x32003B, 0xB3C2F0, 0x104F99, 0x3A0003, 0xE80489, 0x540FE1, 0x320035  /* 0x002170 ...;.2....O...:.....T5.2 */
                                                  650:       .pword      0x90002B, 0x070CAD, 0xB3C2FA, 0xE00000, 0x32001D, 0x370028, 0x7C4069, 0x504F8A  /* 0x002180 +.............2(.7i@|.OP */
                                                  651:       .pword      0x3A0004, 0x448008, 0x904010, 0xE00400, 0x320028, 0xE00008, 0x320011, 0x780089  /* 0x002190 ..:..D.@....(.2.....2..x */
                                                  652:       .pword      0x78000B, 0x070314, 0xE00000, 0x32000C, 0xE0040C, 0x32001A, 0x780089, 0x78000B  /* 0x0021A0 ..x........2.....2..x..x */
                                                  653:       .pword      0x07FCFF, 0xE00000, 0x3A0017, 0x780089, 0x78000B, 0x070308, 0xE00000, 0x3A0014  /* 0x0021B0 ........:..x..x........: */
                                                  654:       .pword      0xE80408, 0x448488, 0x780009, 0x070F77, 0x780400, 0x440FE1, 0x3AFFDF, 0x37000D  /* 0x0021C0 .....D..xw....x..D..:..7 */
                                                  655:       .pword      0xEB0480, 0x37000B, 0xEB0480, 0x370009, 0xEB0480, 0x370007, 0xEB0480, 0x370005  /* 0x0021D0 .....7.....7.....7.....7 */
                                                  656:       .pword      0xEB0480, 0x370003, 0xEB0480, 0x370001, 0xEB0480, 0x780009, 0x78064F, 0xBE054F  /* 0x0021E0 .....7.....7.....xO.xO.. */
                                                  657:       .pword      0xBE044F, 0x060000, 0xFA0014, 0xBE9F88, 0x780400, 0xEB0000, 0x9FBFC0, 0x900848  /* 0x0021F0 O.............x......H.. */
                                                  658:       .pword      0x070C6E, 0x780080, 0xEB0000, 0xE00001, 0x3A0058, 0x901898, 0xA30801, 0x320055  /* 0x002200 n....x......X.:......U.2 */
                                                  659:       .pword      0x900848, 0xEB0080, 0x0704C8, 0xE00400, 0x3A0005, 0x900848, 0xB3C091, 0x987001  /* 0x002210 H.............:H......p. */
                                                  660:       .pword      0xEB8000, 0x37004B, 0x900848, 0x200011, 0x0704BE, 0xE00400, 0x3A0005, 0x900848  /* 0x002220 ...K.7H.... ........:H.. */
                                                  661:       .pword      0xB3C091, 0x987001, 0xEB8000, 0x370041, 0x900168, 0x9001F8, 0x900848, 0x073B98  /* 0x002230 ....p....A.7h.....H...;. */
                                                  662:       .pword      0x900848, 0x9FBF90, 0xBE0018, 0x9FB7F0, 0x9FBF81, 0x9FBFA0, 0x9FBFB1, 0x900A78  /* 0x002240 H....................x.. */
                                                  663:       .pword      0x5781E8, 0x57816C, 0x5780E6, 0x578072, 0x07F997, 0x780480, 0xE00009, 0x3A0005  /* 0x002250 ..Wl.W..Wr.W.....x.....: */
                                                  664:       .pword      0x900848, 0xB3C1D1, 0x987001, 0xEB8000, 0x370028, 0x8053B1, 0xE00001, 0x320002  /* 0x002260 H......p....(.7.S......2 */
                                                  665:       .pword      0x578078, 0x010001, 0x97B0DF, 0x980CB1, 0x97B04F, 0x980CC0, 0x900808, 0x900898  /* 0x002270 x.W.........O........... */
                                                  666:       .pword      0x980CE0, 0x980CF1, 0x906088, 0x984CB1, 0x900848, 0x901020, 0x9000C0, 0xA00001  /* 0x002280 .......`..L.H.. ........ */
                                                  667:       .pword      0x980041, 0x900848, 0xEB0080, 0x070487, 0xE00400, 0x32000B, 0x900CC8, 0x780009  /* 0x002290 A..H.............2.....x */
                                                  668:       .pword      0x070E46, 0x987480, 0x900848, 0x907080, 0xEB8000, 0xE00401, 0x3A0006, 0xEB0000  /* 0x0022A0 F...t.H...p.........:... */
                                                  669:       .pword      0x370004, 0x900848, 0xB3C091, 0x987001, 0xEB8000, 0xBE044F, 0xFA8000, 0x060000  /* 0x0022B0 ..7H......p....O........ */
                                                  670:       .pword      0xFA0008, 0xBE9F88, 0xBE9F8A, 0x781F8C, 0x780600, 0xBE0502, 0x90686C, 0x504FE1  /* 0x0022C0 ...........x..x...lh..OP */
                                                  671:       .pword      0x320014, 0x504FE3, 0x3A0009, 0x2FFFF0, 0x20FFF1, 0x9FBF90, 0x9FBFA1, 0x2FFF72  /* 0x0022D0 ..2.OP..:../.. ......r./ */
                                                  672:       .pword      0x20FFF3, 0x9FB7F2, 0x9FBF83, 0x370011, 0x2FFFF0, 0x200001, 0x9FBF90, 0x9FBFA1  /* 0x0022E0 .. ........7../.. ...... */
                                                  673:       .pword      0x2FFF72, 0x200003, 0x9FB7F2, 0x9FBF83, 0x370008, 0x2FFFF0, 0x200001, 0x9FBF90  /* 0x0022F0 r./.. ........7../.. ... */
                                                  674:       .pword      0x9FBFA1, 0x20FF72, 0x200003, 0x9FB7F2, 0x9FBF83, 0x550FE1, 0x5D8FE0, 0x3E0006  /* 0x002300 ...r. .. ........U..]..> */
                                                  675:       .pword      0x20002A, 0x20000B, 0xBE040A, 0x370007, 0xBE040A, 0x370005, 0x550FE0, 0x5D8FE0  /* 0x002310 *. .. .....7.....7..U..] */
                                                  676:       .pword      0x3AFFFB, 0xBE040A, 0x370029, 0xBE0108, 0x78000C, 0x073B22, 0x97B91F, 0x97B9AF  /* 0x002320 ..:...).7.....x";....... */
                                                  677:       .pword      0x500F82, 0x588F83, 0x32001E, 0x500FE0, 0x588FE0, 0x32001E, 0x97B17F, 0x97B98F  /* 0x002330 ..P..X..2..P..X..2...... */
                                                  678:       .pword      0x500F82, 0x588F83, 0x32000A, 0x440461, 0x4C84E0, 0x90082C, 0x9008BC, 0x400062  /* 0x002340 ..P..X..2a.D..L,.....b.@ */
                                                  679:       .pword      0x4880E0, 0x540F80, 0x5C8F81, 0x310004, 0x370005, 0x200028, 0x200009, 0x370002  /* 0x002350 ..H..T..\..1..7(. .. ..7 */
                                                  680:       .pword      0x200028, 0x200009, 0x540F8A, 0x5C8F8B, 0x320006, 0x540FE0, 0x5C8FE0, 0x3AFFDB  /* 0x002360 (. .. ..T..\..2..T..\..: */
                                                  681:       .pword      0x370003, 0xB84460, 0x370001, 0xB84460, 0xBE0008, 0x78064F, 0xBE054F, 0xBE044F  /* 0x002370 ..7`D...7`D....O.xO..O.. */
                                                  682:       .pword      0xFA8000, 0x060000, 0x4787EA, 0xBE9F88, 0xBE9F8A, 0xBE9F8C, 0x781F8E, 0xBE0400  /* 0x002380 ........G...........x... */
                                                  683:       .pword      0x780682, 0x90686D, 0x504FE1, 0x320014, 0x504FE3, 0x3A0009, 0x2FFF80, 0x20FFF1  /* 0x002390 ..xmh..OP..2.OP..:../..  */
                                                  684:       .pword      0x9FB7D0, 0x9FB7E1, 0x2FFFF2, 0x20FFF3, 0x9FB7F2, 0x9FBF83, 0x370011, 0x2FFF80  /* 0x0023A0 ......../.. ........7../ */
                                                  685:       .pword      0x200001, 0x9FB7D0, 0x9FB7E1, 0x2FFFF2, 0x200003, 0x9FB7F2, 0x9FBF83, 0x370008  /* 0x0023B0 .. ......../.. ........7 */
                                                  686:       .pword      0x20FF80, 0x200001, 0x9FB7D0, 0x9FB7E1, 0x2FFFF2, 0x200003, 0x9FB7F2, 0x9FBF83  /* 0x0023C0 .. .. ......../.. ...... */
                                                  687:       .pword      0x20021C, 0x2000FE, 0x540FE1, 0x5C8FE0, 0x3E0002, 0x370022, 0xBE040A, 0xBE0108  /* 0x0023D0 .. .. ..T..\..>".7...... */
                                                  688:       .pword      0x78000D, 0x073AC6, 0xBE0500, 0x97B07F, 0x97B88F, 0x550F80, 0x5D8F81, 0x320024  /* 0x0023E0 ..x.:............U..]$.2 */
                                                  689:       .pword      0x200012, 0x200003, 0x550F82, 0x5D8F83, 0x360021, 0x78060E, 0x97B05F, 0x97B0EF  /* 0x0023F0 .. .. ..U..]!.6..x_..... */
                                                  690:       .pword      0x500F8A, 0x588F8B, 0x360001, 0xEB0600, 0xEB4080, 0xB82260, 0xBE0108, 0x78000D  /* 0x002400 ..P..X..6....@.`"......x */
                                                  691:       .pword      0x07F198, 0x97B17F, 0x97B98F, 0x500F82, 0x588F83, 0x320012, 0xE0000C, 0x32FFDE  /* 0x002410 ...........P..X..2.....2 */
                                                  692:       .pword      0xB3C011, 0xB82260, 0xB81160, 0x78000D, 0x07F18C, 0x78000C, 0x78074F, 0xBE064F  /* 0x002420 ...`".`....x.....xO.xO.. */
                                                  693:       .pword      0xBE054F, 0xBE044F, 0xB100AF, 0x060000, 0x2000FC, 0x37FFF2, 0x20021C, 0x37FFF0  /* 0x002430 O..O.......... ..7.. ..7 */
                                                  694:       .pword      0x20009C, 0x37FFEE, 0x784200, 0x807900, 0xFB8184, 0x9008D0, 0xDE08C8, 0x6080E3  /* 0x002440 .. ..7.Bx.y............` */
                                                  695:       .pword      0x508F83, 0x3A0006, 0x900090, 0xA39801, 0x3A0003, 0x885410, 0xB3C010, 0x37004F  /* 0x002450 ..P..:........:.T....O.7 */
                                                  696:       .pword      0xEF6A5B, 0x8078F2, 0xEB4000, 0xE00002, 0x32004A, 0x900022, 0xEB0080, 0xE00000  /* 0x002460 [j..x..@....J.2"........ */
                                                  697:       .pword      0x320001, 0x9000A0, 0xEB0280, 0xE00001, 0x320034, 0x900851, 0xDE0048, 0x600063  /* 0x002470 ..2.........4.2Q..H..c.` */
                                                  698:       .pword      0x518F80, 0x3A002C, 0x524FE2, 0x320019, 0x524FE3, 0x320008, 0xE00404, 0x3A0026  /* 0x002480 ..Q,.:.OR..2.OR..2...&.: */
                                                  699:       .pword      0x900011, 0xA39800, 0x3A0023, 0x885411, 0xB3C010, 0x370031, 0x900011, 0xA39800  /* 0x002490 ......#.:.T....1.7...... */
                                                  700:       .pword      0x320006, 0x900031, 0xE00000, 0x3A001A, 0x900021, 0x9800B0, 0x370017, 0x900031  /* 0x0024A0 ..21.......:!.......71.. */
                                                  701:       .pword      0xE00000, 0x3A0014, 0x885411, 0xB3C010, 0x370022, 0x900011, 0xA39800, 0x3A000E  /* 0x0024B0 .....:.T....".7........: */
                                                  702:       .pword      0x900011, 0xA3C800, 0x3A000B, 0xEC6A5B, 0xBFCA5A, 0xE34A5B, 0x360007, 0x20A5B2  /* 0x0024C0 ........:[j.Z..[J...6..  */
                                                  703:       .pword      0x784112, 0x20A5A0, 0x784802, 0x885411, 0xB3C010, 0x370011, 0x780091, 0xE00001  /* 0x0024D0 .Ax.. .Hx.T......7..x... */
                                                  704:       .pword      0x3A0009, 0x780112, 0xE00002, 0x32000A, 0x900022, 0x780085, 0xE00000, 0x32FFC3  /* 0x0024E0 ..:..x.....2"....x.....2 */
                                                  705:       .pword      0x9000A0, 0x37FFC1, 0xE00002, 0x3AFFBF, 0xEB4000, 0x370001, 0xEB4000, 0x060000  /* 0x0024F0 .....7.....:.@...7.@.... */
                                                  706:       .pword      0xFA0042, 0x781F88, 0xEB0080, 0x9FBFE1, 0xEB4100, 0x780080, 0x57806E, 0x07FE07  /* 0x002500 B....x.......A...xn.W... */
                                                  707:       .pword      0x780400, 0xE00008, 0x3A0005, 0xB3C211, 0x807B40, 0x987001, 0xEB8000, 0x370047  /* 0x002510 ..x.....:...@{..p....G.7 */
                                                  708:       .pword      0x97B81F, 0x97B8AF, 0x9FBFC0, 0x9FBFD1, 0x97B83F, 0x9010B0, 0x901040, 0x9000E1  /* 0x002520 ............?.....@..... */
                                                  709:       .pword      0x010001, 0xE00400, 0x320005, 0xB3C1A1, 0x97B83F, 0x987001, 0xEB8000, 0x370037  /* 0x002530 ........2...?...p....7.7 */
                                                  710:       .pword      0xEB4080, 0x780008, 0x07FA3C, 0xE00400, 0x320002, 0x504FE3, 0x3A0005, 0xB3C131  /* 0x002540 .@...x<.......2.OP..:1.. */
                                                  711:       .pword      0x97B83F, 0x987001, 0xEB8000, 0x37002B, 0x504FE1, 0x3A0017, 0x97B81F, 0x97B8AF  /* 0x002550 ?...p....+.7.OP..:...... */
                                                  712:       .pword      0x9FBFC0, 0x9FBFD1, 0xEB0000, 0x9FBFE0, 0x2FFBC1, 0x40808F, 0x780008, 0x070519  /* 0x002560 ............../..@..x... */
                                                  713:       .pword      0x200027, 0xEB0300, 0xEB0280, 0x578264, 0x5781E8, 0x57817D, 0x2FFBC1, 0x40808F  /* 0x002570 '. ......d.W..W}.W../..@ */
                                                  714:       .pword      0x57806E, 0x07F773, 0x780080, 0xE00001, 0x3A000F, 0x97A8DF, 0x9FBF81, 0x200141  /* 0x002580 n.Ws....x.....:......A.  */
                                                  715:       .pword      0x97A86F, 0xA34800, 0x3A0009, 0xB3C012, 0x5780F0, 0x2FFBC0, 0x40000F, 0x07FB84  /* 0x002590 o...H...:.....W../..@... */
                                                  716:       .pword      0x780080, 0xEB0000, 0xE00001, 0x320003, 0x97B83F, 0x987001, 0xEB8000, 0x78044F  /* 0x0025A0 ..x........2?...p....O.x */
                                                  717:       .pword      0xFA8000, 0x060000, 0xBE9F88, 0xBE9F8A, 0x781F8C, 0x784481, 0x784582, 0x780403  /* 0x0025B0 ..............x.Dx.Ex..x */
                                                  718:       .pword      0x784504, 0xB3C561, 0xE00400, 0x34004B, 0x20EC32, 0x104F92, 0x3A0048, 0xE84081  /* 0x0025C0 .Exa.....K.42. .O.H.:.@. */
                                                  719:       .pword      0xB3C200, 0x410163, 0x104F92, 0x3A0043, 0xE84081, 0x410063, 0x14CF90, 0x39003F  /* 0x0025D0 ...c.A.O.C.:.@.c.A...?.9 */
                                                  720:       .pword      0x40C0EC, 0x400073, 0x784801, 0xB80060, 0x8876A0, 0x8876B1, 0xEB4080, 0xE90002  /* 0x0025E0 ..@s.@.Hx`...v..v..@.... */
                                                  721:       .pword      0x784801, 0x400063, 0x784801, 0x65C661, 0x6600E1, 0x780110, 0xA10002, 0x710801  /* 0x0025F0 .Hxc.@.Hxa.e..f..x.....q */
                                                  722:       .pword      0x887675, 0x887686, 0x887697, 0x070E68, 0x8876C0, 0x8876D1, 0x20ECB3, 0xE88103  /* 0x002600 uv..v..v.h...v..v... ... */
                                                  723:       .pword      0x784913, 0xE0040B, 0x3A0002, 0xE80183, 0x784913, 0x253552, 0x243423, 0x887522  /* 0x002610 .Ix.....:....IxR5%#4$"u. */
                                                  724:       .pword      0x887533, 0x887540, 0x887551, 0x807680, 0x807691, 0x887560, 0x887571, 0x20EB00  /* 0x002620 3u.@u.Qu..v..v.`u.qu...  */
                                                  725:       .pword      0xEB4800, 0x6600E1, 0xDD08C7, 0x780110, 0xA17002, 0x710801, 0xE80000, 0x784809  /* 0x002630 .H...f.....x.p...q....Hx */
                                                  726:       .pword      0xE80000, 0x78480A, 0xE0040A, 0x320007, 0xE9408A, 0xFB8081, 0xE80100, 0x410081  /* 0x002640 ....Hx.....2.@.........A */
                                                  727:       .pword      0x786838, 0x500F81, 0x3AFFFD, 0xB3C211, 0x20EC60, 0x784801, 0xEB4080, 0x784001  /* 0x002650 8hx..P..:...`. .Hx.@..@x */
                                                  728:       .pword      0x78064F, 0xBE054F, 0xBE044F, 0x060000, 0x4787F4, 0xBE9F88, 0xBE9F8A, 0xBE9F8C  /* 0x002660 O.xO..O.......G......... */
                                                  729:       .pword      0x781F8E, 0x780500, 0xBE0402, 0x780581, 0xEB4000, 0xE0041A, 0x320049, 0x510FE0  /* 0x002670 ..x..x.....x.@....I.2..Q */
                                                  730:       .pword      0x598FE0, 0x32000D, 0xDE4E48, 0x20000D, 0xDE4840, 0x200001, 0x784680, 0xDD4948  /* 0x002680 ..Y..2HN... @H... .FxHI. */
                                                  731:       .pword      0xDE4048, 0x710000, 0xDE48C8, 0x784700, 0xB3C050, 0x9FF780, 0x370004, 0xEB4000  /* 0x002690 H@...q.H..GxP.......7.@. */
                                                  732:       .pword      0xE00404, 0x3AFFF0, 0x370035, 0xB3C2A0, 0x9FE7C0, 0xEB4000, 0x9FE7D0, 0x9FE7EC  /* 0x0026A0 .....:5.7.......@....... */
                                                  733:       .pword      0x9FE7FD, 0x9FEF8E, 0x9FEF98, 0x9FEFA0, 0x9FEFB0, 0xB3C011, 0x9FEFC1, 0x9FEFD0  /* 0x0026B0 ........................ */
                                                  734:       .pword      0x8052A6, 0xEB0380, 0x78028B, 0xB3C0A4, 0x5781FC, 0x784100, 0x784082, 0x78401A  /* 0x0026C0 .R......x.....W.Ax.@x.@x */
                                                  735:       .pword      0x07FF71, 0x9FEFE0, 0xE00400, 0x320003, 0x370009, 0x072CBC, 0x0730DF, 0x2FFE02  /* 0x0026D0 q..........2..7.,..0.../ */
                                                  736:       .pword      0x41010F, 0x5780F2, 0x78401A, 0x07091E, 0xE00400, 0x32FFF7, 0x97E86F, 0xE00400  /* 0x0026E0 ..A..W.@x........2o..... */
                                                  737:       .pword      0x320004, 0xB3C511, 0x504F81, 0x3A000B, 0x370002, 0xB3C010, 0x370009, 0x78000A  /* 0x0026F0 ..2....OP..:..7.....7..x */
                                                  738:       .pword      0x070750, 0x97F10F, 0xE94102, 0x9FF782, 0x3AFFCE, 0xEB4000, 0x370001, 0xEB4000  /* 0x002700 P......A......:.@...7.@. */
                                                  739:       .pword      0x78074F, 0xBE064F, 0xBE054F, 0xBE044F, 0xB1014F, 0x060000, 0xFA0016, 0xBE9F88  /* 0x002710 O.xO..O..O..O........... */
                                                  740:       .pword      0xBE9F8A, 0x781F8C, 0x780482, 0x780503, 0x780404, 0x2ABF82, 0x200003, 0x9FB782  /* 0x002720 .....x..x..x..x..*.. ... */
                                                  741:       .pword      0x9FB793, 0x97B10F, 0x97B19F, 0x9FBF92, 0x9FBFA3, 0xE00008, 0x3A0001, 0x57847C  /* 0x002730 ....................:|.W */
                                                  742:       .pword      0xEB0600, 0xEB0580, 0x780288, 0x78020B, 0x78018A, 0x780109, 0x022C42, 0x000000  /* 0x002740 ........x..x..x..xB,.... */
                                                  743:       .pword      0xE00000, 0x320036, 0xBE0218, 0x200082, 0x200003, 0x2021C0, 0x200001, 0x023BEE  /* 0x002750 ...6.2..... .. .! .. .;. */
                                                  744:       .pword      0x000000, 0xE00000, 0x3A001E, 0xBE0218, 0x97B81F, 0x97B8AF, 0x500FE0, 0x588FE0  /* 0x002760 ........:...........P..X */
                                                  745:       .pword      0x32000F, 0xBE0004, 0x97B91F, 0x97B9AF, 0x520F82, 0x5A8F83, 0x390009, 0xE0000B  /* 0x002770 ..2...........R..Z..9... */
                                                  746:       .pword      0x3A001C, 0x904128, 0x20009B, 0xE00402, 0x350001, 0x20004B, 0x9004A8, 0x37FFDA  /* 0x002780 ..:(A... .....5K. .....7 */
                                                  747:       .pword      0x2000C2, 0x200003, 0x202080, 0x200001, 0x023BEE, 0x000000, 0xE00000, 0x32000F  /* 0x002790 .. .. .  .. .;.........2 */
                                                  748:       .pword      0x20001C, 0x550FE3, 0x36000D, 0x900128, 0x550502, 0x550563, 0x44850A, 0x200024  /* 0x0027A0 .. ..U..6(....Uc.U..D$.  */
                                                  749:       .pword      0x200005, 0x420038, 0x4A80A8, 0x4104E3, 0x37FFC5, 0x2FFFCC, 0x370001, 0xEB8600  /* 0x0027B0 .. 8.B..J..A..7../..7... */
                                                  750:       .pword      0x78000C, 0x78064F, 0xBE054F, 0xBE044F, 0xFA8000, 0x060000, 0xFA003C, 0xBE9F88  /* 0x0027C0 ..xO.xO..O........<..... */
                                                  751:       .pword      0x780480, 0x780401, 0xEB4080, 0x780008, 0x07F8F2, 0xE00400, 0x3A0005, 0x900029  /* 0x0027D0 ..x..x.@...x........:).. */
                                                  752:       .pword      0xB3C131, 0x987001, 0xEB8000, 0x370043, 0x504FE1, 0x3A0019, 0xBE0019, 0x9FA790  /* 0x0027E0 1...p....C.7.OP..:...... */
                                                  753:       .pword      0x9FA7A1, 0xEB0000, 0x9FA7B0, 0x2FFC81, 0x40808F, 0x780008, 0x0703D2, 0x200027  /* 0x0027F0 .........../..@..x...'.  */
                                                  754:       .pword      0x2003F6, 0xEB0280, 0x2FFC64, 0x42020F, 0x2FFC23, 0x41818F, 0x578171, 0x2FFC81  /* 0x002800 .. ...d./..B#./..Aq.W../ */
                                                  755:       .pword      0x40808F, 0x780009, 0x07F62A, 0xE00000, 0x320026, 0xEB8000, 0x370028, 0x504FE3  /* 0x002810 ..@..x*.....&.2...(.7.OP */
                                                  756:       .pword      0x3A001D, 0x904118, 0xEB0000, 0xB3C2E1, 0x514F81, 0x3A0021, 0xBE0019, 0x9FA790  /* 0x002820 ..:.A........OQ!.:...... */
                                                  757:       .pword      0x9FA7A1, 0xEB0000, 0x9FA7B0, 0x200014, 0x2FFC63, 0x41818F, 0x2FFC22, 0x41010F  /* 0x002830 ........... c./..A"./..A */
                                                  758:       .pword      0x2FFC01, 0x40808F, 0x780009, 0x07F6A0, 0x780080, 0xEB8000, 0x97A10F, 0xE00002  /* 0x002840 ../..@..x.....x......... */
                                                  759:       .pword      0x3A000E, 0x780001, 0x073BCC, 0xBE8C80, 0xEB0000, 0x370009, 0x900029, 0xB3C131  /* 0x002850 ..:..x.;.........7)..1.. */
                                                  760:       .pword      0x987001, 0xEB8000, 0x370004, 0x97A80F, 0x97A89F, 0xBE8C80, 0xEB0000, 0xBE044F  /* 0x002860 .p......7............O.. */
                                                  761:       .pword      0xFA8000, 0x060000, 0x4787EC, 0xBE9F88, 0xBE9F8A, 0xBE9F8C, 0x781F8E, 0x784680  /* 0x002870 ........G...........x.Fx */
                                                  762:       .pword      0x784701, 0x9FF782, 0x780603, 0x8053DB, 0x20F249, 0xEB0400, 0x780509, 0xDD4043  /* 0x002880 .Gx.....x.S.I. .....xC@. */
                                                  763:       .pword      0x400066, 0x78006A, 0xA31800, 0x320037, 0xDD4043, 0x400066, 0x78006A, 0xA35800  /* 0x002890 f.@j.x...7.2C@.f.@j.x.X. */
                                                  764:       .pword      0x3A0002, 0x16CF99, 0x3A0030, 0xDD4043, 0x400066, 0x78006A, 0xA34800, 0x3A0003  /* 0x0028A0 ..:...0.:C@.f.@j.x.H...: */
                                                  765:       .pword      0x904019, 0x504F8E, 0x3A0028, 0xDD4043, 0x400066, 0x78006A, 0xA33800, 0x3A0004  /* 0x0028B0 .@..OP(.:C@.f.@j.x.8...: */
                                                  766:       .pword      0x904029, 0x97F08F, 0x504F81, 0x3A001F, 0x90480B, 0xFB8000, 0x90489B, 0xDD08C8  /* 0x0028C0 )@.....OP..:.H.....H.... */
                                                  767:       .pword      0x708080, 0x9FB7C1, 0x9048AB, 0xFB8081, 0x90483B, 0xDD0048, 0x708000, 0x9FB7D0  /* 0x0028D0 ..p....H....;H.H....p... */
                                                  768:       .pword      0x9FEFCD, 0x9FEFDE, 0x97F00F, 0x9FEFE0, 0x200084, 0x200005, 0x578178, 0x200791  /* 0x0028E0 .............. .. x.W..  */
                                                  769:       .pword      0xEBC000, 0x070A52, 0xE00400, 0x3A0007, 0xDD4443, 0x20F280, 0x440000, 0x904010  /* 0x0028F0 ...R.......:CD... ..D.@. */
                                                  770:       .pword      0x784E00, 0xB3C010, 0x370005, 0xE80408, 0x4484E8, 0x540FE2, 0x3AFFC0, 0xEB4000  /* 0x002900 .Nx.....7.....D..T..:.@. */
                                                  771:       .pword      0x78074F, 0xBE064F, 0xBE054F, 0xBE044F, 0xB100CF, 0x060000, 0xBE9F88, 0xBE9F8A  /* 0x002910 O.xO..O..O.............. */
                                                  772:       .pword      0x784580, 0x780501, 0x780482, 0x78400B, 0x070C82, 0x780400, 0xE00008, 0x3A0009  /* 0x002920 .Ex..x..x.@x.....x.....: */
                                                  773:       .pword      0x200230, 0xE24A74, 0x32003E, 0xEF6A74, 0x20F0F0, 0x78480B, 0x88782A, 0x2FFCF8  /* 0x002930 0. tJ.>.2tj... .Hx*x.../ */
                                                  774:       .pword      0x440400, 0x901028, 0x9000D0, 0x508F88, 0x3A0002, 0xEB0080, 0x980051, 0x780008  /* 0x002940 ..D(.......P..:...Q....x */
                                                  775:       .pword      0x0708C6, 0x780080, 0x200090, 0xE00001, 0x3A002C, 0x981449, 0x78009A, 0xE00001  /* 0x002950 .....x.. ...,.:I....x... */
                                                  776:       .pword      0x320002, 0x780009, 0x010001, 0x9000AA, 0x780009, 0x010001, 0x780080, 0x200060  /* 0x002960 ..2..x........x.....x`.  */
                                                  777:       .pword      0xE00011, 0x3A001A, 0x900011, 0xA30800, 0x32001F, 0x900121, 0xEB0180, 0x980C42  /* 0x002970 .....:........2!.....B.. */
                                                  778:       .pword      0x980C53, 0x9000A1, 0x202000, 0x508F80, 0x360017, 0x200240, 0x37000D, 0x780008  /* 0x002980 S......  ..P..6@. ..7..x */
                                                  779:       .pword      0x073A2E, 0xE00000, 0x3A0009, 0x807B41, 0xE00001, 0x3A000B, 0x887B48, 0x900168  /* 0x002990 .:......:A{......:H{.h.. */
                                                  780:       .pword      0x9001F8, 0x887B22, 0x887B33, 0x370005, 0x20F0F1, 0xEB4880, 0xB3C012, 0x20A743  /* 0x0029A0 ..."{.3{...7.. .H....C.  */
                                                  781:       .pword      0x784982, 0xBE054F, 0xBE044F, 0x060000, 0x780008, 0x07F87E, 0xE00000, 0x3AFFF4  /* 0x0029B0 .IxO..O.......x~.......: */
                                                  782:       .pword      0x37FFE6, 0xFA000A, 0xBE9F88, 0xBE9F8A, 0xBE9F8C, 0x980730, 0x98074F, 0x2000C0  /* 0x0029C0 ..7............0..O....  */
                                                  783:       .pword      0x200001, 0x02435A, 0x000000, 0xBE0200, 0x780580, 0xE88080, 0xA10001, 0x478781  /* 0x0029D0 .. ZC.........x........G */
                                                  784:       .pword      0x90054E, 0xEB0080, 0x202242, 0x200003, 0x78000A, 0x023A96, 0x000000, 0x370033  /* 0x0029E0 N.....B" .. ..x.:....3.7 */
                                                  785:       .pword      0xEB4000, 0x984750, 0x78000A, 0x7840B0, 0x984721, 0x7840B0, 0x984731, 0x784010  /* 0x0029F0 .@.PG...x.@x!G..@x1G..@x */
                                                  786:       .pword      0x984740, 0x450063, 0x784F10, 0x90404A, 0x984710, 0x90402A, 0x404FE8, 0x320004  /* 0x002A00 @G.c.E.OxJ@..G.*@..O@..2 */
                                                  787:       .pword      0x200014, 0xE00400, 0x3D0005, 0x370001, 0x200084, 0x90003E, 0xE00000, 0x320016  /* 0x002A10 .. .....=..7.. >.......2 */
                                                  788:       .pword      0x78061E, 0x4506E6, 0x90041E, 0x9004AE, 0xEB0280, 0x78018C, 0x78010D, 0xBE0008  /* 0x002A20 ..x..E...........x..x... */
                                                  789:       .pword      0x022C42, 0x000000, 0xE00000, 0x32000A, 0x203DF0, 0x8854D0, 0xEB0300, 0x2DEAD5  /* 0x002A30 B,.........2.= .T......- */
                                                  790:       .pword      0xEB0200, 0x78018C, 0x78010D, 0xBE0008, 0x0231B2, 0x000000, 0x78001E, 0x558580  /* 0x002A40 .....x..x....1......x..U */
                                                  791:       .pword      0x5585E6, 0x400066, 0x450500, 0x558FE6, 0x3EFFCB, 0xEF2A9A, 0x9007CE, 0xBE064F  /* 0x002A50 ..Uf.@..E..U..>.*....O.. */
                                                  792:       .pword      0xBE054F, 0xBE044F, 0xFA8000, 0x060000, 0x4787F4, 0xBE9F88, 0xBE9F8A, 0xBE9F8C  /* 0x002A60 O..O..........G......... */
                                                  793:       .pword      0x781F8E, 0x780500, 0xBE0402, 0x780581, 0xEB4000, 0xE0041A, 0x320040, 0xDE1E48  /* 0x002A70 ..x..x.....x.@....@.2H.. */
                                                  794:       .pword      0x20000D, 0xDE1840, 0x200001, 0x784680, 0xDD4948, 0xDE4048, 0x710000, 0xDE48C8  /* 0x002A80 .. @.... .FxHI.H@...q.H. */
                                                  795:       .pword      0x784700, 0xB3C050, 0x9FF780, 0xB3C280, 0x9FE7C0, 0xEB4000, 0x9FE7D0, 0x9FE7EC  /* 0x002A90 .GxP............@....... */
                                                  796:       .pword      0x9FE7FD, 0x9FEF8E, 0x9FEF98, 0x9FEFA0, 0x9FEFB0, 0xB3C012, 0x9FEFC2, 0x9FEFD0  /* 0x002AA0 ........................ */
                                                  797:       .pword      0x8052A6, 0xEB0380, 0x78028B, 0xB3C0A4, 0x5781FC, 0x784080, 0x78401A, 0x07FD7A  /* 0x002AB0 .R......x.....W.@x.@xz.. */
                                                  798:       .pword      0x9FEFE0, 0xE00400, 0x320003, 0x370009, 0x072AC5, 0x072EE8, 0x2FFE02, 0x41010F  /* 0x002AC0 ........2..7.*....../..A */
                                                  799:       .pword      0x5780F2, 0x78401A, 0x070727, 0xE00400, 0x32FFF7, 0x97E86F, 0xE00400, 0x320004  /* 0x002AD0 ..W.@x'.......2o.......2 */
                                                  800:       .pword      0xB3C511, 0x504F81, 0x3A000B, 0x370002, 0xB3C010, 0x370009, 0x78000A, 0x070559  /* 0x002AE0 ....OP..:..7.....7..xY.. */
                                                  801:       .pword      0x97F10F, 0xE94102, 0x9FF782, 0x3AFFCF, 0xEB4000, 0x370001, 0xEB4000, 0x78074F  /* 0x002AF0 ....A......:.@...7.@.O.x */
                                                  802:       .pword      0xBE064F, 0xBE054F, 0xBE044F, 0xB1014F, 0x060000, 0xFA0008, 0xBE9F88, 0xBE9F8A  /* 0x002B00 O..O..O..O.............. */
                                                  803:       .pword      0xBE9F8C, 0x780500, 0xBE0402, 0x900DCA, 0x90686B, 0x504FE1, 0x320014, 0x504FE3  /* 0x002B10 .....x......kh..OP..2.OP */
                                                  804:       .pword      0x3A0009, 0x2FFF80, 0x20FFF1, 0x9FB7E0, 0x9FB7F1, 0x2FFFF4, 0x20FFF5, 0x9FBF84  /* 0x002B20 ..:../.. ......../.. ... */
                                                  805:       .pword      0x9FBF95, 0x370011, 0x2FFF80, 0x200001, 0x9FB7E0, 0x9FB7F1, 0x2FFFF4, 0x200005  /* 0x002B30 .....7../.. ......../..  */
                                                  806:       .pword      0x9FBF84, 0x9FBF95, 0x370008, 0x20FF80, 0x200001, 0x9FB7E0, 0x9FB7F1, 0x2FFFF4  /* 0x002B40 ........7.. .. ......../ */
                                                  807:       .pword      0x200005, 0x9FBF84, 0x9FBF95, 0x20008C, 0x20026D, 0x90016A, 0x9001FA, 0x78000B  /* 0x002B50 .. ........ m. j.......x */
                                                  808:       .pword      0x073707, 0x78010C, 0x97BA0F, 0x97BA9F, 0x500F84, 0x588F85, 0x32000F, 0x900A2B  /* 0x002B60 .7...x........P..X..2+.. */
                                                  809:       .pword      0x900ABB, 0x420262, 0x4A82E0, 0x2000A2, 0x500F84, 0x588F85, 0x310001, 0xEB0100  /* 0x002B70 ...b.B..J.. ..P..X..1... */
                                                  810:       .pword      0x97B26F, 0x97B2FF, 0x500F84, 0x588F85, 0x390001, 0x78010D, 0x980560, 0x980571  /* 0x002B80 o.......P..X..9..x`..q.. */
                                                  811:       .pword      0x540461, 0x5C84E0, 0x320002, 0xE00002, 0x32FFE0, 0x780002, 0xBE064F, 0xBE054F  /* 0x002B90 a.T..\..2.....2..xO..O.. */
                                                  812:       .pword      0xBE044F, 0xFA8000, 0x060000, 0xBE9F88, 0xBE9F8A, 0x781F8C, 0x901020, 0x900550  /* 0x002BA0 O................x ..P.. */
                                                  813:       .pword      0xB3C010, 0xE0000A, 0x320041, 0xE00001, 0x320004, 0xB3C010, 0x508FE1, 0x3A003C  /* 0x002BB0 ......A.2.....2.....P<.: */
                                                  814:       .pword      0x370016, 0x90112A, 0x9000C2, 0xB3C010, 0xA30801, 0x320036, 0x9011BA, 0x90108A  /* 0x002BC0 ..7*...........6.2...... */
                                                  815:       .pword      0x90104A, 0x9002D3, 0xEB4200, 0xBE0112, 0x010005, 0x784080, 0xEB4000, 0xE00401  /* 0x002BD0 J......B........@x.@.... */
                                                  816:       .pword      0x32002B, 0x90102A, 0x9000C0, 0xA10001, 0x980041, 0xB3C010, 0x370025, 0x9010AA  /* 0x002BE0 +.2*........A.....%.7... */
                                                  817:       .pword      0x900141, 0xB3C010, 0xA31802, 0x320020, 0x900421, 0x9004B1, 0x90684A, 0xE00400  /* 0x002BF0 A........ .2!.....Jh.... */
                                                  818:       .pword      0x320014, 0xEB4580, 0x78460B, 0x90113A, 0x90109A, 0x90104A, 0x9002D2, 0x78420C  /* 0x002C00 ..2.E..Fx:.....J......Bx */
                                                  819:       .pword      0xBE0108, 0x010005, 0xE00400, 0x32000F, 0xE8458B, 0x90096A, 0x9009FA, 0x90684A  /* 0x002C10 ...........2.E.j.....Jh. */
                                                  820:       .pword      0x504F8B, 0x360003, 0x410408, 0x498489, 0x37FFEE, 0x90102A, 0x9000C0, 0xA11001  /* 0x002C20 .OP..6..A..I..7*........ */
                                                  821:       .pword      0x980041, 0xB3C010, 0x370001, 0xEB4000, 0x78064F, 0xBE054F, 0xBE044F, 0x060000  /* 0x002C30 A.......7.@.O.xO..O..... */
                                                  822:       .pword      0xB82260, 0xBE9F88, 0xBE9F8A, 0xF80032, 0xE00005, 0xAF2042, 0x78028F, 0x4282E4  /* 0x002C40 `".......2.....B ...x..B */
                                                  823:       .pword      0xA37801, 0x3A0006, 0xA3D804, 0x320002, 0xAF4761, 0xA26001, 0xA7C004, 0xA06001  /* 0x002C50 .x...:.....2aG..`.....`. */
                                                  824:       .pword      0x880191, 0xEB0080, 0xAFE761, 0x37FFFE, 0x370003, 0xE88000, 0xAF0042, 0xEC2032  /* 0x002C60 ......a....7..7...B..2 . */
                                                  825:       .pword      0xE90183, 0x390029, 0x781A82, 0x2000D1, 0x2FFFF6, 0x200FF7, 0x784332, 0xE90183  /* 0x002C70 ...).9..x.. ../.. 2Cx... */
                                                  826:       .pword      0x390005, 0x7848B2, 0xE90183, 0x390003, 0x7843B2, 0x370002, 0xA03004, 0xA02004  /* 0x002C80 ..9.Hx.....9.Cx..7.0.. . */
                                                  827:       .pword      0xBA0410, 0xBA8490, 0xBE9A88, 0xBE9A86, 0x620FE3, 0x32000B, 0xEA8306, 0xEAC387  /* 0x002C90 ..............b..2...... */
                                                  828:       .pword      0x630508, 0x638589, 0xA70004, 0xBE030A, 0x730508, 0x738589, 0xA71004, 0xBE030A  /* 0x002CA0 ..c..c........s..s...... */
                                                  829:       .pword      0xB84460, 0x530308, 0x5B8389, 0x620FEC, 0x320003, 0xEB0380, 0xA73004, 0xB20FF6  /* 0x002CB0 `D...S..[..b..2....0.... */
                                                  830:       .pword      0x5282EA, 0x730087, 0x32FFD2, 0x800196, 0x782286, 0x782280, 0x780001, 0xF90032  /* 0x002CC0 ..R..s..2...."x."x..x2.. */
                                                  831:       .pword      0xBE054F, 0xBE044F, 0x060000, 0xFA0014, 0x781F88, 0xEB0080, 0x9FBFE1, 0xEB4100  /* 0x002CD0 O..O..........x.......A. */
                                                  832:       .pword      0x780080, 0x578074, 0x07FA1C, 0x780400, 0x97B06F, 0x97B0FF, 0x9FBF90, 0x9FBFA1  /* 0x002CE0 ..xt.W.....xo........... */
                                                  833:       .pword      0x97B88F, 0x9FBFB1, 0xEB8000, 0xE00008, 0x320034, 0x780001, 0x9010B0, 0x901040  /* 0x002CF0 ............4.2..x...@.. */
                                                  834:       .pword      0x9000E1, 0x010001, 0x784080, 0xEB8000, 0xE00401, 0x3A002B, 0x780008, 0x07EBE7  /* 0x002D00 .......@x......+.:..x... */
                                                  835:       .pword      0xE00000, 0x320007, 0x780088, 0x57806E, 0x07FD59, 0x780080, 0xEB8000, 0xE00001  /* 0x002D10 .....2..xn.WY....x...... */
                                                  836:       .pword      0x3A0020, 0x97B91F, 0x97B9AF, 0x97B83F, 0x900260, 0x9002F0, 0xEB8000, 0x510F84  /* 0x002D20  .:......?..`..........Q */
                                                  837:       .pword      0x598F85, 0x320017, 0x9FBFC2, 0x9FBFD3, 0x200024, 0x5781E4, 0x578168, 0x5780F6  /* 0x002D30 ..Y..2......$. ..Wh.W..W */
                                                  838:       .pword      0x57806E, 0x07F422, 0xE00000, 0x32000A, 0x784010, 0xE00400, 0x320003, 0x404FFB  /* 0x002D40 n.W".......2.@x.....2.O@ */
                                                  839:       .pword      0x32FFF3, 0x370006, 0x780088, 0x578074, 0x0702AA, 0x370003, 0xEB8000, 0x370001  /* 0x002D50 ..2..7..xt.W.....7.....7 */
                                                  840:       .pword      0xEB8000, 0x78044F, 0xFA8000, 0x060000, 0xBE9F88, 0x781F8A, 0xFB8000, 0x2003A2  /* 0x002D60 ...O.x...........x.....  */
                                                  841:       .pword      0xB98102, 0x200241, 0x408082, 0x20EA42, 0x7880E2, 0xA31801, 0x320006, 0x2003A9  /* 0x002D70 ...A. ..@B. ..x.....2..  */
                                                  842:       .pword      0xB98009, 0xB3C303, 0xB00222, 0x787103, 0x370035, 0x2003A2, 0xB98102, 0x200241  /* 0x002D80 ......"...qx5.7.. ...A.  */
                                                  843:       .pword      0x408082, 0x20EA42, 0x7880E2, 0xA32801, 0x320006, 0x2003A1, 0xB98001, 0xB3C403  /* 0x002D90 ..@B. ..x.(...2.. ...... */
                                                  844:       .pword      0xB00222, 0x787103, 0x370027, 0x2003A2, 0xB98102, 0x200241, 0x408082, 0x20EA42  /* 0x002DA0 "...qx'.7.. ...A. ..@B.  */
                                                  845:       .pword      0x7880E2, 0xA33801, 0x320006, 0x2003A1, 0xB98001, 0xB3C503, 0xB00222, 0x787103  /* 0x002DB0 ..x.8...2.. ......"...qx */
                                                  846:       .pword      0x370019, 0x2003A9, 0xB98009, 0x780480, 0x44847E, 0x20EA4A, 0x450408, 0x904018  /* 0x002DC0 ..7.. .....x~.DJ. ..E.@. */
                                                  847:       .pword      0xB82260, 0xEB0100, 0x201F61, 0x807A93, 0x010003, 0x450009, 0x9060F0, 0x904018  /* 0x002DD0 `"....a. .z......E.`..@. */
                                                  848:       .pword      0x070990, 0x200280, 0x400009, 0x7840EA, 0x904018, 0x07098B, 0x450509, 0x20EC60  /* 0x002DE0 ..... ..@.@x.@......E`.  */
                                                  849:       .pword      0x90653A, 0x7CF00A, 0x78054F, 0xBE044F, 0x060000, 0xBE9F88, 0xBE9F8A, 0xBE9F8C  /* 0x002DF0 :e...|O.xO.............. */
                                                  850:       .pword      0x780500, 0xBE0402, 0xBE0604, 0x780581, 0x90094A, 0x90100A, 0xEB0080, 0x07EB60  /* 0x002E00 ..x........xJ........`.. */
                                                  851:       .pword      0x90100A, 0x200201, 0x09000A, 0x785801, 0xB100B0, 0xB3C2E4, 0x784804, 0xB3C101  /* 0x002E10 ..... ....Xx.......Hx... */
                                                  852:       .pword      0x984831, 0xEB4080, 0x984841, 0x980858, 0x200002, 0x20FFF3, 0x780083, 0x608309  /* 0x002E20 1H..@.AH.X.... .. ..x..` */
                                                  853:       .pword      0xEB0380, 0xDD33C0, 0x200006, 0x980827, 0xB83360, 0x980866, 0x980877, 0x9043CB  /* 0x002E30 ....3... '..`3.f..w...C. */
                                                  854:       .pword      0x984857, 0x90029B, 0x980075, 0x90059B, 0x98080B, 0x980812, 0x980832, 0x980842  /* 0x002E40 WH....u...........2..B.. */
                                                  855:       .pword      0x90100A, 0x200206, 0x400306, 0x09001F, 0x785B30, 0xB10200, 0x90100A, 0x986014  /* 0x002E50 ..... ..@...0[x.......`. */
                                                  856:       .pword      0x98185C, 0x60808D, 0x981821, 0xBE0108, 0x78000A, 0x0705A8, 0xBE0100, 0x9010AA  /* 0x002E60 \....`!.......x......... */
                                                  857:       .pword      0x900041, 0xA00000, 0x9800C0, 0x9010AA, 0xBE8882, 0xEB0080, 0x78000A, 0x07FE93  /* 0x002E70 A...................x... */
                                                  858:       .pword      0xFB8000, 0xBE064F, 0xBE054F, 0xBE044F, 0x060000, 0xBE9F88, 0xBE9F8A, 0x781F8C  /* 0x002E80 ...O..O..O.............x */
                                                  859:       .pword      0x780580, 0x900D4B, 0x200022, 0x200003, 0x78000A, 0x07FA12, 0xBE0400, 0x20017C  /* 0x002E90 ..xK..". .. ..x......|.  */
                                                  860:       .pword      0x500FE0, 0x588FE0, 0x320025, 0x90686A, 0x504FE1, 0x3A000A, 0xEB4080, 0x20FF84  /* 0x002EA0 ..P..X%.2jh..OP..:.@...  */
                                                  861:       .pword      0x200005, 0xBE0108, 0x78000A, 0x07EC45, 0x400FE1, 0x588FE0, 0x3A0029, 0x370017  /* 0x002EB0 .. .....xE....@..X).:..7 */
                                                  862:       .pword      0x504FE2, 0x3A000A, 0xEB4080, 0x2FFF84, 0x200005, 0xBE0108, 0x78000A, 0x07EC39  /* 0x002EC0 .OP..:.@.../.. .....x9.. */
                                                  863:       .pword      0x400FE1, 0x588FE0, 0x3A001D, 0x37000B, 0xEB4080, 0x2FFF84, 0x20FFF5, 0xBE0108  /* 0x002ED0 ..@..X..:..7.@.../.. ... */
                                                  864:       .pword      0x78000A, 0x07EC2F, 0x2FFFF2, 0x20FFF3, 0x500F82, 0x588F83, 0x3A0011, 0x20009C  /* 0x002EE0 ..x/..../.. ..P..X..:..  */
                                                  865:       .pword      0x200011, 0x78000A, 0x07FE58, 0xE00400, 0x3A0001, 0x20009C, 0x9805C8, 0x9805D9  /* 0x002EF0 .. ..xX.......:.. ...... */
                                                  866:       .pword      0x9805E8, 0x9805F9, 0x98750C, 0xBE0008, 0x78064F, 0xBE054F, 0xBE044F, 0x060000  /* 0x002F00 .......u....O.xO..O..... */
                                                  867:       .pword      0xBE0108, 0x78000A, 0x070088, 0x780600, 0x37FFEB, 0xFA0004, 0xBE9F88, 0xBE9F8A  /* 0x002F10 .....x.....x..7......... */
                                                  868:       .pword      0xBE9F8C, 0x784580, 0x780481, 0x780502, 0x780683, 0x200720, 0x548F80, 0x320003  /* 0x002F20 ....Ex..x..x..x . ..T..2 */
                                                  869:       .pword      0x27FFF0, 0x548F80, 0x3A000E, 0x90481A, 0x404FE1, 0x32002E, 0xB3C0A2, 0xBC4004  /* 0x002F30 ..'..T..:.H..O@..2....@. */
                                                  870:       .pword      0xE88002, 0x20F5A1, 0x7801E1, 0xB86A61, 0x78010A, 0x780089, 0x78400B, 0x010003  /* 0x002F40 ..... ..xaj...x..x.@x... */
                                                  871:       .pword      0x370023, 0x8078F8, 0xE00008, 0x320012, 0x20F5AC, 0xB86861, 0x9FBF80, 0x9FBF91  /* 0x002F50 #.7.x......2.. ah....... */
                                                  872:       .pword      0x904078, 0xB3C0A2, 0xBC4004, 0xE88102, 0x7901EC, 0x97BA0F, 0x97BA9F, 0x78010A  /* 0x002F60 x@.....@......y........x */
                                                  873:       .pword      0x780089, 0x78400B, 0x010003, 0x780418, 0xE00008, 0x3AFFF2, 0x807910, 0xA37800  /* 0x002F70 ..x.@x.....x.....:.y..x. */
                                                  874:       .pword      0x32000B, 0x20F180, 0xFB8010, 0xB9006A, 0xE88000, 0x20F5A1, 0x7801E1, 0xB86A61  /* 0x002F80 ..2.. ...j....... ..xaj. */
                                                  875:       .pword      0x78010A, 0x780089, 0x78400B, 0x010003, 0xBE064F, 0xBE054F, 0xBE044F, 0xFA8000  /* 0x002F90 ..x..x.@x...O..O..O..... */
                                                  876:       .pword      0x060000, 0x7841B0, 0xB3C2E2, 0x51CF82, 0x3A0006, 0xEB4100, 0x37001B, 0xEB4100  /* 0x002FA0 ....Ax.....Q..:.A...7.A. */
                                                  877:       .pword      0x370019, 0xEB4100, 0x370017, 0xE00403, 0x32FFFA, 0xB3C2F2, 0x51CF82, 0x32FFF9  /* 0x002FB0 ..7.A...7.....2.....Q..2 */
                                                  878:       .pword      0x780200, 0xEB4100, 0xB3C2E5, 0xB3C2F6, 0xFB8002, 0x408000, 0x986073, 0xE84102  /* 0x002FC0 ..x.A............@s`..A. */
                                                  879:       .pword      0x7841B4, 0x780004, 0x51CF85, 0x320004, 0xE00403, 0x320002, 0x51CF86, 0x3AFFF4  /* 0x002FD0 .Ax..x..Q..2.....2..Q..: */
                                                  880:       .pword      0x514FE7, 0x3E0007, 0xB3C205, 0xFB8202, 0x408204, 0x986275, 0xE84102, 0x514FE7  /* 0x002FE0 .OQ..>........@ub..A..OQ */
                                                  881:       .pword      0x36FFFA, 0xB3C2E4, 0x51CF84, 0x3A0003, 0x784190, 0xE00403, 0x3A0004, 0xB3C203  /* 0x002FF0 ..6.....Q..:.Ax.....:... */
                                                  882:       .pword      0x514FEA, 0x36000A, 0x37000F, 0xE80000, 0xFB8202, 0x408204, 0x986273, 0xE84102  /* 0x003000 .OQ..6..7........@sb..A. */
                                                  883:       .pword      0x7841B0, 0xE00403, 0x3AFFF9, 0x37FFF3, 0xFB8002, 0x408000, 0x986073, 0xE84102  /* 0x003010 .Ax.....:..7.....@s`..A. */
                                                  884:       .pword      0x514FEB, 0x3AFFFA, 0x060000, 0xBE9F88, 0xBE9F8A, 0xBE9F8C, 0x781F8E, 0x780500  /* 0x003020 .OQ..:..............x..x */
                                                  885:       .pword      0x78000A, 0x0704C4, 0xBE0400, 0xEB0080, 0x78000A, 0x07FDB5, 0xE00400, 0x3A0004  /* 0x003030 ..x...........x........: */
                                                  886:       .pword      0xB3C090, 0x987500, 0x200090, 0x37002C, 0x90094A, 0x90100A, 0xEB0080, 0x07EA40  /* 0x003040 ....u... ,.7J........@.. */
                                                  887:       .pword      0x9068DA, 0xE00401, 0x320019, 0xBE0108, 0x20009B, 0xEB0700, 0x370001, 0xBE010C  /* 0x003050 .h......2..... .....7... */
                                                  888:       .pword      0x410661, 0x4986E0, 0x90123A, 0x90108A, 0x90104A, 0x9002D4, 0xEB4200, 0x010005  /* 0x003060 a.A..I:.....J......B.... */
                                                  889:       .pword      0x784080, 0x78000B, 0xE00401, 0x320001, 0x78000E, 0x9068DA, 0x564108, 0x50CF82  /* 0x003070 .@x..x.....2..x.h..AV..P */
                                                  890:       .pword      0x360005, 0xE00000, 0x32FFEC, 0x370002, 0xBE0608, 0xEB0000, 0x90112A, 0xFB8201  /* 0x003080 ..6.....2..7......*..... */
                                                  891:       .pword      0xEB0280, 0x561904, 0x5E9105, 0x9010AA, 0x900141, 0xA10002, 0x9800C2, 0x987500  /* 0x003090 .....V..^...A.........u. */
                                                  892:       .pword      0x78074F, 0xBE064F, 0xBE054F, 0xBE044F, 0x060000, 0xA32802, 0x320032, 0x784110  /* 0x0030A0 O.xO..O..O......(.2.2.Ax */
                                                  893:       .pword      0xB3C2A3, 0x514F83, 0x3A0011, 0x370004, 0xE80183, 0x784154, 0x514F87, 0x3A0012  /* 0x0030B0 ....OQ..:..7...TAx.OQ..: */
                                                  894:       .pword      0x4001E8, 0x784113, 0xB3C010, 0xB3C2A4, 0x514F84, 0x32002F, 0x780003, 0xEB0180  /* 0x0030C0 ..@.Ax.......OQ/.2..x... */
                                                  895:       .pword      0x200084, 0xB3C3F5, 0xB3C2A6, 0x370014, 0x780200, 0xEB0180, 0xEB0280, 0xB3C3F6  /* 0x0030D0 .. ........7..x......... */
                                                  896:       .pword      0xB3C2A7, 0x370001, 0x780283, 0x514F86, 0x320003, 0x7AC2E1, 0x52CF82, 0x3A0018  /* 0x0030E0 .....7..x.OQ..2..z..R..: */
                                                  897:       .pword      0x518FE7, 0x3AFFE2, 0x37FFE5, 0x418269, 0x784150, 0xE80183, 0x514F86, 0x320012  /* 0x0030F0 ..Q..:..7i.APAx....OQ..2 */
                                                  898:       .pword      0x514F85, 0x320003, 0x7A4261, 0x524F82, 0x3A000F, 0x518FE2, 0x3AFFF4, 0xB3C010  /* 0x003100 .OQ..2aBz.OR..:..Q..:... */
                                                  899:       .pword      0x37000C, 0x2000B2, 0x07E9C8, 0xA7F000, 0xEA0000, 0xE90000, 0xDE004F, 0x370005  /* 0x003110 ..7.. ............O....7 */
                                                  900:       .pword      0xEB4000, 0x370003, 0xB3C010, 0x370001, 0xEB4000, 0x060000, 0xFA000E, 0xBE9F88  /* 0x003120 .@...7.....7.@.......... */
                                                  901:       .pword      0xBE9F8A, 0x781F8C, 0x780480, 0x780601, 0xEB0100, 0x9FB7C2, 0xBE0019, 0x9FBF80  /* 0x003130 .....x..x..x............ */
                                                  902:       .pword      0x9FBF91, 0x9FBFA2, 0x900949, 0x9FB7F2, 0x9FB7D0, 0x9FB7E1, 0x78041C, 0x97BD0F  /* 0x003140 ......I.............x... */
                                                  903:       .pword      0x97BD9F, 0x780208, 0x5781EC, 0x578170, 0x5780F8, 0x578076, 0x07F215, 0xE80088  /* 0x003150 .....x..Wp.W..Wv.W...... */
                                                  904:       .pword      0xE00000, 0x320007, 0x784010, 0x404FFB, 0x32001C, 0xE00400, 0x32001A, 0x780401  /* 0x003160 .....2.@x.O@..2.....2..x */
                                                  905:       .pword      0x37FFEE, 0x900849, 0x900260, 0x9002F0, 0x97B90F, 0x97B99F, 0x520F82, 0x5A8F83  /* 0x003170 ..7I..`.............R..Z */
                                                  906:       .pword      0x3A0003, 0x9068E0, 0x50CFE3, 0x3A0010, 0x9FBF8A, 0x9FBF9B, 0xB3C012, 0x5780F0  /* 0x003180 ..:.h...P..:...........W */
                                                  907:       .pword      0x0700CC, 0x500FF7, 0x3A0006, 0x370008, 0x78064F, 0xBE054F, 0xBE044F, 0xFA8000  /* 0x003190 .....P..:..7O.xO..O..... */
                                                  908:       .pword      0x060000, 0x780E08, 0xEB0000, 0x37FFF8, 0x780E08, 0x2000F0, 0x37FFF5, 0xFE0000  /* 0x0031A0 .....x.....7..x.. ..7... */
                                                  909:       .pword      0xB82260, 0xA37801, 0x3A0006, 0xA3D804, 0x320002, 0xAF4761, 0xA26001, 0xA7C004  /* 0x0031B0 `"..x...:.....2aG..`.... */
                                                  910:       .pword      0xA06001, 0xBE9F80, 0xBE9F82, 0xF80032, 0x880191, 0xE00003, 0x32002C, 0x200067  /* 0x0031C0 .`.......2........,.2g.  */
                                                  911:       .pword      0x539FE3, 0x200006, 0xE00006, 0x320004, 0x9FBFF7, 0xA71000, 0xA0F004, 0xA11000  /* 0x0031D0 ..S.. .....2............ */
                                                  912:       .pword      0xA10000, 0xAFE761, 0x37FFFE, 0x97BBFF, 0xEB8080, 0xBAC090, 0xBA1F90, 0x609FCF  /* 0x0031E0 ...a....7..............` */
                                                  913:       .pword      0xE88000, 0xE13866, 0x3A0005, 0xBAC090, 0x609FCF, 0xBA0090, 0x609FCF, 0xE88000  /* 0x0031F0 ...f8...:.....`.....`... */
                                                  914:       .pword      0xE00000, 0xAF2042, 0xEC2032, 0xA7F004, 0x5383E3, 0xA1F004, 0xEA8FCF, 0x3A0004  /* 0x003200 ...B .2 ......S........: */
                                                  915:       .pword      0x410107, 0x518187, 0x360007, 0x37FFE7, 0xEBD900, 0xE90183, 0x320003, 0xE90387  /* 0x003210 ..A..Q..6..7........2... */
                                                  916:       .pword      0x3AFFFB, 0x37FFE1, 0xE9878F, 0xF90032, 0xBE014F, 0xBE004F, 0x040C04, 0x000000  /* 0x003220 ..:..7...2..O..O........ */
                                                  917:       .pword      0xBFAAA0, 0x32003A, 0x97B8CF, 0xDE08CD, 0x3A0037, 0xAF6044, 0x3A0035, 0xAC0AA2  /* 0x003230 ...:.2......7.:D`.5.:... */
                                                  918:       .pword      0x3A0033, 0xF80036, 0xF80000, 0xF80000, 0xF80034, 0xBE9F84, 0xBE9F86, 0x8054E5  /* 0x003240 3.:6........4.........T. */
                                                  919:       .pword      0x807BC6, 0x807A37, 0x130295, 0x188337, 0x188397, 0xEF6042, 0x20AA04, 0x780184  /* 0x003250 .{.7z....7.....B`... ..x */
                                                  920:       .pword      0x108214, 0x32001B, 0x420062, 0xE12830, 0xE1B030, 0xE1B830, 0x33FFF8, 0xBE9F84  /* 0x003260 .....2b.B0(.0..0....3... */
                                                  921:       .pword      0xBE9F86, 0x1082B0, 0x188330, 0x1883B0, 0xAF2042, 0x780994, 0x428A54, 0x4B0A54  /* 0x003270 ......0.....B ...xT.BT.K */
                                                  922:       .pword      0x4B8A54, 0x2328E6, 0x200007, 0xBE9F86, 0x781FB0, 0x781FB0, 0x064000, 0xEF6042  /* 0x003280 T.K.(#.. .....x..x.@.B`. */
                                                  923:       .pword      0xBE034F, 0xBE024F, 0x980A10, 0xEB0080, 0x37FFE2, 0xBE034F, 0xBE024F, 0xF90034  /* 0x003290 O..O..........7O..O..4.. */
                                                  924:       .pword      0xF90000, 0xF90000, 0xF90036, 0xA90AA2, 0xBE014F, 0x7800CF, 0x064000, 0xFA003A  /* 0x0032A0 ......6.....O....x.@.:.. */
                                                  925:       .pword      0xBE9F88, 0xBE0400, 0xBE0018, 0x9FBFB0, 0x9FBFC1, 0xEB0000, 0x9FBFD0, 0xEB4080  /* 0x0032B0 ......................@. */
                                                  926:       .pword      0x780009, 0x07F37D, 0xE00400, 0x320002, 0x504FE3, 0x3A0005, 0x900028, 0xB3C131  /* 0x0032C0 ..x}.......2.OP..:(..1.. */
                                                  927:       .pword      0x987001, 0xEB8000, 0x370027, 0x504FE1, 0x3A0012, 0x2FFC21, 0x40808F, 0x780009  /* 0x0032D0 .p....'.7.OP..:!./..@..x */
                                                  928:       .pword      0x07FE60, 0x200027, 0x2003F6, 0xEB0280, 0x578266, 0x5781EA, 0x578177, 0x2FFC21  /* 0x0032E0 `..'. .. ...f.W..Ww.W!./ */
                                                  929:       .pword      0x40808F, 0x780008, 0x07F0BA, 0x780080, 0xEB8000, 0xE00001, 0x3A0013, 0x97B01F  /* 0x0032F0 ..@..x.....x........:... */
                                                  930:       .pword      0xA34800, 0x3A0005, 0x900028, 0xB3C151, 0x987001, 0xEB8000, 0x37000B, 0xB3C012  /* 0x003300 .H...:(..Q...p......7... */
                                                  931:       .pword      0x2FFE01, 0x40808F, 0x2FFC20, 0x40000F, 0x07F4C7, 0x780080, 0xEB8000, 0xE00001  /* 0x003310 ../..@ ./..@.....x...... */
                                                  932:       .pword      0x3A0001, 0xEB0000, 0xBE044F, 0xFA8000, 0x060000, 0xBE9F88, 0xBE9F8A, 0x781F8C  /* 0x003320 ..:...O................x */
                                                  933:       .pword      0xBE0500, 0x784602, 0xBE011B, 0x78000A, 0x07F7C3, 0xBE0400, 0x200170, 0x540FE0  /* 0x003330 ....Fx.....x......p. ..T */
                                                  934:       .pword      0x5C8FE0, 0x320027, 0x90686A, 0x504FE1, 0x3A0007, 0xEB4080, 0x20FF84, 0x200005  /* 0x003340 ..\'.2jh..OP..:.@... ..  */
                                                  935:       .pword      0xBE0108, 0x78000A, 0x07E9F6, 0x370011, 0x504FE2, 0x3A0007, 0xEB4080, 0x2FFF84  /* 0x003350 .....x.....7.OP..:.@.../ */
                                                  936:       .pword      0x200005, 0xBE0108, 0x78000A, 0x07E9ED, 0x370008, 0x504FE3, 0x3A0006, 0xEB4080  /* 0x003360 .. .....x.....7.OP..:.@. */
                                                  937:       .pword      0x2FFF84, 0x20FFF5, 0xBE0108, 0x78000A, 0x07E9E4, 0xEB4080, 0xBE0208, 0xBE011B  /* 0x003370 ../.. .....x....@....... */
                                                  938:       .pword      0x78000A, 0x07E9DF, 0xBE8D88, 0xEB0000, 0xE0040C, 0x320003, 0xBE0108, 0x78000A  /* 0x003380 ..x..............2.....x */
                                                  939:       .pword      0x07FE4A, 0x78064F, 0xBE054F, 0xBE044F, 0x060000, 0x784111, 0xB3C203, 0x514F83  /* 0x003390 J..O.xO..O......Ax....OQ */
                                                  940:       .pword      0x3A002C, 0x370006, 0x780003, 0x780084, 0x7842B4, 0x52CF86, 0x3A0003, 0x370009  /* 0x0033A0 ,.:..7..x..x.Bx..R..:..7 */
                                                  941:       .pword      0xEB4100, 0x370007, 0x785985, 0x780003, 0x780084, 0xE84102, 0x514FE8, 0x3AFFF2  /* 0x0033B0 .A...7.Yx..x..x.A..OQ..: */
                                                  942:       .pword      0x370004, 0xE80081, 0xE84102, 0x514FE7, 0x36FFFC, 0xB3C203, 0x11CF91, 0x320013  /* 0x0033C0 ..7....A..OQ..6........2 */
                                                  943:       .pword      0x41C1EE, 0x785803, 0x514FEA, 0x3E000F, 0x784191, 0xB3C204, 0x51CF84, 0x32000B  /* 0x0033D0 ..A.Xx.OQ..>.Ax.....Q..2 */
                                                  944:       .pword      0x780200, 0xB3C205, 0x370003, 0x7841D1, 0x51CF85, 0x320005, 0x785A03, 0x780004  /* 0x0033E0 ..x.....7.Ax..Q..2.Zx..x */
                                                  945:       .pword      0xE84102, 0x514FEA, 0x36FFF8, 0xEB4800, 0x060000, 0x780180, 0x785982, 0xE80201  /* 0x0033F0 .A..OQ..6.H......x.Yx... */
                                                  946:       .pword      0xB3C012, 0xB3C206, 0x37FFCF, 0xFA0002, 0xBE9F88, 0xBE9F8A, 0x784400, 0x201F60  /* 0x003400 ........7..........Dx`.  */
                                                  947:       .pword      0x508F80, 0x3C0008, 0xB3C010, 0x201F42, 0x508F82, 0x3D0027, 0x200710, 0x508F80  /* 0x003410 ..P..<...B. ..P'.=.. ..P */
                                                  948:       .pword      0x3A0023, 0x37001F, 0x201F70, 0x508F80, 0x3A001F, 0x784092, 0x20A500, 0x984061  /* 0x003420 #.:..7p. ..P..:.@x.. a@. */
                                                  949:       .pword      0x900090, 0xA01001, 0x980011, 0xEB4000, 0x9FF7E0, 0x20001A, 0x20000B, 0x201F89  /* 0x003430 ..........@...... .. ..  */
                                                  950:       .pword      0xBE020A, 0x57816A, 0x780089, 0x784008, 0x0704A7, 0x97F0EF, 0xE84001, 0x9FF7E0  /* 0x003440 ...j.W..x.@x.......@.... */
                                                  951:       .pword      0xFB8000, 0x20A561, 0x784091, 0xFB8081, 0xE80081, 0x500F81, 0x35FFF1, 0xB3C010  /* 0x003450 ...a. .@x........P..5... */
                                                  952:       .pword      0x370004, 0xEF6A52, 0xB3C010, 0x370001, 0xEB4000, 0xBE054F, 0xBE044F, 0xFA8000  /* 0x003460 ..7Rj......7.@.O..O..... */
                                                  953:       .pword      0x060000, 0xBE9F88, 0xBE9F8A, 0x781F8C, 0x8078FC, 0xE0000C, 0x320028, 0x20F1EB  /* 0x003470 ...........x.x....(.2..  */
                                                  954:       .pword      0xEB0480, 0x78061C, 0x78001B, 0x900090, 0xE00001, 0x32001D, 0x780511, 0x8078F0  /* 0x003480 .....x..x........2..x.x. */
                                                  955:       .pword      0x900090, 0x900021, 0xE00000, 0x32000D, 0x780410, 0x07E776, 0x8078F0, 0x900010  /* 0x003490 ...!.......2..xv...x.... */
                                                  956:       .pword      0x980029, 0x8078F0, 0x900010, 0x980028, 0x8078F0, 0x900090, 0x900021, 0xE00000  /* 0x0034A0 )...x....(...x....!..... */
                                                  957:       .pword      0x3AFFF3, 0x780001, 0x07E769, 0x8078F0, 0x980019, 0x8078F0, 0x98001A, 0x78001B  /* 0x0034B0 ..:..xi...x.....x......x */
                                                  958:       .pword      0x900090, 0xE00001, 0x3AFFE3, 0x07E760, 0x780D8C, 0xE0000C, 0x3AFFDA, 0x807900  /* 0x0034C0 ........:`....x.....:.y. */
                                                  959:       .pword      0x885410, 0x78064F, 0xBE054F, 0xBE044F, 0x060000, 0xBE9F88, 0x781F8A, 0x780502  /* 0x0034D0 .T.O.xO..O..........x..x */
                                                  960:       .pword      0xBE0404, 0xB3C062, 0x20F153, 0x104F93, 0x3A0026, 0x20F003, 0x805400, 0x618180  /* 0x0034E0 ...b..S. .O.&.:.. .T...a */
                                                  961:       .pword      0xB3C012, 0x204000, 0x518F80, 0x3A001F, 0x784001, 0x0703F6, 0x780180, 0xB3C142  /* 0x0034F0 ....@ ..Q..:.@x.....xB.. */
                                                  962:       .pword      0xE00003, 0x320019, 0x900853, 0xB23000, 0xB3C182, 0x320015, 0x905823, 0xB3C152  /* 0x003500 .....2S...0......2#X.R.. */
                                                  963:       .pword      0xE00400, 0x3D0011, 0x900013, 0xB3C112, 0xA35800, 0x3A000D, 0x900013, 0xB3C122  /* 0x003510 .....=.......X...:...".. */
                                                  964:       .pword      0xA36800, 0x3A0009, 0x900013, 0xB3C102, 0xA39800, 0x320005, 0x780108, 0x78008A  /* 0x003520 .h...:...........2..x..x */
                                                  965:       .pword      0x780003, 0x0700F8, 0xEB4100, 0x784002, 0x78054F, 0xBE044F, 0x060000, 0xBE9F88  /* 0x003530 ..x....A..@xO.xO........ */
                                                  966:       .pword      0x781F8A, 0x780502, 0xBE0404, 0xB3C062, 0x20F153, 0x104F93, 0x3A0026, 0x20F003  /* 0x003540 ..x..x...b..S. .O.&.:..  */
                                                  967:       .pword      0x805400, 0x618180, 0xB3C012, 0x204000, 0x518F80, 0x3A001F, 0x784001, 0x0703C4  /* 0x003550 .T...a....@ ..Q..:.@x... */
                                                  968:       .pword      0x780180, 0xB3C142, 0xE00003, 0x320019, 0x900853, 0xB23000, 0xB3C182, 0x320015  /* 0x003560 ..xB.......2S...0......2 */
                                                  969:       .pword      0x905823, 0xB3C152, 0xE00400, 0x350011, 0x900013, 0xB3C112, 0xA35800, 0x3A000D  /* 0x003570 #X.R.......5.......X...: */
                                                  970:       .pword      0x900013, 0xB3C122, 0xA36800, 0x3A0009, 0x900013, 0xB3C102, 0xA39800, 0x320005  /* 0x003580 ..."...h...:...........2 */
                                                  971:       .pword      0x780108, 0x78008A, 0x780003, 0x0700F2, 0xEB4100, 0x784002, 0x78054F, 0xBE044F  /* 0x003590 ..x..x..x....A..@xO.xO.. */
                                                  972:       .pword      0x060000, 0xFA0022, 0xBE9F88, 0x780400, 0x784498, 0xEB4000, 0xE00409, 0x320028  /* 0x0035A0 ...".......x.Dx.@....(.2 */
                                                  973:       .pword      0xB3C030, 0x9FDFE0, 0xEB4000, 0x9FDFF0, 0x9FE780, 0x9FE790, 0xB3C121, 0x9FE7A1  /* 0x0035B0 0......@..........!..... */
                                                  974:       .pword      0x9FE7B0, 0x9FE7C0, 0x9FE7D0, 0x9FE7E0, 0x9FE7F0, 0x200126, 0x200007, 0x5782F7  /* 0x0035C0 ...............&. .. ..W */
                                                  975:       .pword      0xB3C0A4, 0x2FFDE3, 0x41818F, 0xB3C012, 0x784080, 0x784009, 0x07F7EB, 0x9FEF80  /* 0x0035D0 ...../..A....@x.@x...... */
                                                  976:       .pword      0xE00400, 0x320003, 0x370009, 0x072536, 0x072959, 0x2FFDA2, 0x41010F, 0x5780F8  /* 0x0035E0 .....2..76%.Y).../..A..W */
                                                  977:       .pword      0x784018, 0x070198, 0xE00400, 0x32FFF7, 0x97E80F, 0xFB8000, 0xE90000, 0xDE004F  /* 0x0035F0 .@x........2.........O.. */
                                                  978:       .pword      0xBE044F, 0xFA8000, 0x060000, 0xBE9F88, 0x780482, 0x780403, 0x20F152, 0x104F92  /* 0x003600 O.............x..xR. .O. */
                                                  979:       .pword      0x320006, 0xB3C060, 0x784C80, 0xEB0C00, 0x781438, 0xB3C010, 0x370022, 0x784001  /* 0x003610 ..2`...Lx...8.x...".7.@x */
                                                  980:       .pword      0x070363, 0xE00000, 0x32001B, 0x900090, 0xDE08C9, 0x60C0E1, 0x900110, 0xA38802  /* 0x003620 c.......2........`...... */
                                                  981:       .pword      0x320005, 0xEB4C80, 0x900900, 0x900990, 0xBE8C02, 0x37000E, 0x900110, 0xA35802  /* 0x003630 ..2.L............7....X. */
                                                  982:       .pword      0x320003, 0xB3C110, 0x784C80, 0x370008, 0x900110, 0xA36802, 0x320003, 0x905840  /* 0x003640 ..2....Lx..7....h...2@X. */
                                                  983:       .pword      0x784C80, 0x370002, 0xB3C190, 0x784C80, 0x784001, 0x370003, 0xB3C140, 0x784C80  /* 0x003650 .Lx..7....Lx.@x..7@...Lx */
                                                  984:       .pword      0xB3C010, 0xBE044F, 0x060000, 0xFA0034, 0xBE9F88, 0x781F8A, 0x780480, 0xB3C05A  /* 0x003660 ...O.....4.......x..xZ.. */
                                                  985:       .pword      0xEB4400, 0x9FCFA8, 0x9FCFB8, 0x9FCFC8, 0x9FCFD8, 0x9FCFE8, 0x9FCFF8, 0xB83360  /* 0x003670 .D...................`3. */
                                                  986:       .pword      0x2FFD55, 0x42828F, 0xB3C064, 0x2FFCA3, 0x41818F, 0xB3C012, 0x784088, 0x784019  /* 0x003680 U./..Bd..../..A....@x.@x */
                                                  987:       .pword      0x07F791, 0x9FD7C0, 0xE00400, 0x320003, 0x37000D, 0x0724DC, 0x0728FF, 0x2FFC62  /* 0x003690 ...........2..7.$..(.b./ */
                                                  988:       .pword      0x41010F, 0x2FFD41, 0x40808F, 0x784019, 0x07013D, 0xE00400, 0x32FFF6, 0x97D04F  /* 0x0036A0 ..AA./..@.@x=.......2O.. */
                                                  989:       .pword      0xE00400, 0x320004, 0xE9450A, 0x3AFFDD, 0xEB4000, 0x370001, 0xB3C010, 0x78054F  /* 0x0036B0 .....2.E...:.@...7...O.x */
                                                  990:       .pword      0xBE044F, 0xFA8000, 0x060000, 0xBE9F88, 0x784480, 0x784009, 0x0705B0, 0x780400  /* 0x0036C0 O............Dx.@x.....x */
                                                  991:       .pword      0xEB8000, 0xE00008, 0x320025, 0x901028, 0x900050, 0x500F88, 0x3A0009, 0x200011  /* 0x0036D0 ......%.2(..P....P..:..  */
                                                  992:       .pword      0x780008, 0x07FA61, 0xEB0080, 0x780008, 0x07FA5E, 0x901028, 0xEB0080, 0x980051  /* 0x0036E0 ..xa.......x^..(.....Q.. */
                                                  993:       .pword      0x9010B8, 0x901048, 0x9000B1, 0x010001, 0x20F0F0, 0x14CF90, 0x3A0007, 0xB3C010  /* 0x0036F0 ...H.......... .....:... */
                                                  994:       .pword      0xB7EA74, 0xEB4000, 0x20F0D1, 0x784880, 0xE88081, 0x784880, 0xEB0000, 0x807B41  /* 0x003700 t...@... .Hx....Hx...A{. */
                                                  995:       .pword      0x508F88, 0x3A0006, 0xB80060, 0x887B20, 0x887B31, 0x20F680, 0xEB0800, 0xEB0000  /* 0x003710 ..P..:`.. {.1{... ...... */
                                                  996:       .pword      0xBE044F, 0x060000, 0x900190, 0xA17003, 0x980013, 0x900190, 0xA18003, 0x980013  /* 0x003720 O.........p............. */
                                                  997:       .pword      0x900210, 0x2FFE03, 0x620183, 0x980013, 0x900190, 0xA1C003, 0x980013, 0x980831  /* 0x003730 ...../..b............1.. */
                                                  998:       .pword      0xB82260, 0x980804, 0x980815, 0xEB0180, 0x980052, 0x980063, 0xEB0100, 0x980872  /* 0x003740 `"..........R..c.....r.. */
                                                  999:       .pword      0x9009D0, 0x203002, 0x618182, 0x518F82, 0x3A0003, 0xB3C401, 0x985801, 0x37000A  /* 0x003750 ....0 ..a..Q..:....X...7 */
                                                  1000:      .pword      0x201002, 0x518F82, 0x3A0005, 0xB3C602, 0x985802, 0xEB4100, 0x984092, 0x370002  /* 0x003760 .. ..Q..:....X..A..@...7 */
                                                  1001:      .pword      0xB3C801, 0x985801, 0x900090, 0xA19001, 0x980011, 0x060000, 0x900190, 0xA17003  /* 0x003770 ....X.................p. */
                                                  1002:      .pword      0x980013, 0x900190, 0xA18003, 0x980013, 0x900210, 0x2FFE03, 0x620183, 0x980013  /* 0x003780 ................./..b... */
                                                  1003:      .pword      0x900190, 0xA1C003, 0x980013, 0x980831, 0xB82260, 0x980804, 0x980815, 0xEB0180  /* 0x003790 .........1..`".......... */
                                                  1004:      .pword      0x980052, 0x980063, 0xEB0100, 0x980872, 0x9009D0, 0x203002, 0x618182, 0x518F82  /* 0x0037A0 R..c.....r......0 ..a..Q */
                                                  1005:      .pword      0x3A0003, 0xB3C501, 0x985801, 0x37000A, 0x201002, 0x518F82, 0x3A0005, 0xB3C702  /* 0x0037B0 ..:....X...7.. ..Q..:... */
                                                  1006:      .pword      0x985802, 0xEB4100, 0x984092, 0x370002, 0xB3C901, 0x985801, 0x900090, 0xA19001  /* 0x0037C0 .X..A..@...7....X....... */
                                                  1007:      .pword      0x980011, 0x060000, 0x784080, 0xB3C560, 0xE00401, 0x340026, 0x20EC30, 0x784110  /* 0x0037D0 .......@x`.....&.40. .Ax */
                                                  1008:      .pword      0xB3C560, 0x514F81, 0x3A0021, 0x784002, 0x07010E, 0xB3C301, 0x504F81, 0x3A001C  /* 0x0037E0 `...OQ!.:.@x.......OP..: */
                                                  1009:      .pword      0x20EC60, 0xFB8090, 0xB20F01, 0x200300, 0x508F80, 0x320013, 0x3C0008, 0xB3C510  /* 0x0037F0 `. ........ ..P..2..<... */
                                                  1010:      .pword      0x508FF0, 0x320012, 0xE84000, 0x200202, 0x508F82, 0x3A000D, 0x37000D, 0x200500  /* 0x003800 ..P..2.@... ..P..:..7..  */
                                                  1011:      .pword      0x508F80, 0x320007, 0x404065, 0x200602, 0x508F82, 0x320006, 0x200400, 0x508F80  /* 0x003810 ..P..2e@@.. ..P..2.. ..P */
                                                  1012:      .pword      0x3A0002, 0xB3C530, 0x370001, 0xB3C500, 0x060000, 0x200712, 0x508F82, 0x32000E  /* 0x003820 ..:0....7........ ..P..2 */
                                                  1013:      .pword      0x780002, 0x508F80, 0x3E0006, 0xE00001, 0x32000F, 0x50006B, 0x508F80, 0x3A0010  /* 0x003830 ..x..P..>.....2k.P..P..: */
                                                  1014:      .pword      0x370003, 0x200760, 0x508F80, 0x3E000C, 0xB3C011, 0x37000B, 0x20EC31, 0x784191  /* 0x003840 ..7`. ..P..>.....71. .Ax */
                                                  1015:      .pword      0xB3C011, 0x51CF80, 0x3A0006, 0x370007, 0x0723FD, 0x072820, 0xB3C011, 0x370001  /* 0x003850 .....Q..:..7.#. (......7 */
                                                  1016:      .pword      0xEB4080, 0x784001, 0x060000, 0xEB4000, 0x20EC31, 0x784880, 0x4080E3, 0x784880  /* 0x003860 .@..@x....@.1. .Hx..@.Hx */
                                                  1017:      .pword      0xB82260, 0xEB0100, 0x200711, 0x784003, 0x807A93, 0x010003, 0xB3C011, 0x37FFF1  /* 0x003870 `"...... .@x.z.........7 */
                                                  1018:      .pword      0xFA0006, 0x781F88, 0xB3C012, 0x780080, 0x578068, 0x07F449, 0x780400, 0xEB8000  /* 0x003880 .....x.....xh.WI....x... */
                                                  1019:      .pword      0xE00008, 0x32001C, 0x780008, 0x07E623, 0x780080, 0xEB0000, 0xE00001, 0x320016  /* 0x003890 .....2..x#....x........2 */
                                                  1020:      .pword      0x780088, 0x578068, 0x07F793, 0x780080, 0xEB0000, 0xE00001, 0x32000F, 0x780088  /* 0x0038A0 ..xh.W.....x........2..x */
                                                  1021:      .pword      0x578068, 0x07F17E, 0x780080, 0xEB8000, 0xE00001, 0x3A0008, 0x780088, 0x578068  /* 0x0038B0 h.W~....x........:..xh.W */
                                                  1022:      .pword      0x07F785, 0x780080, 0xEB8000, 0xE00001, 0x3A0001, 0xEB0000, 0x78044F, 0xFA8000  /* 0x0038C0 .....x........:...O.x... */
                                                  1023:      .pword      0x060000, 0x900290, 0xA15005, 0x980015, 0x900290, 0xA16005, 0x980015, 0x900290  /* 0x0038D0 .......P........`....... */
                                                  1024:      .pword      0xA17005, 0x980015, 0x900290, 0xA18005, 0x980015, 0x900310, 0x2FFE05, 0x630285  /* 0x0038E0 .p................../..c */
                                                  1025:      .pword      0x980015, 0x900290, 0xA1C005, 0x980015, 0x980833, 0xB83360, 0x980806, 0x980817  /* 0x0038F0 ............3..`3....... */
                                                  1026:      .pword      0xB82361, 0x980056, 0x980067, 0xEB0180, 0x980873, 0x980821, 0x980072, 0xE00004  /* 0x003900 a#.V..g.....s..!..r..... */
                                                  1027:      .pword      0x3A0003, 0xB3C101, 0x985801, 0x370002, 0xB3C301, 0x985801, 0x900090, 0xA19001  /* 0x003910 ..:....X...7....X....... */
                                                  1028:      .pword      0x980011, 0x060000, 0xE00400, 0x340004, 0x20EC33, 0x104F93, 0x3A000B, 0x370006  /* 0x003920 ...........43. .O...:..7 */
                                                  1029:      .pword      0xB3C560, 0x784880, 0xEB0900, 0x781132, 0xB3C010, 0x370019, 0x20EC60, 0x784010  /* 0x003930 `...Hx...2.x.....7`. .@x */
                                                  1030:      .pword      0xE00400, 0x3A0006, 0xB3C560, 0x784880, 0xEB0900, 0x781132, 0xB3C010, 0x37000F  /* 0x003940 .....:`...Hx...2.x.....7 */
                                                  1031:      .pword      0xB3C203, 0x504F83, 0x320006, 0x780200, 0xB20F04, 0xEB4000, 0x200603, 0x520F83  /* 0x003950 ....OP..2..x....@... ..R */
                                                  1032:      .pword      0x3A0006, 0x8076A4, 0x8076B5, 0xBE8904, 0x20EC50, 0x784890, 0xB3C010, 0x060000  /* 0x003960 ..:.v..v....P. .Hx...... */
                                                  1033:      .pword      0xEB1F80, 0x781F81, 0x781F80, 0x781F86, 0x781F85, 0x781F84, 0x024244, 0x000000  /* 0x003970 .....x..x..x..x..xDB.... */
                                                  1034:      .pword      0x024066, 0x000000, 0xEB0380, 0x53824F, 0x5B82CF, 0x5B834F, 0x7801CF, 0x320014  /* 0x003980 f@.......O.S..[O.[..x..2 */
                                                  1035:      .pword      0x20AA07, 0x781997, 0x33000B, 0x401984, 0x489985, 0x491986, 0xBE9984, 0x781986  /* 0x003990 .. ..x..3..@..H..I.....x */
                                                  1036:      .pword      0x7819CF, 0x7819CF, 0x280000, 0x781980, 0x518BF4, 0x060000, 0x501984, 0x589985  /* 0x0039A0 ..x..x..(..x..Q.....P..X */
                                                  1037:      .pword      0x591986, 0x090002, 0xEB1980, 0x37FFF4, 0x5787E4, 0x060000, 0x9068E0, 0x50CFE3  /* 0x0039B0 ..Y........7..W....h...P */
                                                  1038:      .pword      0x3A000D, 0x510162, 0x5981E0, 0x906A50, 0xFB8204, 0xEB0280, 0xB99B04, 0xB81104  /* 0x0039C0 ..:b.Q..YPj............. */
                                                  1039:      .pword      0x430183, 0x900890, 0x900800, 0x400002, 0x488083, 0x370014, 0x510FE1, 0x598FE0  /* 0x0039D0 ..C........@..H..7..Q..Y */
                                                  1040:      .pword      0x3E0005, 0x9000D0, 0x900040, 0x400002, 0x488083, 0x37000C, 0x510162, 0x5981E0  /* 0x0039E0 ..>...@....@..H..7b.Q..Y */
                                                  1041:      .pword      0x906A50, 0xFB8204, 0xEB0280, 0xB99B04, 0xB81104, 0x430183, 0x900890, 0x900800  /* 0x0039F0 Pj...............C...... */
                                                  1042:      .pword      0x400002, 0x488083, 0x060000, 0x20F001, 0x805400, 0x608080, 0xB3C310, 0x32001E  /* 0x003A00 ..@..H..... .T...`.....2 */
                                                  1043:      .pword      0x20F001, 0x805400, 0x608080, 0x204000, 0x508F80, 0x3A0008, 0x200F01, 0x805400  /* 0x003A10 .. .T...`.@ ..P..:.. .T. */
                                                  1044:      .pword      0x608080, 0xB3C300, 0x508FF0, 0x3A0012, 0x40406A, 0x370010, 0x20F001, 0x805400  /* 0x003A20 ..`.....P..:j@@..7.. .T. */
                                                  1045:      .pword      0x608080, 0x205000, 0x508F80, 0x3A0003, 0x20F160, 0x784010, 0x370007, 0x805402  /* 0x003A30 ..`.P ..P..:`. .@x..7.T. */
                                                  1046:      .pword      0xB11012, 0xB3C340, 0x202FE1, 0x510F81, 0x3E0001, 0xE9C000, 0x060000, 0x900290  /* 0x003A40 ...@.../ ..Q..>......... */
                                                  1047:      .pword      0xA15005, 0x980015, 0x900290, 0xA16005, 0x980015, 0x900290, 0xA17005, 0x980015  /* 0x003A50 .P........`........p.... */
                                                  1048:      .pword      0x900290, 0xA18005, 0x980015, 0x900310, 0x2FFE05, 0x630285, 0x980015, 0x900290  /* 0x003A60 ............../..c...... */
                                                  1049:      .pword      0xA1C005, 0x980015, 0x980833, 0xB83360, 0x980806, 0x980817, 0xEB0280, 0x980054  /* 0x003A70 ......3..`3..........T.. */
                                                  1050:      .pword      0x980065, 0xEB0180, 0x980873, 0x980821, 0x980072, 0xB3C201, 0x985801, 0x900090  /* 0x003A80 e.....s..!..r......X.... */
                                                  1051:      .pword      0xA19001, 0x980011, 0x060000, 0xE00004, 0x320021, 0x780280, 0xB80862, 0x200036  /* 0x003A90 ............!.2..xb..6.  */
                                                  1052:      .pword      0x090011, 0xD88846, 0x410100, 0xB08003, 0xEB0000, 0x800197, 0x880193, 0xAFE761  /* 0x003AA0 ...F....A............a.. */
                                                  1053:      .pword      0x37FFFE, 0xE00001, 0x32000C, 0xE90204, 0xA70002, 0x370006, 0xBA5AD2, 0xE90204  /* 0x003AB0 ..7.....2........7.Z.... */
                                                  1054:      .pword      0x39000C, 0x370002, 0xBA5AB2, 0xBA5A92, 0xBADAC2, 0xE88102, 0xB4A032, 0x520263  /* 0x003AC0 ..9..7.Z..Z.......2..c.R */
                                                  1055:      .pword      0x31FFF9, 0x420262, 0x330002, 0x098004, 0xBA5AB2, 0x880197, 0x060000, 0x781F88  /* 0x003AD0 ..1b.B..3....Z.........x */
                                                  1056:      .pword      0x780400, 0x901028, 0x9000D0, 0xEB0000, 0x508F88, 0x32001A, 0xE00008, 0x32000E  /* 0x003AE0 ..x(..........P..2.....2 */
                                                  1057:      .pword      0x200011, 0x780008, 0x07F858, 0x784080, 0xEB8000, 0xE00401, 0x320011, 0xEB0080  /* 0x003AF0 .. ..xX...@x........2... */
                                                  1058:      .pword      0x780008, 0x07F851, 0x784080, 0xEB8000, 0xE00401, 0x32000A, 0x901028, 0x980058  /* 0x003B00 ..xQ...@x........2(..X.. */
                                                  1059:      .pword      0x901128, 0xEB8000, 0xEB8080, 0xBE8900, 0x901128, 0x980120, 0x980131, 0xEB0000  /* 0x003B10 (...........(.. ..1..... */
                                                  1060:      .pword      0x78044F, 0x060000, 0xFA0008, 0xBE0111, 0x9FBFD2, 0x9FBFE3, 0xEB0200, 0x9FBFF4  /* 0x003B20 O.x..................... */
                                                  1061:      .pword      0x510FE0, 0x598FE0, 0x3A0005, 0x900120, 0x900262, 0x9002F2, 0x9FBFD4, 0x9FBFE5  /* 0x003B30 ..Q..Y..: ..b........... */
                                                  1062:      .pword      0x900A71, 0xE9818F, 0x578166, 0x5780E8, 0x07ED1F, 0x780080, 0xEB4000, 0xE00001  /* 0x003B40 q.....f.W..W.....x.@.... */
                                                  1063:      .pword      0x320009, 0x900921, 0xB3C010, 0xE00002, 0x3A0005, 0x900851, 0xA7F000, 0xEA0000  /* 0x003B50 ..2!..........:Q........ */
                                                  1064:      .pword      0xEA0000, 0xDE004F, 0xFA8000, 0x060000, 0xBE9F88, 0x781F8A, 0x8078E0, 0xE00000  /* 0x003B60 ...O.............x.x.... */
                                                  1065:      .pword      0x3A0003, 0x37000E, 0x780008, 0x370002, 0xEB0500, 0x20F1C9, 0x900410, 0x780010  /* 0x003B70 ..:..7..x..7..... .....x */
                                                  1066:      .pword      0x07E403, 0x8078E0, 0x78080A, 0x780019, 0x07E3FF, 0x780C88, 0xE00008, 0x3AFFF2  /* 0x003B80 ....x...x..x.....x.....: */
                                                  1067:      .pword      0x8053D0, 0xE00000, 0x320002, 0x07E3F8, 0xEF2A7A, 0x805420, 0xE00000, 0x320002  /* 0x003B90 .S......2...z*. T......2 */
                                                  1068:      .pword      0x07E3F3, 0xEF2A84, 0x07FC66, 0x78054F, 0xBE044F, 0x060000, 0xEA8000, 0xEA8081  /* 0x003BA0 ....*.f..O.xO........... */
                                                  1069:      .pword      0x200085, 0x283206, 0x2EDB87, 0x370010, 0x785AB2, 0x7852B2, 0x680004, 0x200084  /* 0x003BB0 .. .2(.....7.Zx.Rx..h..  */
                                                  1070:      .pword      0xD10081, 0xD38000, 0x390002, 0x680006, 0x688087, 0xD10081, 0xD38000, 0x390002  /* 0x003BC0 ........9..h..h........9 */
                                                  1071:      .pword      0x680006, 0x688087, 0xE90204, 0x3AFFF4, 0x5181E2, 0x3BFFEE, 0x4181E2, 0x320004  /* 0x003BD0 ..h..h.....:..Q..;..A..2 */
                                                  1072:      .pword      0x684012, 0x200044, 0x200003, 0x37FFEC, 0xEA8000, 0xEA8081, 0x060000, 0xFA0004  /* 0x003BE0 .@hD. .. ..7............ */
                                                  1073:      .pword      0x781F88, 0xBE9F8A, 0xBE0300, 0x9FBFB0, 0x9FBFC1, 0x780402, 0xBE0504, 0xEB0000  /* 0x003BF0 ..x..............x...... */
                                                  1074:      .pword      0x530FE0, 0x5B8FE0, 0x3A000B, 0x37000F, 0x57806A, 0x024128, 0x000000, 0x550F80  /* 0x003C00 ..S..[..:..7j.W(A......U */
                                                  1075:      .pword      0x5D8F81, 0x390003, 0x550F82, 0x5D8F83, 0x390005, 0x540464, 0xE00008, 0x3AFFF4  /* 0x003C10 ..]..9..U..]..9d.T.....: */
                                                  1076:      .pword      0xEB0000, 0x370001, 0x200010, 0xBE054F, 0x78044F, 0xFA8000, 0x060000, 0xBE9F88  /* 0x003C20 .....7.. O..O.x......... */
                                                  1077:      .pword      0xBE9F8A, 0xBE0400, 0x784582, 0x784503, 0xEB0C80, 0xBE0008, 0x07FA77, 0x200161  /* 0x003C30 .......Ex.Ex......w..a.  */
                                                  1078:      .pword      0xE00000, 0x3A000E, 0xB82260, 0xE0040A, 0x320007, 0x780008, 0x07F91E, 0xBE0200  /* 0x003C40 .....:`"......2..x...... */
                                                  1079:      .pword      0x900848, 0x907080, 0xFB8081, 0x3A0004, 0x78410B, 0xBE0008, 0x07F111, 0x780080  /* 0x003C50 H...p......:.Ax........x */
                                                  1080:      .pword      0x900848, 0x987001, 0x780001, 0xBE054F, 0xBE044F, 0x060000, 0xFA0006, 0x781F88  /* 0x003C60 H...p...xO..O..........x */
                                                  1081:      .pword      0xEB4100, 0x780080, 0x578068, 0x07F253, 0x780400, 0xEB8000, 0xE00008, 0x320012  /* 0x003C70 .A...xh.WS....x........2 */
                                                  1082:      .pword      0x780008, 0x07E42D, 0xE00000, 0x320007, 0x780088, 0x578068, 0x07F59F, 0x780080  /* 0x003C80 ..x-.......2..xh.W.....x */
                                                  1083:      .pword      0xEB8000, 0xE00001, 0x3A0007, 0x97B86F, 0x887B40, 0x97B84F, 0x97B8DF, 0x887B20  /* 0x003C90 ........:o..@{.O..... {. */
                                                  1084:      .pword      0x887B31, 0xEB0000, 0x78044F, 0xFA8000, 0x060000, 0xE00400, 0x3A0016, 0x8078F3  /* 0x003CA0 1{....O.x...........:.x. */
                                                  1085:      .pword      0xE00003, 0x320019, 0x900113, 0xE00002, 0x32000C, 0x900022, 0xE00000, 0x320006  /* 0x003CB0 .....2........2".......2 */
                                                  1086:      .pword      0x900090, 0xA1B001, 0x980011, 0x780010, 0xE00000, 0x3AFFFA, 0x780112, 0xE00002  /* 0x003CC0 ...........x.....:..x... */
                                                  1087:      .pword      0x3AFFF4, 0x780193, 0xE00003, 0x3AFFEE, 0x370006, 0x070006, 0xE00000, 0x320003  /* 0x003CD0 ..:..x.....:..7........2 */
                                                  1088:      .pword      0x900090, 0xA1B001, 0x980011, 0x060000, 0x784080, 0xE00401, 0x3A0002, 0x807900  /* 0x003CE0 .............@x.....:.y. */
                                                  1089:      .pword      0x370018, 0x8078F3, 0xEB0000, 0xE00003, 0x320014, 0x900023, 0xE00000, 0x32000D  /* 0x003CF0 ..7.x.........2#.......2 */
                                                  1090:      .pword      0x900020, 0xE00000, 0x32000A, 0x905920, 0x514F81, 0x3A0004, 0x37000A, 0x905920  /* 0x003D00  .......2 Y..OQ..:..7 Y. */
                                                  1091:      .pword      0x514F81, 0x320007, 0x780010, 0xE00000, 0x3AFFFA, 0x780193, 0xE00003, 0x3AFFED  /* 0x003D10 .OQ..2..x.....:..x.....: */
                                                  1092:      .pword      0xEB0000, 0x060000, 0xFE0000, 0xAFE761, 0x37FFFE, 0x883B00, 0x8054D7, 0xEF2A9A  /* 0x003D20 .........a....7.;..T..*. */
                                                  1093:      .pword      0xB83B01, 0x213261, 0xB009B7, 0x530081, 0x024352, 0x000000, 0x883B31, 0xEB0080  /* 0x003D30 .;.a2!.....SRC....1;.... */
                                                  1094:      .pword      0x883B37, 0xA8E761, 0x000000, 0x000000, 0xA60002, 0x024368, 0x000000, 0xEB0380  /* 0x003D40 7;.a...........hC....... */
                                                  1095:      .pword      0xA30802, 0xAFE761, 0x3AFFFE, 0xA9C761, 0xA70002, 0x024368, 0x000000, 0x060000  /* 0x003D50 ...a....:a.....hC....... */
                                                  1096:      .pword      0x807913, 0xB3CDD2, 0xA30803, 0x3A0001, 0xB3C5D2, 0x805413, 0x900A53, 0xB23004  /* 0x003D60 .y.........:....T.S...0. */
                                                  1097:      .pword      0x3A0001, 0xA14402, 0x900A53, 0xB23004, 0x201003, 0x520F83, 0x3A0001, 0xA10402  /* 0x003D70 ..:.D.S...0... ..R..:... */
                                                  1098:      .pword      0xFB8102, 0x882552, 0x20F142, 0xFB8112, 0x8824B2, 0xFB8081, 0xDD08C4, 0xB207F0  /* 0x003D80 ...R%.B. ....$.......... */
                                                  1099:      .pword      0x700001, 0x8824F0, 0xA88A58, 0x060000, 0x2006A2, 0x508F82, 0x3C0007, 0x200690  /* 0x003D90 ..p.$.X....... ..P..<..  */
                                                  1100:      .pword      0x508F80, 0x3D000E, 0x500064, 0x508F80, 0x3A0010, 0x37000A, 0x2006C2, 0x508F82  /* 0x003DA0 ..P..=d.P..P..:..7.. ..P */
                                                  1101:      .pword      0x35000C, 0x410164, 0x508F82, 0x340004, 0x201F82, 0x508F82, 0x3A0006, 0x370002  /* 0x003DB0 ..5d.A..P..4.. ..P..:..7 */
                                                  1102:      .pword      0xB3C010, 0x370004, 0xB7EA90, 0xEB4000, 0x370001, 0xEB4000, 0x060000, 0x2440A0  /* 0x003DC0 .....7....@...7.@.....@$ */
                                                  1103:      .pword      0x200001, 0x50016A, 0x5881E0, 0x32000A, 0x0242C8, 0x000000, 0xDE0048, 0xDD08C8  /* 0x003DD0 .. j.P..X..2.B....H..... */
                                                  1104:      .pword      0x700001, 0x212CD2, 0x510000, 0xAE2042, 0x050000, 0x050010, 0x200000, 0x200001  /* 0x003DE0 ..p.,!..QB ......... ..  */
                                                  1105:      .pword      0xA06001, 0x0242C8, 0x000000, 0xDE014C, 0xDD09C4, 0x710103, 0xEA8000, 0x20FFF4  /* 0x003DF0 .`..B....L.......q.....  */
                                                  1106:      .pword      0x600004, 0x37FFF0, 0x805410, 0x900090, 0xA16001, 0x980011, 0x805410, 0x900090  /* 0x003E00 ..`..7.T.....`.....T.... */
                                                  1107:      .pword      0xA15001, 0x980011, 0xED4A86, 0xB7EA86, 0x320003, 0x2FFF00, 0xB62A80, 0x37000B  /* 0x003E10 .P.....J......2../.*...7 */
                                                  1108:      .pword      0xED4A88, 0xB7EA88, 0x320003, 0x201100, 0x885400, 0x370005, 0xB3C071, 0x20F160  /* 0x003E20 .J......2.. .T...7q..`.  */
                                                  1109:      .pword      0x784801, 0x205000, 0x885400, 0x060000, 0x807900, 0xE00000, 0x3A0009, 0x200220  /* 0x003E30 .Hx.P .T.....y......: .  */
                                                  1110:      .pword      0x07E308, 0x780080, 0x887901, 0xEB4000, 0xE00001, 0x32000E, 0xEB0880, 0x370001  /* 0x003E40 .....x.y..@......2.....7 */
                                                  1111:      .pword      0x07FE8B, 0x807900, 0x885410, 0xEF2A80, 0xEFAA7C, 0xEB4000, 0x20F141, 0x784880  /* 0x003E50 ....y..T..*.|...@.A. .Hx */
                                                  1112:      .pword      0xE80081, 0x784880, 0xA80A8A, 0xB3C010, 0x060000, 0xFA0002, 0xEF2488, 0x20F150  /* 0x003E60 ....Hx.............$.P.  */
                                                  1113:      .pword      0x784010, 0xE00400, 0x32000F, 0xEB4080, 0x9FFFE1, 0x8078D1, 0x9FFFF1, 0x200024  /* 0x003E70 .@x.....2.@.....x....$.  */
                                                  1114:      .pword      0x200005, 0xE9810F, 0x2006A1, 0x07FF88, 0x20F150, 0x200013, 0x780100, 0x200711  /* 0x003E80 .. ..... ...P. .. ..x..  */
                                                  1115:      .pword      0x784010, 0x07F843, 0xB80060, 0x07FFD0, 0xFA8000, 0x060000, 0xFA0004, 0x781F88  /* 0x003E90 .@xC..`................x */
                                                  1116:      .pword      0x780400, 0x8054D0, 0x500065, 0x9FBFE0, 0xEF2A9A, 0xEB0000, 0x9FBFD0, 0xE00008  /* 0x003EA0 ..x.T.e.P....*.......... */
                                                  1117:      .pword      0x320001, 0xFE6000, 0x8054D1, 0x97B86F, 0x408000, 0x400065, 0x8854D0, 0x578066  /* 0x003EB0 ..2.`..T.o....@e.@.T.f.W */
                                                  1118:      .pword      0x021F60, 0x000000, 0xE00000, 0x3AFFF3, 0x78044F, 0xFA8000, 0x060000, 0xB3C010  /* 0x003EC0 `..........:O.x......... */
                                                  1119:      .pword      0xB7EA74, 0x20AA40, 0x8877F0, 0x20CA40, 0x887800, 0x20F341, 0x887811, 0xEB0000  /* 0x003ED0 t..@. .w.@. .x.A. .x.... */
                                                  1120:      .pword      0x8879F0, 0x408168, 0x2FFFC3, 0x618912, 0xEB8100, 0xEB8180, 0xBE8882, 0x8879C2  /* 0x003EE0 .y.h.@../..a..........y. */
                                                  1121:      .pword      0x8879D3, 0x887B40, 0xB80060, 0x887B20, 0x887B31, 0x200010, 0x060000, 0xA8A744  /* 0x003EF0 .y.@{.`.. {.1{... ...D.. */
                                                  1122:      .pword      0x202580, 0xE90000, 0x400FE1, 0x3AFFFD, 0x224000, 0x200F41, 0x885380, 0x885391  /* 0x003F00 .% .....@..:.@"A. .S..S. */
                                                  1123:      .pword      0x885380, 0x885391, 0x23E800, 0x885360, 0xEF2A6E, 0x200100, 0x8854F0, 0x07004C  /* 0x003F10 .S..S...#`S.n*... .T.L.. */
                                                  1124:      .pword      0xEB0000, 0x0701EF, 0xA902C0, 0xA922C0, 0xA8A2C8, 0x070110, 0x060000, 0x781F88  /* 0x003F20 .........."............x */
                                                  1125:      .pword      0x780400, 0xEB0080, 0x780008, 0x07F637, 0x784080, 0x200090, 0xE00401, 0x32000C  /* 0x003F30 ..x.....x7...@x.. .....2 */
                                                  1126:      .pword      0x9011B8, 0x901088, 0x901128, 0x901048, 0x900243, 0xBE0112, 0x010004, 0x784080  /* 0x003F40 ......(..H..C.........@x */
                                                  1127:      .pword      0xEB0000, 0xE00401, 0x3A0001, 0x200080, 0x78044F, 0x060000, 0xBE9F88, 0x780482  /* 0x003F50 ........:.. O.x........x */
                                                  1128:      .pword      0x780403, 0xB3C062, 0x20F153, 0x104F93, 0x3A000D, 0x784001, 0x07FEBD, 0xB3C142  /* 0x003F60 ..xb..S. .O...:.@x...B.. */
                                                  1129:      .pword      0xE00000, 0x320008, 0x6484E1, 0xDD48CD, 0x900490, 0xA1D009, 0x708489, 0x980019  /* 0x003F70 .....2..d.H.........p... */
                                                  1130:      .pword      0x981008, 0xEB4100, 0x784002, 0xBE044F, 0x060000, 0x781F88, 0x200018, 0xE20F76  /* 0x003F80 ....A..@xO.......x.. v.. */
                                                  1131:      .pword      0x320010, 0x805495, 0xE00005, 0x32000D, 0x010005, 0x780400, 0xE00008, 0x340009  /* 0x003F90 ..2.T......2.....x.....4 */
                                                  1132:      .pword      0x200940, 0x200A42, 0x510100, 0xEB0080, 0x0701CB, 0xEF2A68, 0xEF2A6A, 0x070173  /* 0x003FA0 @. B. ..Q......h*.j*.s.. */
                                                  1133:      .pword      0xA8C09E, 0x780008, 0x78044F, 0x060000, 0xEB0000, 0x887BC0, 0x20F400, 0x887A30  /* 0x003FB0 .....xO.x.......{... 0z. */
                                                  1134:      .pword      0x201000, 0x8854E0, 0x20AA00, 0xE00000, 0x320002, 0xEF2AA0, 0xEF6AA2, 0x200040  /* 0x003FC0 .. .T... .....2.*..j.@.  */
                                                  1135:      .pword      0x880820, 0xEFA102, 0x200021, 0xDD0880, 0xBFC0A5, 0x60406F, 0x704001, 0xB7E0A5  /* 0x003FD0  .....!. ......o@`.@p... */
                                                  1136:      .pword      0xA86094, 0xA8E105, 0x060000, 0xEB0100, 0xB82260, 0xE00001, 0x320011, 0xE91FB1  /* 0x003FE0 .`..........`"......2... */
                                                  1137:      .pword      0x33000E, 0x20FFF3, 0x780331, 0xDE33CC, 0x630303, 0x430302, 0xA5A800, 0xA53816  /* 0x003FF0 ..3.. 1.x.3...c..C....8. */
                                                  1138:      .pword      0xAD2804, 0xAA0042, 0xAE2042, 0xAD3816, 0xE80285, 0xE91FCF, 0x3BFFF3, 0xE9878F  /* 0x004000 .(.B..B ..8.........;... */
                                                  1139:      .pword      0x780004, 0x060000, 0xFE0000, 0xAFE761, 0x37FFFE, 0x800192, 0x880191, 0xBB0803  /* 0x004010 ..x......a....7......... */
                                                  1140:      .pword      0x880192, 0x880000, 0x880001, 0x240420, 0xA8C760, 0xAEC760, 0xB28410, 0xEB0100  /* 0x004020 ......... .$`..`........ */
                                                  1141:      .pword      0x203E51, 0x023D26, 0x000000, 0xAFE761, 0x37FFFE, 0xA9C761, 0x060000, 0xBE9F88  /* 0x004030 Q> &=....a....7a........ */
                                                  1142:      .pword      0xBE9F8A, 0xBE0400, 0x024066, 0x000000, 0xBE0500, 0xEB0180, 0xE00003, 0xAE2042  /* 0x004040 ......f@.............B . */
                                                  1143:      .pword      0xFE4001, 0x024066, 0x000000, 0x50020A, 0x58828B, 0x540104, 0x5C8185, 0x31FFF6  /* 0x004050 .@.f@......P..X..T..\..1 */
                                                  1144:      .pword      0xBE054F, 0xBE044F, 0x060000, 0x8054E7, 0xEB0300, 0x20F465, 0x807BC0, 0x780215  /* 0x004060 O..O......T....e. .{...x */
                                                  1145:      .pword      0x100017, 0x1B00B4, 0x1B0134, 0x1B0194, 0x520264, 0xE12015, 0x3AFFF7, 0x200844  /* 0x004070 ......4.....d.R. ...:D.  */
                                                  1146:      .pword      0xB00004, 0xA63014, 0x060000, 0x2408E0, 0x024334, 0x000000, 0x37FFEC, 0x781F81  /* 0x004080 ....0......$4C......7..x */
                                                  1147:      .pword      0xBE9F82, 0xEB0180, 0x807A31, 0x688168, 0xE81931, 0x499931, 0x498911, 0x510164  /* 0x004090 ......1z.h.h1..1.I..Id.Q */
                                                  1148:      .pword      0x887A32, 0x200841, 0xB00001, 0xA13011, 0x232301, 0xE00001, 0xAE2042, 0x014001  /* 0x0040A0 2z.A. ....0..##...B ..@. */
                                                  1149:      .pword      0xBE014F, 0x7800CF, 0x064000, 0x780100, 0x784092, 0xEB8000, 0xE00401, 0x32000D  /* 0x0040B0 O....x.@...x.@x........2 */
                                                  1150:      .pword      0xEB0000, 0xB3C2F3, 0x50CF83, 0x320009, 0xE80102, 0x7840B2, 0xE00401, 0x320004  /* 0x0040C0 ........P..2....@x.....2 */
                                                  1151:      .pword      0xE80000, 0x50CF83, 0x3AFFFA, 0x370001, 0xEB8000, 0x060000, 0x800192, 0x880191  /* 0x0040D0 .....P..:..7............ */
                                                  1152:      .pword      0x203FF3, 0xEA8083, 0x608000, 0xEB8200, 0xAFE761, 0x37FFFE, 0xBAC210, 0xBA00B0  /* 0x0040E0 .? .....`...a....7...... */
                                                  1153:      .pword      0x620201, 0xEA8084, 0x3A0004, 0xE98183, 0x31FFF9, 0x880192, 0x050010, 0x880192  /* 0x0040F0 ..b.....:.....1......... */
                                                  1154:      .pword      0x050000, 0xB3C062, 0x20F153, 0x104F93, 0x3A000C, 0x784001, 0x07FDED, 0xB3C142  /* 0x004100 ...b..S. .O...:.@x...B.. */
                                                  1155:      .pword      0xE00000, 0x320007, 0x900090, 0xA15001, 0x980011, 0x900090, 0xA16001, 0x980011  /* 0x004110 .....2....P........`.... */
                                                  1156:      .pword      0xEB4100, 0x784002, 0x060000, 0xFFFFFF, 0x780230, 0x7802A0, 0x800197, 0x421864  /* 0x004120 .A..@x......0.x..x...d.B */
                                                  1157:      .pword      0x4A8860, 0x880195, 0xE88304, 0x4A82E0, 0xAFE761, 0x37FFFE, 0xBA0014, 0xBA8094  /* 0x004130 `.J........Ja....7...... */
                                                  1158:      .pword      0x880195, 0xBA0116, 0xBA8196, 0x880197, 0x060000, 0x000000, 0x781F88, 0x807B78  /* 0x004140 ....................xx{. */
                                                  1159:      .pword      0x024216, 0x000000, 0x680408, 0x887B88, 0x807B70, 0xEA8080, 0x640081, 0x887B91  /* 0x004150 .B......h.{.p{......d.{. */
                                                  1160:      .pword      0x640080, 0x887BA1, 0x6C0000, 0x887B70, 0x78044F, 0x060000, 0xE90202, 0x390005  /* 0x004160 ..d.{...lp{.O.x........9 */
                                                  1161:      .pword      0x700181, 0xA60003, 0x370003, 0x098004, 0x785831, 0x060000, 0xD10182, 0xE90183  /* 0x004170 ..p.....7...1Xx......... */
                                                  1162:      .pword      0x390003, 0x098003, 0x781831, 0xA70002, 0x785831, 0x060000, 0x781F88, 0x07FEB7  /* 0x004180 ..9...1.x...1Xx.....x... */
                                                  1163:      .pword      0x07FE9E, 0x242F40, 0x0700EC, 0xB80060, 0x07FE4F, 0xEB0400, 0xFE6000, 0x071F5A  /* 0x004190 ...@/$...`..O......`.Z.. */
                                                  1164:      .pword      0x07237D, 0x780008, 0x07E8CE, 0xFE4001, 0x37FFF9, 0x780080, 0x900921, 0x9009B1  /* 0x0041A0 }#...x....@...7..x!..... */
                                                  1165:      .pword      0x900801, 0x900891, 0x690000, 0x698081, 0x708000, 0x780080, 0xA7F001, 0xEA0081  /* 0x0041B0 ........i..i..p..x...... */
                                                  1166:      .pword      0xE90081, 0xDE084F, 0x060000, 0xFA0002, 0x780180, 0x200012, 0x200011, 0xE9800F  /* 0x0041C0 ...O..........x.. .. ... */
                                                  1167:      .pword      0x07E46C, 0x780080, 0xEB8000, 0x508FE1, 0x3A0002, 0x97F8EF, 0xFB0001, 0xFA8000  /* 0x0041D0 l....x.....P..:......... */
                                                  1168:      .pword      0x060000, 0xFA0002, 0x9FFFE0, 0x780181, 0x200012, 0x200011, 0xE9800F, 0x07E5AF  /* 0x0041E0 ...........x.. .. ...... */
                                                  1169:      .pword      0x780080, 0xEB0000, 0x508FE1, 0x320001, 0xEB8000, 0xFA8000, 0x060000, 0x400081  /* 0x0041F0 ..x.....P..2...........@ */
                                                  1170:      .pword      0x904211, 0xDD2248, 0xFB8011, 0x700104, 0x904231, 0xDD2248, 0x904021, 0xFB8000  /* 0x004200 .B.H"......p1B.H".!@.... */
                                                  1171:      .pword      0x700184, 0xBE0002, 0x060000, 0x781F88, 0x280241, 0x780011, 0x200018, 0xDD4400  /* 0x004210 ..p........xA.(..x.. .D. */
                                                  1172:      .pword      0xE90408, 0xEB0000, 0x023FE6, 0x000000, 0x680008, 0x78044F, 0x060000, 0x784080  /* 0x004220 .......?......hO.x....@x */
                                                  1173:      .pword      0xEB0000, 0xE24A74, 0x3A0006, 0x20EDE0, 0x200312, 0x410100, 0x10CF92, 0x320001  /* 0x004230 ...tJ...:.. .. ..A.....2 */
                                                  1174:      .pword      0xEB0000, 0x060000, 0x20AA01, 0x370001, 0x780082, 0x780111, 0xE00002, 0x320004  /* 0x004240 ........ ..7..x..x.....2 */
                                                  1175:      .pword      0x510F80, 0x3AFFFA, 0x780890, 0x050010, 0x050000, 0x781F88, 0x780400, 0x780008  /* 0x004250 ..Q..:..x........x..x..x */
                                                  1176:      .pword      0x07EFC9, 0x901898, 0xA11001, 0xA10001, 0x981C11, 0x78044F, 0x060000, 0x07FDAF  /* 0x004260 ...............O.x...... */
                                                  1177:      .pword      0xE00000, 0x320006, 0xFC0102, 0x20F760, 0xEB8800, 0x02440C, 0x000000, 0xFE0000  /* 0x004270 .....2...`. ....D....... */
                                                  1178:      .pword      0x060000, 0x7841B0, 0x51C1B1, 0x3A0003, 0xE90102, 0x31FFFB, 0x050000, 0xEB8000  /* 0x004280 ....Ax..Q..:.....1...... */
                                                  1179:      .pword      0xAF0042, 0x050010, 0x060000, 0x20A9C0, 0xE00000, 0x320004, 0x200940, 0xB00000  /* 0x004290 B.......... .....2@. ... */
                                                  1180:      .pword      0xA43010, 0xAE0042, 0x050000, 0x050010, 0x07FFC2, 0x780080, 0xEB0000, 0xE00001  /* 0x0042A0 .0.B.............x...... */
                                                  1181:      .pword      0x320002, 0x906861, 0xFB8000, 0x060000, 0x07FFBA, 0x780080, 0x2000B0, 0xE00001  /* 0x0042B0 ..2ah............x.. ... */
                                                  1182:      .pword      0x320002, 0x907001, 0xFB8000, 0x060000, 0x800192, 0x880191, 0xAFE761, 0x37FFFE  /* 0x0042C0 ..2.p.............a....7 */
                                                  1183:      .pword      0xBA8090, 0xBA0010, 0x880192, 0x060000, 0x8052E0, 0x8052F1, 0x400161, 0x4881E0  /* 0x0042D0 .............R..R.a.@..H */
                                                  1184:      .pword      0x8852E2, 0x8852F3, 0x060000, 0x784010, 0x07FA75, 0xB2C520, 0xFB8000, 0xE90000  /* 0x0042E0 .R..R.....@xu.. ........ */
                                                  1185:      .pword      0xDE004F, 0x060000, 0x250BC1, 0x780801, 0x2A6151, 0x980011, 0xEB4080, 0x984041  /* 0x0042F0 O.......%..xQa*....@.A@. */
                                                  1186:      .pword      0x060000, 0x781F80, 0xEB0000, 0x024362, 0x000000, 0x68004F, 0x044362, 0x000000  /* 0x004300 .....x...bC....O.hbC.... */
                                                  1187:      .pword      0x9008C0, 0xEB4100, 0x987082, 0x9008B0, 0x900820, 0x060000, 0x07FF88, 0xE00000  /* 0x004310 ....A..p.... ........... */
                                                  1188:      .pword      0x320002, 0xEB4080, 0x987001, 0x060000, 0x400001, 0x904110, 0xDD1148, 0xFB8090  /* 0x004320 ..2.@..p......@.A.H..... */
                                                  1189:      .pword      0x708002, 0x060000, 0x800211, 0xDD08C8, 0xAF6044, 0xA07001, 0x709FCF, 0x014000  /* 0x004330 ..p.........D`..p...p.@. */
                                                  1190:      .pword      0xE90102, 0x390002, 0x098002, 0x785801, 0x060000, 0x900110, 0x780001, 0x010002  /* 0x004340 .....9....Xx........x... */
                                                  1191:      .pword      0x060000, 0x200800, 0x701FCF, 0x800210, 0x064000, 0xB80063, 0xD10081, 0xD38000  /* 0x004350 ..... ..p....@.c........ */
                                                  1192:      .pword      0x060000, 0x2801E1, 0x043FE6, 0x000000, 0xDD0048, 0x701FCF, 0x064000, 0x8853B0  /* 0x004360 .....(.?....H....p.@..S. */
                                                  1193:      .pword      0x060000, 0xB3C010, 0x060000, 0xB3C010, 0x060000, 0xEB4000, 0x060000, 0xFFFFFF  /* 0x004370 ................@....... */
                                                  1194:      .pword      0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF  /* 0x004380 ........................ */
                                                  1195:      .pword      0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF  /* 0x004390 ........................ */
                                                  1196:      .pword      0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF  /* 0x0043A0 ........................ */
                                                  1197:      .pword      0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF  /* 0x0043B0 ........................ */
                                                  1198:      .pword      0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF  /* 0x0043C0 ........................ */
                                                  1199:      .pword      0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF  /* 0x0043D0 ........................ */
                                                  1200:      .pword      0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF  /* 0x0043E0 ........................ */
                                                  1201:      .pword      0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF  /* 0x0043F0 ........................ */
                                                  1202:      .popsection
                                                  1203:  
                                                  1204:      ; Bootloader code block intended for program region 'program'
                                                  1205:      ; 0x008000 to 0x00A000, length 0x002000 (12288 bytes; needs 7 pages)
                                                  1206:      .pushsection    EZBL_ROM_AT_0x008000, address(0x008000), code, keep
                                                  1207:      .pword      0x002E2E, 0x002100, 0x002423, 0x002625, 0x002827, 0x002D29, 0x005E40, 0x00605F  /* 0x008000 ....!.#$.%&.'(.)-.@^._`. */
                                                  1208:      .pword      0x007D7B, 0x00207E, 0x002F5C, 0x002A3A, 0x00223F, 0x003E3C, 0x00007C, 0x000002  /* 0x008010 {}.~ .\/.:*.?".<>.|..... */
                                                  1209:      .pword      0x0012C4, 0x0002C4, 0x000001, 0x0052CA, 0x004946, 0x004D52, 0x004157, 0x004552  /* 0x008020 ..........R.FI.RM.WA.RE. */
                                                  1210:      .pword      0x00422E, 0x00324C, 0x000000, 0x000000, 0x0042E6, 0x00051C, 0x004376, 0x002A68  /* 0x008030 .B.L2........B....vC.h*. */
                                                  1211:      .pword      0x002668, 0x00437A, 0x00F88A, 0x00869C, 0x006779, 0x009314, 0x006801, 0x0008A0  /* 0x008040 h&.zC.......yg.....h.... */
                                                  1212:      .pword      0x000C9D, 0x00491B, 0xFA0002, 0xBE9F88, 0xBE9F8A, 0xBE9F8C, 0x8053E0, 0x400FE1  /* 0x008050 ....I..............S...@ */
                                                  1213:      .pword      0x320003, 0xF80A7C, 0xF90A80, 0xEFAA7C, 0x20F000, 0xB60A80, 0x202001, 0x500F81  /* 0x008060 ..2|.....|.... ....  ..P */
                                                  1214:      .pword      0x3201A6, 0x3E0006, 0xE00000, 0x32000E, 0x201001, 0x500F81, 0x3A040A, 0x370089  /* 0x008070 ..2..>.....2.. ..P..:..7 */
                                                  1215:      .pword      0x204001, 0x500F81, 0x3203B3, 0xB01001, 0x500F81, 0x3203D0, 0x203001, 0x500F81  /* 0x008080 .@ ..P..2.....P..2.0 ..P */
                                                  1216:      .pword      0x3A0400, 0x3701CE, 0x200F00, 0xB60A80, 0x500FF0, 0x320056, 0x200201, 0x500F81  /* 0x008090 ..:..7.. .....PV.2.. ..P */
                                                  1217:      .pword      0x32005A, 0xE00000, 0x3A03F6, 0x07DEE1, 0xEB0080, 0x807900, 0x780801, 0x20F200  /* 0x0080A0 Z.2.....:.......y...x..  */
                                                  1218:      .pword      0x780110, 0x980111, 0x780110, 0x900192, 0xA0A003, 0x980113, 0x780110, 0x900192  /* 0x0080B0 ..x.....x...........x... */
                                                  1219:      .pword      0xA09003, 0x980113, 0x780110, 0x900192, 0xA0D003, 0x980113, 0x780110, 0x200C83  /* 0x0080C0 ........x...........x..  */
                                                  1220:      .pword      0x981103, 0x200403, 0x980143, 0x780110, 0xB82260, 0x980904, 0x980915, 0x780010  /* 0x0080D0 ..... C....x`".........x */
                                                  1221:      .pword      0xEB4100, 0x985821, 0x985802, 0x900A50, 0x2FCFF3, 0x620183, 0x980853, 0xEBC180  /* 0x0080E0 .A.!X..X.P..../..bS..... */
                                                  1222:      .pword      0x985813, 0xB3C030, 0xB7EA88, 0x20F120, 0x784802, 0xE80000, 0x784802, 0xE80000  /* 0x0080F0 .X.0..... . .Hx....Hx... */
                                                  1223:      .pword      0x784802, 0x887911, 0x8878F1, 0xEF2A58, 0xEF248C, 0x200FF0, 0x882450, 0x2008C1  /* 0x008100 .Hx.y..x.X*..$... P$...  */
                                                  1224:      .pword      0x204825, 0x608A95, 0x5080EF, 0x882401, 0xEF2490, 0x882470, 0x210000, 0xDE0048  /* 0x008110 %H ..`..P.$..$.p$...!H.. */
                                                  1225:      .pword      0x8824C0, 0x200080, 0x8824A0, 0x2000A1, 0x8824A1, 0x8824A0, 0x200300, 0x882430  /* 0x008120 .$... .$... .$..$... 0$. */
                                                  1226:      .pword      0x200020, 0x882530, 0xEF24A8, 0xEF2496, 0xA9E4AA, 0x2004A0, 0x882500, 0x20FF00  /* 0x008130  . 0%..$..$...... .%...  */
                                                  1227:      .pword      0xB60A80, 0x400070, 0x885400, 0x3703A5, 0xAB0A8A, 0x3203A3, 0x20FF00, 0xB60A80  /* 0x008140 ...p.@.T...7.....2.. ... */
                                                  1228:      .pword      0x400070, 0x885400, 0x37039E, 0xEB4000, 0x9FF7A0, 0xB3C320, 0x9FF7B0, 0x200024  /* 0x008150 p.@.T...7.@.... .....$.  */
                                                  1229:      .pword      0x200005, 0x57816E, 0x200691, 0xEBC000, 0x07DE17, 0xE00400, 0x32000E, 0x200010  /* 0x008160 .. n.W.. ...........2..  */
                                                  1230:      .pword      0x882440, 0xA9C08E, 0x2F0FF0, 0xB620CE, 0x206000, 0xB720CE, 0xA8C09E, 0x20FF00  /* 0x008170 @$....../. ..` . ......  */
                                                  1231:      .pword      0xB60A80, 0x400070, 0x885400, 0xA8C48C, 0x370384, 0xA90A8A, 0x200100, 0x885400  /* 0x008180 ...p.@.T......7..... .T. */
                                                  1232:      .pword      0x370380, 0x200F00, 0xB60A80, 0x200201, 0x500F81, 0x32007C, 0x3E0005, 0xE00000  /* 0x008190 ..7.. ..... ..P|.2..>... */
                                                  1233:      .pword      0x32000A, 0x500FF0, 0x3A0376, 0x37001C, 0x200301, 0x500F81, 0x3200D0, 0x4080F0  /* 0x0081A0 ..2..Pv.:..7.. ..P..2..@ */
                                                  1234:      .pword      0x500F81, 0x3A036F, 0x3700FE, 0x805400, 0x60006F, 0x320003, 0x500FE2, 0x3A0369  /* 0x0081B0 ..Po.:..7.T.o.`..2..Pi.: */
                                                  1235:      .pword      0x37000A, 0x200010, 0x882450, 0xA8048C, 0x200FB0, 0x8853F0, 0x200400, 0x882400  /* 0x0081C0 ..7.. P$...... .S... .$. */
                                                  1236:      .pword      0xA8C482, 0xEC2A80, 0x37035E, 0x20FF00, 0xB60A80, 0x400070, 0x885400, 0x370359  /* 0x0081D0 ....*.^.7.. ...p.@.T.Y.7 */
                                                  1237:      .pword      0x805400, 0x60006F, 0x500FE2, 0x320044, 0x500FE4, 0x32004B, 0xE00000, 0x3A0351  /* 0x0081E0 .T.o.`..PD.2..PK.2...Q.: */
                                                  1238:      .pword      0x805420, 0xE00000, 0x320001, 0x07C0C8, 0x200080, 0x07C12B, 0x885420, 0xE00000  /* 0x0081F0  T......2..... +.. T.... */
                                                  1239:      .pword      0x3A0006, 0xB3C331, 0x20F160, 0x784801, 0x205000, 0x885400, 0x370342, 0xEB4000  /* 0x008200 ..:1..`. .Hx.P .T.B.7.@. */
                                                  1240:      .pword      0x20F121, 0x784880, 0xE80081, 0x784880, 0x40806F, 0xEB0800, 0xB3C030, 0xB7EA86  /* 0x008210 !. .Hx....Hxo.@...0..... */
                                                  1241:      .pword      0x2000D0, 0x882550, 0xEF24AC, 0xEF24AE, 0xEF24B0, 0xEF24B2, 0xEF24B4, 0xEF24B6  /* 0x008220 .. P%..$..$..$..$..$..$. */
                                                  1242:      .pword      0xEF24B8, 0xEF24BA, 0xEF24BC, 0xEF24BE, 0xEF24C0, 0xEF24C2, 0xEF24C4, 0xEF24C6  /* 0x008230 .$..$..$..$..$..$..$..$. */
                                                  1243:      .pword      0xEF24C8, 0xABE494, 0x3A0008, 0x40806F, 0xA00010, 0xB3C801, 0x50006E, 0x784801  /* 0x008240 .$......:o.@......n.P.Hx */
                                                  1244:      .pword      0x200800, 0x8824B0, 0xA8E4AA, 0xA82494, 0xA92494, 0x20F220, 0xA14010, 0xA15010  /* 0x008250 .. .$.....$..$. . .@..P. */
                                                  1245:      .pword      0xA88494, 0x200330, 0x8853F0, 0x40006D, 0x882400, 0xA8C482, 0xEC2A80, 0x370311  /* 0x008260 ...0. .S.m.@.$.....*...7 */
                                                  1246:      .pword      0xA98494, 0xA80494, 0x2000B0, 0x8853F0, 0x200400, 0x882400, 0xA8C482, 0xEC2A80  /* 0x008270 ........ .S... .$.....*. */
                                                  1247:      .pword      0x370308, 0x2000F0, 0x882460, 0x200FF0, 0x882480, 0x20FF00, 0xB60A80, 0x400070  /* 0x008280 ..7.. `$... .$... ...p.@ */
                                                  1248:      .pword      0x885400, 0x3702FF, 0x805400, 0x60006F, 0x500FE1, 0x32001E, 0x390003, 0x500FE2  /* 0x008290 .T...7.T.o.`..P..2..9..P */
                                                  1249:      .pword      0x3A02F8, 0x37002F, 0x8053D0, 0xE00000, 0x320002, 0x07C06E, 0xEF2A7A, 0x805421  /* 0x0082A0 ..:/.7.S......2n..z*.!T. */
                                                  1250:      .pword      0xB3C800, 0x784880, 0xB3C060, 0x984090, 0xEB4000, 0x9840A0, 0xB3C012, 0x9840B2  /* 0x0082B0 ....Hx`...@..@..@.....@. */
                                                  1251:      .pword      0x9840C0, 0x9840D0, 0xB3C082, 0x9840E2, 0x9840F0, 0x200084, 0x780181, 0x780104  /* 0x0082C0 .@..@.....@..@... ..x..x */
                                                  1252:      .pword      0x807900, 0x07DBBD, 0xEC2A80, 0x3702DD, 0x807900, 0x900090, 0xA39801, 0x3202D9  /* 0x0082D0 .y.....*...7.y.........2 */
                                                  1253:      .pword      0x900010, 0xA38800, 0x32000C, 0x805420, 0x904040, 0x504FE9, 0x3A0006, 0xB3C351  /* 0x0082E0 ........2 T.@@..OP..:Q.. */
                                                  1254:      .pword      0x20F160, 0x784801, 0x205000, 0x885400, 0x3702CC, 0xEC2A80, 0x3702CA, 0x07DD82  /* 0x0082F0 `. .Hx.P .T...7.*...7... */
                                                  1255:      .pword      0x3702C8, 0x805428, 0xFB8018, 0x07C0A5, 0x8853D0, 0xE00000, 0x3A0006, 0xB3C331  /* 0x008300 ..7(T........S......:1.. */
                                                  1256:      .pword      0x20F160, 0x784801, 0x205000, 0x885400, 0x3702BC, 0x784818, 0x9040F8, 0xFB8081  /* 0x008310 `. .Hx.P .T...7.Hx.@.... */
                                                  1257:      .pword      0x807900, 0x980041, 0x780008, 0x07C030, 0x807900, 0x900040, 0x07C092, 0x885420  /* 0x008320 .y.A....x0...y.@..... T. */
                                                  1258:      .pword      0xE00000, 0x3A0006, 0xB3C331, 0x20F160, 0x784801, 0x205000, 0x885400, 0x3702A9  /* 0x008330 .....:1..`. .Hx.P .T...7 */
                                                  1259:      .pword      0xB3C030, 0xB7EA86, 0x20FF00, 0xB60A80, 0x400070, 0x885400, 0x3702A2, 0x805400  /* 0x008340 0....... ...p.@.T...7.T. */
                                                  1260:      .pword      0x60006F, 0x500FE1, 0x32001C, 0x390003, 0x500FE2, 0x3A029B, 0x370023, 0xAB8A58  /* 0x008350 o.`..P..2..9..P..:#.7X.. */
                                                  1261:      .pword      0x3A0298, 0x805421, 0xB3C800, 0x784880, 0xB3C060, 0x984090, 0xEB4000, 0x9840A0  /* 0x008360 ..:!T.....Hx`...@..@..@. */
                                                  1262:      .pword      0xB3C012, 0x9840B2, 0x9840C0, 0x9840D0, 0x8053D2, 0x784112, 0x9840E2, 0x9840F0  /* 0x008370 ....@..@..@..S..Ax.@..@. */
                                                  1263:      .pword      0x8053D3, 0xFB8213, 0x200082, 0x807900, 0x07DB62, 0xEC2A80, 0x370282, 0x807900  /* 0x008380 .S...... .y.b...*...7.y. */
                                                  1264:      .pword      0x900090, 0xA39801, 0x32027E, 0x900010, 0xA38800, 0x320002, 0xEC2A80, 0x370279  /* 0x008390 ......~.2........2.*.y.7 */
                                                  1265:      .pword      0x07DD31, 0x370277, 0xB3C030, 0xB7EA86, 0x20FF00, 0xB60A80, 0x400070, 0x885400  /* 0x0083A0 1..w.70....... ...p.@.T. */
                                                  1266:      .pword      0x370270, 0x07C9FD, 0x20F000, 0xB60A80, 0xB01000, 0x885400, 0x37026A, 0x200F00  /* 0x0083B0 p.7..... .......T.j.7..  */
                                                  1267:      .pword      0xB60A80, 0x3A0267, 0x805400, 0x60006F, 0x500FE1, 0x32001A, 0x390003, 0x500FE2  /* 0x0083C0 ...g.:.T.o.`..P..2..9..P */
                                                  1268:      .pword      0x3A0260, 0x370021, 0x20F152, 0xB3C010, 0x784900, 0x805421, 0xEB4000, 0x784880  /* 0x0083D0 `.:!.7R. ....Ix!T..@..Hx */
                                                  1269:      .pword      0xB3C053, 0x984093, 0x784112, 0x9840A2, 0x9840B0, 0x9840C0, 0x9840D0, 0x9840E0  /* 0x0083E0 S...@..Ax.@..@..@..@..@. */
                                                  1270:      .pword      0x9840F0, 0xEB0200, 0xEB0180, 0x200082, 0x807900, 0x07DA6B, 0xEC2A80, 0x370249  /* 0x0083F0 .@......... .y.k...*.I.7 */
                                                  1271:      .pword      0x807900, 0x900090, 0xA39801, 0x320245, 0x900010, 0xA38800, 0x320002, 0xEC2A80  /* 0x008400 .y.......E.2........2.*. */
                                                  1272:      .pword      0x370240, 0x07DCF8, 0x37023E, 0x807911, 0x6080E1, 0xDD08C7, 0x20F152, 0xE90002  /* 0x008410 @.7...>.7.y...`...R. ... */
                                                  1273:      .pword      0x70C812, 0xB3C030, 0xB7EA86, 0x20F000, 0xB60A80, 0xB01000, 0x885400, 0x370231  /* 0x008420 ..p0....... .......T.1.7 */
                                                  1274:      .pword      0x200F00, 0xB60A80, 0x200201, 0x500F81, 0x320090, 0x3E0005, 0xE00000, 0x32000D  /* 0x008430 .. ..... ..P..2..>.....2 */
                                                  1275:      .pword      0x500FF0, 0x3A0227, 0x37002D, 0x200401, 0x500F81, 0x320148, 0x4080F0, 0x500F81  /* 0x008440 ..P'.:-.7.. ..PH.2..@..P */
                                                  1276:      .pword      0x320153, 0x200301, 0x500F81, 0x3A021D, 0x3700C0, 0x8053D0, 0x905590, 0x20A8C1  /* 0x008450 S.2.. ..P..:..7.S..U...  */
                                                  1277:      .pword      0x78488B, 0x8078E0, 0xE00000, 0x3A0003, 0x37000E, 0x780008, 0x370002, 0xEB0500  /* 0x008460 .Hx.x......:..7..x..7... */
                                                  1278:      .pword      0x20F1C9, 0x900410, 0x780010, 0x07BF88, 0x8078E0, 0x78080A, 0x780019, 0x07BF84  /* 0x008470 .. .....x....x...x..x... */
                                                  1279:      .pword      0x780C88, 0xE00008, 0x3AFFF2, 0xE0040B, 0x3A0006, 0xB3C391, 0x20F160, 0x784801  /* 0x008480 ..x.....:.....:...`. .Hx */
                                                  1280:      .pword      0x205000, 0x885400, 0x3701FE, 0x20FF00, 0xB60A80, 0x400070, 0x885400, 0x3701F9  /* 0x008490 .P .T...7.. ...p.@.T...7 */
                                                  1281:      .pword      0x805400, 0x60006F, 0x500FE1, 0x32001A, 0x390003, 0x500FE2, 0x3A01F2, 0x370021  /* 0x0084A0 .T.o.`..P..2..9..P..:!.7 */
                                                  1282:      .pword      0x805421, 0xB3C800, 0x784880, 0xB3C060, 0x984090, 0xED4A8C, 0x9840A0, 0xB3C020  /* 0x0084B0 !T.....Hx`...@..J..@. .. */
                                                  1283:      .pword      0x9840B0, 0xEB4000, 0x9840C0, 0x9840D0, 0xB3C082, 0x9840E2, 0x9840F0, 0x200084  /* 0x0084C0 .@..@..@..@.....@..@...  */
                                                  1284:      .pword      0x780181, 0x780104, 0x807900, 0x07DABB, 0xEC2A80, 0x3701DB, 0x807900, 0x900090  /* 0x0084D0 ..x..x.y.....*...7.y.... */
                                                  1285:      .pword      0xA39801, 0x3201D7, 0x900010, 0xA38800, 0x320002, 0xEC2A80, 0x3701D2, 0x07DC8A  /* 0x0084E0 .....2........2.*...7... */
                                                  1286:      .pword      0x3701D0, 0x200060, 0x07BFAE, 0x780400, 0xE00008, 0x3A0006, 0xB3C331, 0x20F160  /* 0x0084F0 ..7`. .....x.....:1..`.  */
                                                  1287:      .pword      0x784801, 0x205000, 0x885400, 0x3701C5, 0x80542B, 0x458563, 0xE8858B, 0xFB809A  /* 0x008500 .Hx.P .T...7+T.c.E...... */
                                                  1288:      .pword      0xDD08C8, 0xFB801B, 0x408000, 0x07BF9D, 0x780C00, 0xE00000, 0x3A0008, 0x780008  /* 0x008510 ........@.....x.....:..x */
                                                  1289:      .pword      0x07BF33, 0xB3C331, 0x20F160, 0x784801, 0x205000, 0x885400, 0x3701B2, 0xFB811A  /* 0x008520 3..1..`. .Hx.P .T...7... */
                                                  1290:      .pword      0xDD1148, 0xFB809B, 0x410081, 0x984021, 0xDE08C8, 0x984031, 0x20F1C1, 0x780211  /* 0x008530 H.......A!@....1@... ..x */
                                                  1291:      .pword      0x980414, 0x780888, 0x8853C0, 0x20A8C5, 0x784295, 0x984445, 0xB3C030, 0xB7EA86  /* 0x008540 .....x.S... .BxED.0..... */
                                                  1292:      .pword      0x20FF00, 0xB60A80, 0x400070, 0x885400, 0x37019C, 0x805400, 0x60006F, 0x500FE1  /* 0x008550 .. ...p.@.T...7.T.o.`..P */
                                                  1293:      .pword      0x320024, 0x390003, 0x500FE2, 0x3A0195, 0x37002B, 0x805421, 0xB3C800, 0x784880  /* 0x008560 $.2..9..P..:+.7!T.....Hx */
                                                  1294:      .pword      0xB3C060, 0x984090, 0xED4A8C, 0x9840A0, 0xB3C020, 0x9840B0, 0xEB4000, 0x9840C0  /* 0x008570 `...@..J..@. ...@..@..@. */
                                                  1295:      .pword      0x9840D0, 0x8078E0, 0x780010, 0x904020, 0x9840E0, 0x8078E0, 0x780010, 0x904030  /* 0x008580 .@..x...x @..@..x...x0@. */
                                                  1296:      .pword      0x9840F0, 0x8078E0, 0x780190, 0x904023, 0xFB8000, 0x904233, 0xDD2248, 0x700204  /* 0x008590 .@..x...x#@....3B.H"...p */
                                                  1297:      .pword      0x200082, 0x807900, 0x07DA54, 0xEC2A80, 0x370174, 0x807900, 0x900090, 0xA39801  /* 0x0085A0 .. .y.T...*.t.7.y....... */
                                                  1298:      .pword      0x320170, 0x900010, 0xA38800, 0x320002, 0xEC2A80, 0x37016B, 0x07DC23, 0x370169  /* 0x0085B0 p.2........2.*.k.7#..i.7 */
                                                  1299:      .pword      0xB3C030, 0xB7EA86, 0xED4A8C, 0xB7EA8C, 0x320003, 0x203100, 0x885400, 0x370161  /* 0x0085C0 0......J......2.1 .T.a.7 */
                                                  1300:      .pword      0x20FF00, 0xB60A80, 0x400070, 0x885400, 0x37015C, 0x805400, 0x60006F, 0x500FE1  /* 0x0085D0 .. ...p.@.T.\.7.T.o.`..P */
                                                  1301:      .pword      0x320041, 0x390005, 0x500FE2, 0x320060, 0x500FE3, 0x3A0153, 0x370068, 0x07D741  /* 0x0085E0 A.2..9..P`.2..PS.:h.7A.. */
                                                  1302:      .pword      0x20F120, 0x784110, 0xE00402, 0x3A0010, 0x8078E0, 0x885470, 0xE00000, 0x320023  /* 0x0085F0  . .Ax.....:.x.pT....#.2 */
                                                  1303:      .pword      0x780010, 0x8853C0, 0x070875, 0xE00400, 0x3A001E, 0x07D733, 0x805470, 0x900010  /* 0x008600 ..x.S.u.......:3..pT.... */
                                                  1304:      .pword      0x885470, 0xE00000, 0x3AFFF5, 0x370017, 0x8078E0, 0x885470, 0xE00000, 0x32000C  /* 0x008610 pT......:..7.x.pT......2 */
                                                  1305:      .pword      0x9040C0, 0x514F81, 0x320009, 0x900010, 0xE00000, 0x3A0002, 0x885470, 0x370004  /* 0x008620 .@..OQ..2........:pT...7 */
                                                  1306:      .pword      0x9040C0, 0x514F81, 0x3AFFF8, 0x885470, 0x780010, 0x8853C0, 0x070859, 0xE00400  /* 0x008630 .@..OQ..:pT...x.S.Y..... */
                                                  1307:      .pword      0x3A0002, 0x07D717, 0xEF2A8E, 0x807910, 0xA32800, 0x32000A, 0xE20A8E, 0x3A0006  /* 0x008640 ..:....*..y..(...2.....: */
                                                  1308:      .pword      0xB3C341, 0x20F160, 0x784801, 0x205000, 0x885400, 0x37011B, 0xEC2A80, 0x370119  /* 0x008650 A..`. .Hx.P .T...7.*...7 */
                                                  1309:      .pword      0xEC2A80, 0x370117, 0x807910, 0xA32800, 0x3A001A, 0x20F220, 0xA02010, 0x805421  /* 0x008660 .*...7.y..(...: . . .!T. */
                                                  1310:      .pword      0xEB4880, 0xB3C032, 0x984092, 0xA33810, 0x320003, 0x784002, 0x9840A0, 0x370002  /* 0x008670 .H.2...@..8...2.@x.@...7 */
                                                  1311:      .pword      0xB3C040, 0x9840A0, 0xEB4000, 0x9840B0, 0x9840C0, 0x9840D0, 0x9840E0, 0x9840F0  /* 0x008680 @...@..@..@..@..@..@..@. */
                                                  1312:      .pword      0xEB0200, 0xEB0180, 0x200082, 0x807900, 0x07D91C, 0xEC2A80, 0x3700FA, 0x20FF00  /* 0x008690 ........ .y.....*...7..  */
                                                  1313:      .pword      0xB60A80, 0x400070, 0x885400, 0x3700F5, 0x807900, 0x900090, 0xA39801, 0x3200F1  /* 0x0086A0 ...p.@.T...7.y.........2 */
                                                  1314:      .pword      0x900010, 0xA38800, 0x320002, 0xEC2A80, 0x3700EC, 0x07DBA4, 0x3700EA, 0xB3C030  /* 0x0086B0 ........2.*...7.....70.. */
                                                  1315:      .pword      0xB7EA86, 0xE20A8E, 0x3A0006, 0xB3C341, 0x20F160, 0x784801, 0x205000, 0x885400  /* 0x0086C0 ........:A..`. .Hx.P .T. */
                                                  1316:      .pword      0x3700E0, 0x20FF00, 0xB60A80, 0x400070, 0x885400, 0x3700DB, 0x20F150, 0xFB8210  /* 0x0086D0 ..7.. ...p.@.T...7P. ... */
                                                  1317:      .pword      0xEB0280, 0xEB0100, 0x2007C1, 0xEBC000, 0x07DB57, 0xE00400, 0x3A00D2, 0x20FF00  /* 0x0086E0 ........ ...W.......:..  */
                                                  1318:      .pword      0xB60A80, 0x400070, 0x885400, 0x3700CD, 0x805400, 0x60006F, 0x500FE1, 0x32001A  /* 0x0086F0 ...p.@.T...7.T.o.`..P..2 */
                                                  1319:      .pword      0x390005, 0x500FE2, 0x320022, 0x500FE3, 0x3A00C4, 0x370023, 0x805421, 0xEB4000  /* 0x008700 ..9..P".2..P..:#.7!T..@. */
                                                  1320:      .pword      0x784880, 0xB3C092, 0x984092, 0x20F122, 0x784112, 0x9840A2, 0x9840B0, 0x9840C0  /* 0x008710 .Hx....@.". .Ax.@..@..@. */
                                                  1321:      .pword      0x9840D0, 0x9840E0, 0x9840F0, 0xEB0200, 0xEB0180, 0x200082, 0x807900, 0x07D8D1  /* 0x008720 .@..@..@......... .y.... */
                                                  1322:      .pword      0xEC2A80, 0x3700AF, 0x807900, 0x900090, 0xA39801, 0x3200AB, 0x900010, 0xA38800  /* 0x008730 .*...7.y.........2...... */
                                                  1323:      .pword      0x320002, 0xEC2A80, 0x3700A6, 0x07DB5E, 0x3700A4, 0xB3C030, 0xB7EA86, 0xEC2A80  /* 0x008740 ..2.*...7^....70......*. */
                                                  1324:      .pword      0x3700A0, 0x20F000, 0xB60A80, 0xB01000, 0x885400, 0x807910, 0xA36800, 0x320015  /* 0x008750 ..7.. .......T..y..h...2 */
                                                  1325:      .pword      0x20F170, 0x784090, 0x784001, 0xB3C0A2, 0xBC4004, 0x20F5A3, 0x418002, 0x790263  /* 0x008760 p. .@x.@x....@... ..Ac.y */
                                                  1326:      .pword      0x900130, 0x9001C0, 0x20F150, 0x784010, 0x010004, 0xE00400, 0x3A001F, 0xB3C391  /* 0x008770 0.....P. .@x........:... */
                                                  1327:      .pword      0x20F160, 0x784801, 0x205000, 0x885400, 0x370019, 0x8078F8, 0xE00008, 0x320016  /* 0x008780 `. .Hx.P .T...7.x......2 */
                                                  1328:      .pword      0x20F5A9, 0x20F15A, 0xE8058A, 0xB3C39C, 0x20500D, 0x9040F8, 0x784001, 0xB3C0A2  /* 0x008790 .. Z. .......P .@..@x... */
                                                  1329:      .pword      0xBC4004, 0x448002, 0x790269, 0x900130, 0x9001C0, 0x78401A, 0x010004, 0xE00400  /* 0x0087A0 .@...Di.y0......@x...... */
                                                  1330:      .pword      0x3A0002, 0x784D8C, 0x88540D, 0x780418, 0xE00008, 0x3AFFEF, 0x807910, 0xA37800  /* 0x0087B0 ..:.Mx.T...x.....:.y..x. */
                                                  1331:      .pword      0x320068, 0x20F180, 0x784090, 0x784001, 0xB3C0A2, 0xBC4004, 0x20F5A3, 0x418002  /* 0x0087C0 h.2.. .@x.@x....@... ..A */
                                                  1332:      .pword      0x790263, 0x900130, 0x9001C0, 0x20F150, 0x784010, 0x010004, 0xE00400, 0x3A0059  /* 0x0087D0 c.y0.....P. .@x......Y.: */
                                                  1333:      .pword      0xB3C391, 0x20F160, 0x784801, 0x205000, 0x885400, 0x370053, 0x200F00, 0xB60A80  /* 0x0087E0 ...`. .Hx.P .T.S.7.. ... */
                                                  1334:      .pword      0x500FF0, 0x3A004F, 0x805400, 0x60006F, 0x500FE3, 0x32000C, 0x500FE5, 0x320013  /* 0x0087F0 ..PO.:.T.o.`..P..2..P..2 */
                                                  1335:      .pword      0x500FE1, 0x3A0047, 0xA84494, 0x200150, 0x8853F0, 0x200400, 0x882400, 0xA8C482  /* 0x008800 ..PG.:.D.P. .S... .$.... */
                                                  1336:      .pword      0xEC2A80, 0x37003F, 0xA94494, 0xA80494, 0x2000B0, 0x8853F0, 0x200400, 0x882400  /* 0x008810 .*.?.7.D...... .S... .$. */
                                                  1337:      .pword      0xA8C482, 0xEC2A80, 0x370036, 0x204000, 0x885400, 0x370033, 0x200F00, 0xB60A80  /* 0x008820 ....*.6.7.@ .T.3.7.. ... */
                                                  1338:      .pword      0x3A0030, 0x200080, 0x8824A0, 0xEF248C, 0x200FF0, 0x882450, 0x2008C1, 0x204822  /* 0x008830 0.:.. .$..$... P$... "H  */
                                                  1339:      .pword      0x608912, 0x5080EF, 0x882401, 0xEF2490, 0x882470, 0xA8048C, 0x20F160, 0x784010  /* 0x008840 ..`..P.$..$.p$....`. .@x */
                                                  1340:      .pword      0x50C0F1, 0xB3C342, 0x504F82, 0x320012, 0x3E0008, 0xB3C6D1, 0x504FE7, 0x32000E  /* 0x008850 ..PB...OP..2..>....OP..2 */
                                                  1341:      .pword      0xE8C081, 0xE94102, 0x504F82, 0x3A0009, 0x370009, 0xB3C651, 0xB3C352, 0x504F82  /* 0x008860 ....A..OP..:..7Q..R...OP */
                                                  1342:      .pword      0x320005, 0x40C0E9, 0x414164, 0x504F82, 0x320001, 0xB3C701, 0xFB8081, 0x200014  /* 0x008870 ..2..@dAA.OP..2........  */
                                                  1343:      .pword      0x200005, 0x20F1A2, 0x510065, 0x784010, 0x07DA87, 0x20FF00, 0xB60A80, 0x400070  /* 0x008880 .. .. e.Q.@x..... ...p.@ */
                                                  1344:      .pword      0x885400, 0xBE064F, 0xBE054F, 0xBE044F, 0xFA8000, 0x060000, 0xFA0006, 0x20EC30  /* 0x008890 .T.O..O..O...........0.  */
                                                  1345:      .pword      0x784010, 0xE00400, 0x320234, 0x20EC61, 0xFB8111, 0x780082, 0xB20F01, 0x200303  /* 0x0088A0 .@x...4.2a. .....x.....  */
                                                  1346:      .pword      0x508F83, 0x320186, 0x3C0006, 0x508FF0, 0x32000B, 0x5181F0, 0x508F83, 0x3A0227  /* 0x0088B0 ..P..2..<..P..2..Q..P'.: */
                                                  1347:      .pword      0x370061, 0x200403, 0x508F83, 0x3201B4, 0x4181F0, 0x508F83, 0x3A0220, 0x3701E8  /* 0x0088C0 a.7.. ..P..2..A..P .:..7 */
                                                  1348:      .pword      0x61016F, 0x510FE1, 0x320010, 0x3C0003, 0xE00002, 0x320006, 0x370218, 0x510FE2  /* 0x0088D0 o.a..Q..2..<.....2..7..Q */
                                                  1349:      .pword      0x32001F, 0x510FE3, 0x3A0214, 0x370033, 0x07D88E, 0xB3C301, 0x504F81, 0x3A020F  /* 0x0088E0 ..2..Q..:3.7.......OP..: */
                                                  1350:      .pword      0x20EC60, 0xE84810, 0x37020C, 0xABA494, 0x3A020A, 0x20EC41, 0x784091, 0x781F81  /* 0x0088F0 `. .H...7.....:A. .@x..x */
                                                  1351:      .pword      0xB3C017, 0x20EA46, 0x200015, 0x200261, 0x408086, 0xFB8211, 0xEB0180, 0xB3CFE2  /* 0x008900 ...F. .. a. ..@......... */
                                                  1352:      .pword      0xB3CA11, 0x07C7D1, 0xE9878F, 0xE00400, 0x3A01FA, 0x20EC60, 0xE84810, 0x3701F7  /* 0x008910 ..............:`. .H...7 */
                                                  1353:      .pword      0x5781E6, 0xE9810F, 0xEB4080, 0x07D66F, 0xE00400, 0x3201F1, 0x20EC90, 0xEB4800  /* 0x008920 ..W....@.o.......2.. .H. */
                                                  1354:      .pword      0x97F86F, 0xE00400, 0x3A0005, 0x20EA41, 0x200250, 0x400001, 0x784811, 0x370004  /* 0x008930 o.......:A. P. ..@.Hx..7 */
                                                  1355:      .pword      0xEB4080, 0x20EC30, 0x784010, 0x07DBDD, 0x20EC60, 0xE84810, 0x3701E0, 0xEB4080  /* 0x008940 .@.0. .@x...`. .H...7.@. */
                                                  1356:      .pword      0x807AB2, 0x807AC3, 0x807A84, 0x010004, 0xE00400, 0x32000D, 0x200014, 0x200005  /* 0x008950 .z..z..z.........2.. ..  */
                                                  1357:      .pword      0x20EC92, 0x201F71, 0x510066, 0x784010, 0x807A93, 0x010003, 0x20EC60, 0xB3CF01  /* 0x008960 .. q. f.Q.@x.z....`. ... */
                                                  1358:      .pword      0x60C090, 0x40C870, 0x3701CC, 0xB3C591, 0x20EC50, 0x784801, 0x40C0E7, 0xE80000  /* 0x008970 ..`p.@..7...P. .Hx..@... */
                                                  1359:      .pword      0x784801, 0x3701C5, 0x61016F, 0x510FE4, 0x32006C, 0x3C0006, 0x510FE2, 0x32001C  /* 0x008980 .Hx..7o.a..Ql.2..<..Q..2 */
                                                  1360:      .pword      0x3C0045, 0x510FE1, 0x3A01BC, 0x370006, 0x510FE6, 0x3200A0, 0x35008D, 0x510FE7  /* 0x008990 E.<..Q..:..7..Q..2..5..Q */
                                                  1361:      .pword      0x3A01B6, 0x37010A, 0x2001F4, 0x200005, 0x20EA42, 0x200281, 0x408082, 0x784091  /* 0x0089A0 ..:..7.. .. B. .. ..@.@x */
                                                  1362:      .pword      0x07D5C6, 0xE00400, 0x320006, 0x20EC51, 0x784880, 0xB3C271, 0x20EC60, 0x784801  /* 0x0089B0 ........2Q. .Hxq..`. .Hx */
                                                  1363:      .pword      0x3701A6, 0x20EC60, 0xE84810, 0x3701A3, 0x5781E6, 0xE9810F, 0x20ECC1, 0x784091  /* 0x0089C0 ..7`. .H...7..W..... .@x */
                                                  1364:      .pword      0x07D61A, 0xE00400, 0x32019C, 0x97F86F, 0xE00400, 0x320006, 0x20EC51, 0x784880  /* 0x0089D0 ........2o.......2Q. .Hx */
                                                  1365:      .pword      0xB3C271, 0x20EC60, 0x784801, 0x370193, 0x2001F0, 0x200001, 0x97B95F, 0x97B9EF  /* 0x0089E0 q..`. .Hx..7.. .. _..... */
                                                  1366:      .pword      0x510F80, 0x598F81, 0x320007, 0xB3C541, 0x20EC50, 0x784801, 0xB3C271, 0xE80000  /* 0x0089F0 ..Q..Y..2A..P. .Hxq..... */
                                                  1367:      .pword      0x784801, 0x370185, 0x807560, 0x807571, 0x500FE0, 0x588FE0, 0x3A0004, 0xB3C251  /* 0x008A00 .Hx..7`u.qu...P..X..:Q.. */
                                                  1368:      .pword      0x20EC60, 0x784801, 0x37017C, 0x20EC60, 0xE84810, 0x370179, 0x807684, 0x807695  /* 0x008A10 `. .Hx|.7`. .H.y.7.v..v. */
                                                  1369:      .pword      0x520FE0, 0x5A8FE0, 0x3A0004, 0xB3C251, 0x20EC60, 0x784801, 0x370170, 0x807641  /* 0x008A20 ..R..Z..:Q..`. .Hxp.7Av. */
                                                  1370:      .pword      0xA30801, 0x3A0006, 0x807672, 0x20ECD1, 0x784091, 0x07D581, 0x9FFFE0, 0x370005  /* 0x008A30 .....:rv... .@x........7 */
                                                  1371:      .pword      0x807672, 0x20ECD1, 0x784091, 0x07D549, 0x9FFFE0, 0x97F86F, 0xE00400, 0x320006  /* 0x008A40 rv... .@xI.....o.......2 */
                                                  1372:      .pword      0x20EC51, 0x784880, 0xB3C271, 0x20EC60, 0x784801, 0x370159, 0x20EC60, 0xE84810  /* 0x008A50 Q. .Hxq..`. .HxY.7`. .H. */
                                                  1373:      .pword      0x370156, 0x5781E6, 0xE9810F, 0x20ECD1, 0x784091, 0x07D5CD, 0xE00400, 0x32014F  /* 0x008A60 V.7..W..... .@x......O.2 */
                                                  1374:      .pword      0x97F86F, 0xE00400, 0x32001E, 0x504FF1, 0x3A0013, 0x20ECD0, 0x784090, 0x50006A  /* 0x008A70 o.......2.OP..:.. .@xj.P */
                                                  1375:      .pword      0x784010, 0x07DB3F, 0x807640, 0xA30800, 0x3A0003, 0x20EC80, 0xA03010, 0x370002  /* 0x008A80 .@x?..@v......:.. .0...7 */
                                                  1376:      .pword      0x20EC80, 0xA02010, 0xB3C251, 0x20EC70, 0x784801, 0xEB4000, 0x07D165, 0x370137  /* 0x008A90 .. . .Q..p. .Hx.@.e..7.7 */
                                                  1377:      .pword      0x20EC80, 0x784190, 0x71C86E, 0xB3C211, 0xE90000, 0x784801, 0xEB4000, 0x07D15C  /* 0x008AA0 .. .Axn.q.......Hx.@.\.. */
                                                  1378:      .pword      0x37012E, 0x20EC60, 0xE84810, 0x37012B, 0x2000D4, 0x200005, 0x20EA42, 0x200271  /* 0x008AB0 ..7`. .H.+.7.. .. B. q.  */
                                                  1379:      .pword      0x408082, 0x784091, 0x07D50A, 0xE00400, 0x320006, 0x20EC51, 0x784880, 0xB3C271  /* 0x008AC0 ..@.@x........2Q. .Hxq.. */
                                                  1380:      .pword      0x20EC60, 0x784801, 0x37011C, 0x20EC60, 0xE84810, 0x370119, 0x5781E6, 0xE9810F  /* 0x008AD0 `. .Hx..7`. .H...7..W... */
                                                  1381:      .pword      0x20ECB1, 0x784091, 0x07D590, 0xE00400, 0x320112, 0x97F86F, 0xE00400, 0x320017  /* 0x008AE0 .. .@x........2o.......2 */
                                                  1382:      .pword      0x20EDC2, 0xE94092, 0x784901, 0x32000D, 0x510071, 0x784090, 0x500068, 0x784010  /* 0x008AF0 .. .@..Ix..2q.Q.@xh.P.@x */
                                                  1383:      .pword      0x07DB00, 0x20EC80, 0xA02010, 0xB3C251, 0xE90000, 0x784801, 0xEB4000, 0x07D12C  /* 0x008B00 ..... . .Q......Hx.@.,.. */
                                                  1384:      .pword      0x3700FE, 0x20EC51, 0x784880, 0xB3C271, 0x20EC60, 0x784801, 0x3700F8, 0x97B85F  /* 0x008B10 ..7Q. .Hxq..`. .Hx..7_.. */
                                                  1385:      .pword      0x97B8EF, 0x68006D, 0x708000, 0xA7F000, 0xEA0000, 0xEA0000, 0xDE014F, 0x253550  /* 0x008B20 ...m.h..p.........O..P5% */
                                                  1386:      .pword      0x253421, 0x807524, 0x807535, 0x6A0000, 0x6A8081, 0x708000, 0xA7F000, 0xEA0000  /* 0x008B30 !4%$u.5u...j..j..p...... */
                                                  1387:      .pword      0xEA0000, 0xDE004F, 0x714000, 0xFB8100, 0x807544, 0x807555, 0x20ED81, 0x6A0331  /* 0x008B40 ...O...@q...Du.Uu... 1.j */
                                                  1388:      .pword      0x6A83A1, 0xBE0006, 0x708006, 0xA7F000, 0xEA0000, 0xEA0000, 0xDE004F, 0x700002  /* 0x008B50 ..j.....p.........O....p */
                                                  1389:      .pword      0x320007, 0xB3C551, 0x20EC50, 0x784801, 0xB3C271, 0xE80000, 0x784801, 0x3700CF  /* 0x008B60 ..2Q..P. .Hxq......Hx..7 */
                                                  1390:      .pword      0x20EAC1, 0x200242, 0x410101, 0x410064, 0xBE0212, 0x521831, 0x5A9021, 0xB10240  /* 0x008B70 .. B. ..Ad.A...1.R!.Z@.. */
                                                  1391:      .pword      0x784010, 0xE00400, 0x320007, 0xB3C502, 0x4080F9, 0x704882, 0xB3C271, 0x20EC60  /* 0x008B80 .@x.....2.....@.Hpq..`.  */
                                                  1392:      .pword      0x784801, 0x370005, 0x20EC50, 0xEB4800, 0xB3C271, 0xE80000, 0x784801, 0x20EB00  /* 0x008B90 .Hx..7P. .H.q......Hx..  */
                                                  1393:      .pword      0xB3C025, 0x12CF90, 0x3A00B4, 0x400078, 0x784310, 0x73486E, 0xB3C201, 0xE90000  /* 0x008BA0 %.......:x.@.CxnHs...... */
                                                  1394:      .pword      0x784801, 0xEB4000, 0x07D0D9, 0x3700AB, 0xB3C201, 0x20EC60, 0x784801, 0x3700A7  /* 0x008BB0 .Hx.@......7...`. .Hx..7 */
                                                  1395:      .pword      0x61016F, 0x510FE1, 0x32001D, 0x510FE2, 0x320030, 0xE00002, 0x3A00A0, 0x20EC41  /* 0x008BC0 o.a..Q..2..Q0.2.....:A.  */
                                                  1396:      .pword      0x784091, 0x781F81, 0xEB4380, 0xEB0300, 0xEB0280, 0x20ECA1, 0xFB8211, 0xEB0180  /* 0x008BD0 .@x..x.C......... ...... */
                                                  1397:      .pword      0xEBC100, 0xB3C211, 0x07C668, 0xE9878F, 0xE00400, 0x320007, 0xB3C5A1, 0x20EC50  /* 0x008BE0 ......h..........2...P.  */
                                                  1398:      .pword      0x784801, 0xB3C271, 0xE80000, 0x784801, 0x37008A, 0x20EC60, 0xE84810, 0x370087  /* 0x008BF0 .Hxq......Hx..7`. .H...7 */
                                                  1399:      .pword      0x5781E6, 0xE9810F, 0xEB4080, 0x07D4FF, 0xE00400, 0x320081, 0x97F86F, 0xE00400  /* 0x008C00 ..W....@.........2o..... */
                                                  1400:      .pword      0x320007, 0xB3C5A1, 0x20EC50, 0x784801, 0xB3C271, 0xE80000, 0x784801, 0x370077  /* 0x008C10 ..2...P. .Hxq......Hxw.7 */
                                                  1401:      .pword      0x20EC80, 0xA11010, 0xE98000, 0xE84810, 0x370072, 0xEB4000, 0x07D09D, 0x37006F  /* 0x008C20 .. .......H.r.7.@....o.7 */
                                                  1402:      .pword      0x61016F, 0x510FE1, 0x32001D, 0x510FE2, 0x320030, 0xE00002, 0x3A0068, 0x20EC41  /* 0x008C30 o.a..Q..2..Q0.2...h.:A.  */
                                                  1403:      .pword      0x784091, 0x781F81, 0xEB4380, 0xEB0300, 0xEB0280, 0x20ECB1, 0xFB8211, 0xEB0180  /* 0x008C40 .@x..x.C......... ...... */
                                                  1404:      .pword      0xB3C012, 0xB3C021, 0x07C630, 0xE9878F, 0xE00400, 0x320007, 0xB3C5A1, 0x20EC50  /* 0x008C50 ...!..0..........2...P.  */
                                                  1405:      .pword      0x784801, 0xB3C271, 0xE80000, 0x784801, 0x370052, 0x20EC60, 0xE84810, 0x37004F  /* 0x008C60 .Hxq......HxR.7`. .H.O.7 */
                                                  1406:      .pword      0x5781E6, 0xE9810F, 0xEB4080, 0x07D4C7, 0xE00400, 0x320049, 0x97F86F, 0xE00400  /* 0x008C70 ..W....@.......I.2o..... */
                                                  1407:      .pword      0x320007, 0xB3C5A1, 0x20EC50, 0x784801, 0xB3C271, 0xE80000, 0x784801, 0x37003F  /* 0x008C80 ..2...P. .Hxq......Hx?.7 */
                                                  1408:      .pword      0x20EC80, 0xA12010, 0xE98000, 0xE84810, 0x37003A, 0xEB4000, 0x07D065, 0x370037  /* 0x008C90 .. . .....H.:.7.@.e..7.7 */
                                                  1409:      .pword      0x61016F, 0x510FE1, 0x32001D, 0x510FE2, 0x320030, 0xE00002, 0x3A0030, 0x20EC41  /* 0x008CA0 o.a..Q..2..Q0.2...0.:A.  */
                                                  1410:      .pword      0x784091, 0x781F81, 0xEB4380, 0xEB0300, 0xEB0280, 0x20ECC1, 0xFB8211, 0xEB0180  /* 0x008CB0 .@x..x.C......... ...... */
                                                  1411:      .pword      0xB3C012, 0xB3C021, 0x07C5F8, 0xE9878F, 0xE00400, 0x320007, 0xB3C5A1, 0x20EC50  /* 0x008CC0 ...!.............2...P.  */
                                                  1412:      .pword      0x784801, 0xB3C271, 0xE80000, 0x784801, 0x37001A, 0x20EC60, 0xE84810, 0x370017  /* 0x008CD0 .Hxq......Hx..7`. .H...7 */
                                                  1413:      .pword      0x5781E6, 0xE9810F, 0xEB4080, 0x07D48F, 0xE00400, 0x320011, 0x97F86F, 0xE00400  /* 0x008CE0 ..W....@.........2o..... */
                                                  1414:      .pword      0x320007, 0xB3C5A1, 0x20EC50, 0x784801, 0xB3C271, 0xE80000, 0x784801, 0x370007  /* 0x008CF0 ..2...P. .Hxq......Hx..7 */
                                                  1415:      .pword      0x20EC80, 0xA13010, 0xE98000, 0xE84810, 0x370002, 0xEB4000, 0x07D02D, 0xFA8000  /* 0x008D00 .. .0.....H...7.@.-..... */
                                                  1416:      .pword      0x060000, 0xA9C08E, 0xABC482, 0x32000E, 0xABC480, 0x32000C, 0x200400, 0x882400  /* 0x008D10 ...........2.....2.. .$. */
                                                  1417:      .pword      0xE20A7E, 0x320008, 0xED2A7E, 0xE20A7E, 0x3A0005, 0xA9C482, 0x20F000, 0xB60A80  /* 0x008D20 ~....2~*.~....:..... ... */
                                                  1418:      .pword      0x320001, 0xEC2A80, 0xABC48C, 0x32000A, 0xABC48A, 0x320008, 0xA9C48C, 0x200400  /* 0x008D30 ..2.*......2.....2.....  */
                                                  1419:      .pword      0x882450, 0x500070, 0xE30A80, 0x3A0002, 0x201000, 0x8853E0, 0xAB048C, 0x320006  /* 0x008D40 P$.p.P.....:.. .S......2 */
                                                  1420:      .pword      0xAB048A, 0x320004, 0x200010, 0x882450, 0xA9048C, 0xEF2A7C, 0xAB648C, 0x320127  /* 0x008D50 .....2.. P$....|*..d.'.2 */
                                                  1421:      .pword      0xAB648A, 0x320125, 0xAB248C, 0x320008, 0xAB248A, 0x320006, 0x805410, 0x9008D0  /* 0x008D60 .d.%.2.$...2.$...2.T.... */
                                                  1422:      .pword      0xB23001, 0x201000, 0x508F80, 0x3A011B, 0xA98A58, 0x802492, 0x200080, 0x882450  /* 0x008D70 .0... ..P..:X...$... P$. */
                                                  1423:      .pword      0x805410, 0x9058A0, 0xFB8081, 0x8024F3, 0x698081, 0x6080EF, 0x3A010F, 0x780082  /* 0x008D80 .T..X.....$...i..`..:..x */
                                                  1424:      .pword      0xA33801, 0x320005, 0x2100C2, 0xA32801, 0x3A0006, 0x510164, 0x370004, 0x210042  /* 0x008D90 .8...2..!.(...:d.Q..7B.! */
                                                  1425:      .pword      0xA32801, 0x3A0001, 0x510164, 0x23C001, 0x608092, 0x208003, 0x508F83, 0x3A0046  /* 0x008DA0 .(...:d.Q..#..`.. ..PF.: */
                                                  1426:      .pword      0x203FF1, 0x608092, 0x900900, 0x900990, 0x408102, 0x4981E0, 0x980802, 0x980813  /* 0x008DB0 .? ..`........@..I...... */
                                                  1427:      .pword      0x805410, 0xEB0100, 0x980872, 0x900110, 0xDE114B, 0xEA8102, 0x610161, 0xDD114B  /* 0x008DC0 .T....r.....K.....a.aK.. */
                                                  1428:      .pword      0x900190, 0xA1B003, 0x710103, 0x980012, 0x805410, 0x905900, 0x514FF0, 0x320008  /* 0x008DD0 ........q....T..Y..OQ..2 */
                                                  1429:      .pword      0x905980, 0xB3C202, 0x51CF82, 0x320004, 0x905980, 0x414170, 0x51CF82, 0x3A000F  /* 0x008DE0 .Y......Q..2.Y.pAA..Q..: */
                                                  1430:      .pword      0x900A00, 0x900A90, 0x900170, 0xEB0180, 0x520F82, 0x5A8F83, 0x3900D7, 0xB81160  /* 0x008DF0 ......p.......R..Z..9`.. */
                                                  1431:      .pword      0x980802, 0x980813, 0x805410, 0x905880, 0xE84081, 0x985801, 0x3700CF, 0x9009D0  /* 0x008E00 .......T..X..@..X...7... */
                                                  1432:      .pword      0xB23003, 0x201002, 0x518F82, 0x32000A, 0x900140, 0x508F82, 0x390007, 0x900A00  /* 0x008E10 .0... ..Q..2@....P..9... */
                                                  1433:      .pword      0x900A90, 0x900150, 0x9001E0, 0x520F82, 0x5A8F83, 0x3900C0, 0x900090, 0xA08001  /* 0x008E20 ...P.......R..Z..9...... */
                                                  1434:      .pword      0x980011, 0x805410, 0x905880, 0xE84081, 0x985801, 0x3700B8, 0x20C003, 0x508F83  /* 0x008E30 ....T..X..@..X...7.. ..P */
                                                  1435:      .pword      0x320003, 0x22C003, 0x508F83, 0x3A002C, 0x203FF1, 0x608092, 0x900900, 0x900990  /* 0x008E40 ..2.."..P,.:.? ..`...... */
                                                  1436:      .pword      0x408102, 0x4981E0, 0x980802, 0x980813, 0x805410, 0xEB0100, 0x980872, 0x900110  /* 0x008E50 ..@..I.......T....r..... */
                                                  1437:      .pword      0xDE114B, 0xEA8102, 0x610161, 0xDD114B, 0x900190, 0xA1B003, 0x710103, 0x980012  /* 0x008E60 K.....a.aK..........q... */
                                                  1438:      .pword      0x805410, 0x9009D0, 0xB23003, 0x201002, 0x518F82, 0x32000A, 0x900140, 0x508F82  /* 0x008E70 .T.....0... ..Q..2@....P */
                                                  1439:      .pword      0x390007, 0x900A00, 0x900A90, 0x900150, 0x9001E0, 0x520F82, 0x5A8F83, 0x39008E  /* 0x008E80 ..9......P.......R..Z..9 */
                                                  1440:      .pword      0x900090, 0xA08001, 0x980011, 0x805410, 0x905880, 0xE84081, 0x985801, 0x370086  /* 0x008E90 ..........T..X..@..X...7 */
                                                  1441:      .pword      0x228002, 0x508F82, 0x3A005A, 0x900090, 0xA0C001, 0x980011, 0x805410, 0x9008F0  /* 0x008EA0 .."..PZ.:..........T.... */
                                                  1442:      .pword      0xE80081, 0x980871, 0x9008D0, 0xDE08C8, 0x6080E3, 0x508FE2, 0x320005, 0x508FE3  /* 0x008EB0 ...q..........`..P..2..P */
                                                  1443:      .pword      0x320027, 0x508FE1, 0x3A0013, 0x370041, 0x900090, 0xA3D801, 0x32006F, 0x900970  /* 0x008EC0 '.2..P..:A.7......o.2p.. */
                                                  1444:      .pword      0x901080, 0x510F81, 0x36006B, 0x900090, 0xA06001, 0x980011, 0xB3C171, 0x805410  /* 0x008ED0 .....Qk.6....`....q...T. */
                                                  1445:      .pword      0x985841, 0x805410, 0x905880, 0xB340F1, 0x985801, 0x370060, 0x900090, 0xA3D801  /* 0x008EE0 AX..T..X..@..X.`.7...... */
                                                  1446:      .pword      0x32005D, 0x900970, 0x901080, 0x510F81, 0x360059, 0x900090, 0xA06001, 0x980011  /* 0x008EF0 ].2p.......QY.6....`.... */
                                                  1447:      .pword      0xB3C171, 0x805410, 0x985841, 0x805410, 0x905880, 0xB340F1, 0x985801, 0x37004E  /* 0x008F00 q...T.AX..T..X..@..X.N.7 */
                                                  1448:      .pword      0x9058A0, 0xE00401, 0x350012, 0x900090, 0xA3D801, 0x320048, 0x900970, 0x901080  /* 0x008F10 .X......5......H.2p..... */
                                                  1449:      .pword      0x510F81, 0x360044, 0x900090, 0xA06001, 0x980011, 0xB3C171, 0x805410, 0x985841  /* 0x008F20 ..QD.6....`....q...T.AX. */
                                                  1450:      .pword      0x805410, 0x905880, 0xB340F1, 0x985801, 0x370039, 0x900090, 0xA08001, 0x980011  /* 0x008F30 .T..X..@..X.9.7......... */
                                                  1451:      .pword      0x805410, 0x905880, 0xE84081, 0x985801, 0x370031, 0x900090, 0xA08001, 0x980011  /* 0x008F40 .T..X..@..X.1.7......... */
                                                  1452:      .pword      0x805410, 0x905880, 0xE84081, 0x985801, 0x370029, 0x238002, 0x508F82, 0x3A000B  /* 0x008F50 .T..X..@..X.).7..#..P..: */
                                                  1453:      .pword      0x900090, 0xA05001, 0x980011, 0xB3C111, 0x805410, 0x985841, 0x805410, 0x905880  /* 0x008F60 ....P........T.AX..T..X. */
                                                  1454:      .pword      0xB340F1, 0x985801, 0x37001B, 0x900090, 0xE84081, 0x6080FF, 0x900190, 0x2FFE02  /* 0x008F70 .@..X...7....@...`...../ */
                                                  1455:      .pword      0x618102, 0x708082, 0x980011, 0x805410, 0x900090, 0x6080FF, 0x508FF3, 0x34000E  /* 0x008F80 ..a..p....T......`..P..4 */
                                                  1456:      .pword      0x900090, 0xA06001, 0x980011, 0xB3C131, 0x805410, 0x985841, 0x805410, 0x905880  /* 0x008F90 ....`....1...T.AX..T..X. */
                                                  1457:      .pword      0xB340F1, 0x985801, 0x200FF0, 0x882470, 0x200020, 0x882450, 0x070073, 0xAB448C  /* 0x008FA0 .@..X... p$. . P$.s...D. */
                                                  1458:      .pword      0x32002A, 0xAB448A, 0x320028, 0x200040, 0x882450, 0x8078F4, 0xE00004, 0x32001D  /* 0x008FB0 *.2.D.(.2@. P$..x......2 */
                                                  1459:      .pword      0x203002, 0x201003, 0x900024, 0xE00000, 0x320015, 0x900020, 0xE00000, 0x320012  /* 0x008FC0 .0 .. $.......2 .......2 */
                                                  1460:      .pword      0x9008D0, 0x608082, 0x508F82, 0x320002, 0x508F83, 0x3A0006, 0x9000B0, 0xE00001  /* 0x008FD0 .....`..P..2..P..:...... */
                                                  1461:      .pword      0x320003, 0x9000B0, 0xE90081, 0x980031, 0x900090, 0xA1C001, 0x980011, 0x780010  /* 0x008FE0 ..2......1.............x */
                                                  1462:      .pword      0xE00000, 0x3AFFEE, 0x780214, 0xE00004, 0x3AFFE5, 0xA90A58, 0xA92A58, 0xA94A58  /* 0x008FF0 .....:..x.....:X..X*.XJ. */
                                                  1463:      .pword      0xA96A58, 0xEF6A5A, 0x070047, 0xAB248C, 0x320044, 0xAB248A, 0x320042, 0xA98A58  /* 0x009000 Xj.Zj.G...$.D.2.$.B.2X.. */
                                                  1464:      .pword      0x805410, 0x900950, 0xB23002, 0x201001, 0x510F81, 0x320037, 0x900090, 0xE84081  /* 0x009010 .T.P...0... ..Q7.2....@. */
                                                  1465:      .pword      0x6080FF, 0x900190, 0x2FFE02, 0x618102, 0x708082, 0x980011, 0x805410, 0x900090  /* 0x009020 ..`...../..a..p....T.... */
                                                  1466:      .pword      0x6080FF, 0x508FF3, 0x34002A, 0xABE48E, 0x320002, 0xB3C201, 0x985841, 0xABA48E  /* 0x009030 ..`..P*.4.....2...AX.... */
                                                  1467:      .pword      0x320003, 0xB3C211, 0x805410, 0x985841, 0xAB848E, 0x320003, 0xB3C221, 0x805410  /* 0x009040 ..2....T.AX......2!...T. */
                                                  1468:      .pword      0x985841, 0xAB648E, 0x320003, 0xB3C231, 0x805410, 0x985841, 0xAB448E, 0x320003  /* 0x009050 AX..d...21...T.AX..D...2 */
                                                  1469:      .pword      0xB3C241, 0x805410, 0x985841, 0xAB248E, 0x320003, 0xB3C251, 0x805410, 0x985841  /* 0x009060 A...T.AX..$...2Q...T.AX. */
                                                  1470:      .pword      0xAB048E, 0x320003, 0xB3C261, 0x805410, 0x985841, 0x805410, 0x900090, 0xA06001  /* 0x009070 .....2a...T.AX..T.....`. */
                                                  1471:      .pword      0x980011, 0x805410, 0x905880, 0xB340F1, 0x985801, 0x200FF0, 0x882470, 0x200020  /* 0x009080 ....T..X..@..X... p$. .  */
                                                  1472:      .pword      0x882450, 0x060000, 0xBE9F88, 0x781F8A, 0x805400, 0xAB8A58, 0x3A0199, 0xEB4400  /* 0x009090 P$.........x.T.X....:.D. */
                                                  1473:      .pword      0xAB0A58, 0x3A00CD, 0x784008, 0x07C9CE, 0xE00400, 0x3200C8, 0x805410, 0x905880  /* 0x0090A0 X....:.@x........2.T..X. */
                                                  1474:      .pword      0xB20F01, 0x200202, 0x508F82, 0x32003B, 0x410170, 0x508F82, 0x320078, 0x508FF0  /* 0x0090B0 ..... ..P;.2p.A..Px.2..P */
                                                  1475:      .pword      0x3A00B6, 0x905880, 0x6080EF, 0x508FE1, 0x320014, 0x3C0003, 0xE00001, 0x320006  /* 0x0090C0 ..:.X...`..P..2..<.....2 */
                                                  1476:      .pword      0x3700AE, 0x508FE2, 0x32001E, 0x508FEF, 0x3A00AA, 0x370022, 0x900090, 0xA1B001  /* 0x0090D0 ..7..P..2..P..:".7...... */
                                                  1477:      .pword      0x980011, 0xB3C0D0, 0x07C2DE, 0x805410, 0x905820, 0xB3C0D1, 0x07D639, 0xA80A58  /* 0x0090E0 ..........T. X....9..X.. */
                                                  1478:      .pword      0x37016F, 0x900900, 0x900990, 0x980052, 0x980063, 0x805410, 0x900090, 0xA0B001  /* 0x0090F0 o.7......R..c...T....... */
                                                  1479:      .pword      0x980011, 0xB3C090, 0x07C2CE, 0x805410, 0x905820, 0xB3C091, 0x07D629, 0xA80A58  /* 0x009100 ..........T. X....)..X.. */
                                                  1480:      .pword      0x37015F, 0xEB4080, 0x985801, 0x805410, 0x900090, 0xA09001, 0x980011, 0x370156  /* 0x009110 _.7.@..X..T..........V.7 */
                                                  1481:      .pword      0xEB4080, 0x985801, 0x805410, 0x900090, 0xA09001, 0x980011, 0x37014F, 0x905880  /* 0x009120 .@..X..T..........O.7.X. */
                                                  1482:      .pword      0x6080EF, 0x508FE2, 0x32001E, 0x3C0005, 0xE00001, 0x320008, 0x508FE1, 0x3A0077  /* 0x009130 ..`..P..2..<.....2..Pw.: */
                                                  1483:      .pword      0x370010, 0x508FE3, 0x320026, 0x508FEF, 0x3A0072, 0x37002A, 0x900090, 0xA1B001  /* 0x009140 ..7..P&.2..Pr.:*.7...... */
                                                  1484:      .pword      0x980011, 0xB3C0D0, 0x07C2A6, 0x805410, 0x905820, 0xB3C0D1, 0x07D601, 0xA80A58  /* 0x009150 ..........T. X.......X.. */
                                                  1485:      .pword      0x370137, 0xB3C090, 0x07C29E, 0x805410, 0x905820, 0xB3C091, 0x07D5F9, 0xA80A58  /* 0x009160 7.7.......T. X.......X.. */
                                                  1486:      .pword      0x37012F, 0x900900, 0x900990, 0x980052, 0x980063, 0x805410, 0x900090, 0xA0B001  /* 0x009170 /.7......R..c...T....... */
                                                  1487:      .pword      0x980011, 0xB3C010, 0x07C28E, 0x805410, 0x905820, 0xB3C011, 0x07D5E9, 0xA80A58  /* 0x009180 ..........T. X.......X.. */
                                                  1488:      .pword      0x37011F, 0xEB4080, 0x985801, 0x805410, 0x900090, 0xA09001, 0x980011, 0x370116  /* 0x009190 ..7.@..X..T............7 */
                                                  1489:      .pword      0xEB4080, 0x985801, 0x805410, 0x900090, 0xA09001, 0x980011, 0x37010F, 0x905880  /* 0x0091A0 .@..X..T............7.X. */
                                                  1490:      .pword      0x6080EF, 0x508FE2, 0x32001E, 0x3C0005, 0xE00001, 0x320008, 0x508FE1, 0x3A0037  /* 0x0091B0 ..`..P..2..<.....2..P7.: */
                                                  1491:      .pword      0x370010, 0x508FE3, 0x320026, 0x508FEF, 0x3A0032, 0x37002A, 0x900090, 0xA1B001  /* 0x0091C0 ..7..P&.2..P2.:*.7...... */
                                                  1492:      .pword      0x980011, 0xB3C0D0, 0x07C266, 0x805410, 0x905820, 0xB3C0D1, 0x07D5C1, 0xA80A58  /* 0x0091D0 ......f...T. X.......X.. */
                                                  1493:      .pword      0x3700F7, 0xB3C010, 0x07C25E, 0x805410, 0x905820, 0xB3C011, 0x07D5B9, 0xA80A58  /* 0x0091E0 ..7...^...T. X.......X.. */
                                                  1494:      .pword      0x3700EF, 0x900900, 0x900990, 0x980052, 0x980063, 0x805410, 0x900090, 0xA0B001  /* 0x0091F0 ..7......R..c...T....... */
                                                  1495:      .pword      0x980011, 0xB3C090, 0x07C24E, 0x805410, 0x905820, 0xB3C091, 0x07D5A9, 0xA80A58  /* 0x009200 ......N...T. X.......X.. */
                                                  1496:      .pword      0x3700DF, 0xEB4080, 0x985801, 0x805410, 0x900090, 0xA09001, 0x980011, 0x3700D6  /* 0x009210 ..7.@..X..T............7 */
                                                  1497:      .pword      0xEB4080, 0x985801, 0x805410, 0x900090, 0xA09001, 0x980011, 0x3700CF, 0xEB4080  /* 0x009220 .@..X..T............7.@. */
                                                  1498:      .pword      0x985801, 0x805410, 0x900090, 0xA09001, 0x980011, 0xB3C018, 0xA80A58, 0xAB2A58  /* 0x009230 .X..T.............X..X*. */
                                                  1499:      .pword      0x32005D, 0x370063, 0x805410, 0x905880, 0x648081, 0x508F8A, 0x320004, 0x200502  /* 0x009240 ].2c.7.T..X...d..P..2..  */
                                                  1500:      .pword      0x508F82, 0x3A0043, 0x370021, 0x905880, 0x6080EF, 0x508FE1, 0x32000B, 0x508FEF  /* 0x009250 ..PC.:!.7.X...`..P..2..P */
                                                  1501:      .pword      0x320012, 0xE00001, 0x3A003C, 0xB3C090, 0x07C21C, 0x805410, 0x905820, 0xB3C091  /* 0x009260 ..2...<.:.......T. X.... */
                                                  1502:      .pword      0x07D577, 0x3700AE, 0xEB4080, 0x985801, 0x805410, 0x9001A0, 0x980033, 0x900090  /* 0x009270 w....7.@..X..T....3..... */
                                                  1503:      .pword      0xA09001, 0x980011, 0x37002F, 0xEB4080, 0x985801, 0x805410, 0x9000A0, 0x980031  /* 0x009280 ....../.7.@..X..T....1.. */
                                                  1504:      .pword      0x900090, 0xA09001, 0x980011, 0x370026, 0x905880, 0x6080EF, 0x508FE1, 0x32000B  /* 0x009290 .........&.7.X...`..P..2 */
                                                  1505:      .pword      0x508FEF, 0x320012, 0xE00001, 0x3A001D, 0xB3C010, 0x07C1FB, 0x805410, 0x905820  /* 0x0092A0 ..P..2.....:.......T. X. */
                                                  1506:      .pword      0xB3C011, 0x07D556, 0x37008D, 0xEB4080, 0x985801, 0x805410, 0x900120, 0x980032  /* 0x0092B0 ...V....7.@..X..T. ..2.. */
                                                  1507:      .pword      0x900090, 0xA09001, 0x980011, 0x37000E, 0xEB4080, 0x985801, 0x805410, 0x9001A0  /* 0x0092C0 ...........7.@..X..T.... */
                                                  1508:      .pword      0x980033, 0x900090, 0xA09001, 0x980011, 0x370005, 0xB3C018, 0x370003, 0xB3C018  /* 0x0092D0 3.............7.....7... */
                                                  1509:      .pword      0x370001, 0xB3C018, 0xE00408, 0x32000C, 0xEB4080, 0x805410, 0x985801, 0x805410  /* 0x0092E0 ..7........2.@..T..X..T. */
                                                  1510:      .pword      0x9000A0, 0x980031, 0x900090, 0xA09001, 0x980011, 0x370002, 0x200F09, 0x20040A  /* 0x0092F0 ...1.............7.. ..  */
                                                  1511:      .pword      0xB3C030, 0x07C8A0, 0xE00400, 0x3AFF9E, 0xA82A58, 0xAB6A58, 0x3A0061, 0x200F09  /* 0x009300 0..........:X*.Xj.a.:..  */
                                                  1512:      .pword      0x20080A, 0xB3C020, 0x07C897, 0xE00400, 0x320051, 0x805410, 0x905880, 0x648081  /* 0x009310 ..  ........Q.2.T..X...d */
                                                  1513:      .pword      0x508F8A, 0x320004, 0x200902, 0x508F82, 0x3A003B, 0x37001D, 0x905880, 0x6080EF  /* 0x009320 ..P..2.. ..P;.:..7.X...` */
                                                  1514:      .pword      0x508FE1, 0x32000B, 0x508FEF, 0x320010, 0xE00001, 0x3A0034, 0xB3C090, 0x07C1B1  /* 0x009330 ..P..2..P..2...4.:...... */
                                                  1515:      .pword      0x805410, 0x905820, 0xB3C091, 0x07D50C, 0x370043, 0xEB4080, 0x985801, 0x805410  /* 0x009340 .T. X.......C.7.@..X..T. */
                                                  1516:      .pword      0x900090, 0xA09001, 0x980011, 0x370029, 0xEB4080, 0x985801, 0x805410, 0x900090  /* 0x009350 .........).7.@..X..T.... */
                                                  1517:      .pword      0xA09001, 0x980011, 0x370022, 0x905880, 0x6080EF, 0x508FE1, 0x32000B, 0x508FEF  /* 0x009360 ......".7.X...`..P..2..P */
                                                  1518:      .pword      0x320010, 0xE00001, 0x3A0019, 0xB3C010, 0x07C194, 0x805410, 0x905820, 0xB3C011  /* 0x009370 ..2.....:.......T. X.... */
                                                  1519:      .pword      0x07D4EF, 0x370026, 0xEB4080, 0x985801, 0x805410, 0x900090, 0xA09001, 0x980011  /* 0x009380 ...&.7.@..X..T.......... */
                                                  1520:      .pword      0x37000C, 0xEB4080, 0x985801, 0x805410, 0x900090, 0xA09001, 0x980011, 0x370005  /* 0x009390 ..7.@..X..T............7 */
                                                  1521:      .pword      0xB3C018, 0x370003, 0xB3C018, 0x370001, 0xB3C018, 0xE00408, 0x320007, 0xEB4080  /* 0x0093A0 .....7.....7........2.@. */
                                                  1522:      .pword      0x805410, 0x985801, 0x805410, 0x900090, 0xA09001, 0x980011, 0xE24A5B, 0x320004  /* 0x0093B0 .T..X..T..........[J...2 */
                                                  1523:      .pword      0xEF6A5A, 0xAB6A58, 0x32FFA6, 0x370004, 0xA86A58, 0x370002, 0xEB4400, 0x37FF36  /* 0x0093C0 Zj.Xj...2..7Xj...7.D.6.7 */
                                                  1524:      .pword      0x78054F, 0xBE044F, 0x060000, 0xB007EF, 0xBE9F88, 0xBE9F8A, 0xBE9F8C, 0x781F8E  /* 0x0093D0 O.xO...................x */
                                                  1525:      .pword      0x9FB7C0, 0x9FB7B1, 0x244002, 0x200003, 0x9F3FB2, 0x9F3FC3, 0xBE0602, 0xEB0080  /* 0x0093E0 .......@$.. .?..?....... */
                                                  1526:      .pword      0xB81160, 0x020932, 0x000000, 0x97B1CF, 0x200302, 0x200011, 0x2FFA20, 0x40000F  /* 0x0093F0 `..2.......... ..  ./..@ */
                                                  1527:      .pword      0x020AAA, 0x000000, 0x2FFECE, 0x200301, 0x500F81, 0x3A016B, 0x2FFA21, 0x40808F  /* 0x009400 ......../.. ..Pk.:!./..@ */
                                                  1528:      .pword      0x508064, 0xEB0080, 0xBE0250, 0x24C422, 0x242323, 0x520F82, 0x5A8F83, 0x320004  /* 0x009410 d.P...P..".$##$..R..Z..2 */
                                                  1529:      .pword      0xE80081, 0x508FEC, 0x3AFFF7, 0x37015A, 0x2FFFC2, 0xB98902, 0x20030E, 0x470702  /* 0x009420 .....P..:Z.7../..... ..G */
                                                  1530:      .pword      0xDD08C2, 0x2FFA22, 0x41010F, 0x410081, 0x78010E, 0x2FFA20, 0x40000F, 0x02416C  /* 0x009430 ..."./..A..A..x ./..@lA. */
                                                  1531:      .pword      0x000000, 0x200308, 0x54050E, 0x2FFA23, 0x41818F, 0x41800E, 0x97B1CF, 0x78010A  /* 0x009440 ..... ..T#./..A..A.....x */
                                                  1532:      .pword      0x200011, 0x020AAA, 0x000000, 0x2FFECE, 0x500F8A, 0x3A0143, 0x780188, 0x2FFA22  /* 0x009450 .. ......../..PC.:..x"./ */
                                                  1533:      .pword      0x41010F, 0xB80060, 0x023BAC, 0x000000, 0xBE0400, 0x97953F, 0x9795CF, 0x2FFA24  /* 0x009460 ..A`...;.......?.....$./ */
                                                  1534:      .pword      0x42020F, 0x420068, 0x200102, 0x280441, 0x024288, 0x000000, 0x2FFEAE, 0xE00000  /* 0x009470 ..Bh.B.. A.(.B....../... */
                                                  1535:      .pword      0x3A0130, 0x200124, 0xEB0080, 0xBE010C, 0x2FF900, 0x40000F, 0x023A96, 0x000000  /* 0x009480 0.:$. ......../..@.:.... */
                                                  1536:      .pword      0x212CD0, 0x97908F, 0x508F80, 0x3A001E, 0x20000E, 0x97985F, 0x9798EF, 0x97997F  /* 0x009490 .,!.....P..:.. _........ */
                                                  1537:      .pword      0x97A18F, 0x978A0F, 0x978A9F, 0x978B2F, 0x978BBF, 0x9FB7D4, 0x9FB7E5, 0x9FB7F6  /* 0x0094A0 ........./.............. */
                                                  1538:      .pword      0x9FBF87, 0xE0000E, 0x320005, 0xE10004, 0xE18805, 0xE19006, 0xE19807, 0x39010C  /* 0x0094B0 ........2..............9 */
                                                  1539:      .pword      0x20003E, 0x97B25F, 0x97B2EF, 0x97B37F, 0x97BB8F, 0xE10004, 0xE18805, 0xE19006  /* 0x0094C0 >. _.................... */
                                                  1540:      .pword      0xE19807, 0x320107, 0x97985F, 0x9798EF, 0x97997F, 0x97A18F, 0x9F8F80, 0x9F8F91  /* 0x0094D0 .....2_................. */
                                                  1541:      .pword      0x9F8FA2, 0x9F8FB3, 0x2FFC20, 0x40000F, 0x2FFD02, 0x41010F, 0x97A09F, 0x7080D0  /* 0x0094E0 ...... ./..@../..A.....p */
                                                  1542:      .pword      0x9FA791, 0x500F82, 0x3AFFFB, 0xE00001, 0x3A00F1, 0x23F8A0, 0xE00000, 0x32000A  /* 0x0094F0 .....P..:.....:..#.....2 */
                                                  1543:      .pword      0xBE010A, 0xB00402, 0xB08003, 0x2FF904, 0x42020F, 0xEB0000, 0x023F8A, 0x000000  /* 0x009500 .........../..B....?.... */
                                                  1544:      .pword      0xE00000, 0x3400E6, 0xBE010A, 0xB10282, 0xB18003, 0x9FB7D2, 0x9FB7E3, 0xEF2A68  /* 0x009510 .....4...............h*. */
                                                  1545:      .pword      0xEF2A6A, 0x23E530, 0xB40A9A, 0x9790AF, 0x500001, 0x8854D0, 0x8054D0, 0x97B1BF  /* 0x009520 j*.0.#........P.T..T.... */
                                                  1546:      .pword      0xB99800, 0x8854D0, 0x200010, 0x023E9C, 0x000000, 0x20001E, 0x9FB79C, 0x9FB7AD  /* 0x009530 ....T... .>...... ...... */
                                                  1547:      .pword      0x37007F, 0x97B1CF, 0x200082, 0x200011, 0x2FF7A0, 0x40000F, 0x020AAA, 0x000000  /* 0x009540 ..7..... .. ../..@...... */
                                                  1548:      .pword      0x780180, 0x518FE8, 0x3A00B7, 0x97387F, 0x9738DF, 0x680001, 0x8854D0, 0x2FF7A2  /* 0x009550 ..x..Q..:.8..8...h.T.../ */
                                                  1549:      .pword      0x41010F, 0xBE0008, 0x023BAC, 0x000000, 0xBE0400, 0x96F8EF, 0x6080E1, 0x97401F  /* 0x009560 ..A....;............`.@. */
                                                  1550:      .pword      0x96F95F, 0x714000, 0xFB8000, 0x700001, 0x3A00A1, 0x97B35F, 0x97B3EF, 0x530368  /* 0x009570 _...@q.....p..:_.....h.S */
                                                  1551:      .pword      0x5B83E0, 0x9FB7D6, 0x9FB7E7, 0x97385F, 0x9738EF, 0xB00240, 0xB08001, 0x530F80  /* 0x009580 ..[......_8..8.@.......S */
                                                  1552:      .pword      0x5B8F81, 0x390094, 0x2003CA, 0x37004F, 0xB85161, 0x510F80, 0x598F81, 0x360001  /* 0x009590 ..[..9.. O.7aQ...Q..Y..6 */
                                                  1553:      .pword      0x780500, 0x97B1CF, 0x78010A, 0x200011, 0x2FFA20, 0x40000F, 0x020AAA, 0x000000  /* 0x0095A0 ..x.....x..  ./..@...... */
                                                  1554:      .pword      0x780580, 0x558F8A, 0x3A0087, 0x78018A, 0x2FFA22, 0x41010F, 0xBE0008, 0x023BAC  /* 0x0095B0 ..x..U..:..x"./..A....;. */
                                                  1555:      .pword      0x000000, 0xBE0400, 0x8054D1, 0xB03DF1, 0x97387F, 0x97395F, 0x690000, 0x508000  /* 0x0095C0 .......T..=..8._9...i..P */
                                                  1556:      .pword      0x8854D0, 0x8054D0, 0x97B3BF, 0xB9B800, 0x8854D0, 0xEB0300, 0xEB0280, 0x204004  /* 0x0095D0 .T..T........T........@  */
                                                  1557:      .pword      0x78018A, 0x2FFA22, 0x41010F, 0x97387F, 0x97808F, 0x020C04, 0x000000, 0xBE0600  /* 0x0095E0 ..x"./..A.8............. */
                                                  1558:      .pword      0x2FF824, 0x42020F, 0x78018A, 0x2FFA22, 0x41010F, 0x97387F, 0x97808F, 0x02271C  /* 0x0095F0 $./..B..x"./..A.8.....'. */
                                                  1559:      .pword      0x000000, 0x97B13F, 0xB98002, 0xE00000, 0x35005B, 0x320001, 0x2FFE7E, 0xB85861  /* 0x009600 ...?........[.5..2~./aX. */
                                                  1560:      .pword      0x97B25F, 0x97B2EF, 0x520200, 0x5A8281, 0x9FB7D4, 0x9FB7E5, 0x9F3FFC, 0x9F878D  /* 0x009610 _.......R..Z.......?.... */
                                                  1561:      .pword      0x97395F, 0x9739EF, 0x510000, 0x598081, 0x9F3FD0, 0x9F3FE1, 0x97387F, 0x9738DF  /* 0x009620 _9..9...Q..Y.?..?..8..8. */
                                                  1562:      .pword      0x688000, 0xB42A9A, 0x78050B, 0x97385F, 0x9738EF, 0x500FE0, 0x588FE0, 0x3AFFAC  /* 0x009630 ..h.*...x_8..8...P..X..: */
                                                  1563:      .pword      0x97B35F, 0x97B3EF, 0x200240, 0x530F80, 0x5B8FE0, 0x3EFF7B, 0x97B61F, 0x97B6AF  /* 0x009640 _.....@. ..S..[{.>...... */
                                                  1564:      .pword      0x97B1CF, 0x200242, 0x200011, 0x2FFA20, 0x40000F, 0x020AAA, 0x000000, 0x200241  /* 0x009650 ...B. ..  ./..@......A.  */
                                                  1565:      .pword      0x500F81, 0x3A0030, 0x200203, 0x2FFA22, 0x41010F, 0xBE0008, 0x023BAC, 0x000000  /* 0x009660 ..P0.:.. "./..A....;.... */
                                                  1566:      .pword      0x97A11F, 0x97A1AF, 0x510F80, 0x598F81, 0x3A0027, 0x212CD0, 0x9F9780, 0x979A7F  /* 0x009670 ........Q..Y'.:.,!...... */
                                                  1567:      .pword      0x97A28F, 0x97A31F, 0x97A3AF, 0x9F8FC4, 0x9F8FD5, 0x9F8FE6, 0x9F8FF7, 0x8054D1  /* 0x009680 ......................T. */
                                                  1568:      .pword      0xB03DF1, 0x97387F, 0x97395F, 0x690000, 0x508000, 0x8854D0, 0x8054D0, 0x97B2BF  /* 0x009690 .=..8._9...i..P.T..T.... */
                                                  1569:      .pword      0xB9A800, 0x8854D0, 0x2DEAD0, 0xB9A800, 0xEB0300, 0x780280, 0xEB0200, 0x200123  /* 0x0096A0 ....T...-........x...#.  */
                                                  1570:      .pword      0x2FF902, 0x41010F, 0xBE000C, 0x020C04, 0x000000, 0x370007, 0x2FFEBE, 0x370005  /* 0x0096B0 ../..A...........7../..7 */
                                                  1571:      .pword      0x2FFE8E, 0x370003, 0x2FFECE, 0x370001, 0x2FFE6E, 0xEF2A9A, 0x807BB0, 0x97B33F  /* 0x0096C0 ../..7../..7n./.*..{.?.. */
                                                  1572:      .pword      0xB9B000, 0xE00000, 0x320006, 0xFE0000, 0x2FFE9E, 0x370003, 0x2FFEBE, 0x370001  /* 0x0096D0 ........2...../..7../..7 */
                                                  1573:      .pword      0x2FFE5E, 0x78000E, 0x78074F, 0xBE064F, 0xBE054F, 0xBE044F, 0xB107EF, 0x060000  /* 0x0096E0 ^./..xO.xO..O..O........ */
                                                  1574:      .pword      0x4787F0, 0xBE9F88, 0xBE9F8A, 0xBE9F8C, 0x781F8E, 0x8078F9, 0x20F220, 0xA11010  /* 0x0096F0 ..G...........x.x. . ... */
                                                  1575:      .pword      0xA02010, 0x8053C0, 0x7845B0, 0xE80000, 0x784430, 0x784530, 0xE80000, 0x7840B0  /* 0x009700 . ..S..Ex...0Dx0Ex....@x */
                                                  1576:      .pword      0x9FEF81, 0x904020, 0x9FEF90, 0x9FE7E0, 0x57817C, 0xEB6900, 0x200024, 0x200005  /* 0x009710 ... @.......|.W.i.$. ..  */
                                                  1577:      .pword      0x200691, 0xEBC000, 0x07D339, 0xE00400, 0x3A0005, 0xB3C281, 0x20F160, 0x784801  /* 0x009720 .. ...9.......:...`. .Hx */
                                                  1578:      .pword      0xB3C011, 0x3700DF, 0xFB8408, 0xDD5648, 0x460608, 0xFB850B, 0x8053C0, 0xEB4080  /* 0x009730 .....7...HV...F....S..@. */
                                                  1579:      .pword      0x560F8A, 0x3600D7, 0x40000A, 0x784681, 0x9FBF89, 0x780580, 0x78000B, 0x7845B0  /* 0x009740 ..V..6..@.Fx.....x..x.Ex */
                                                  1580:      .pword      0x7840B0, 0x50CFE9, 0x3A000E, 0x20F222, 0xA01012, 0x784010, 0x5101EF, 0x784980  /* 0x009750 .@x..P..:". ....@x..Q.Ix */
                                                  1581:      .pword      0xA31800, 0x320004, 0xA33812, 0x320002, 0xA12012, 0x370005, 0x20F224, 0xA13014  /* 0x009760 .....2.8...2. ...7$. .0. */
                                                  1582:      .pword      0x370002, 0x50CFE4, 0x320006, 0xFB858B, 0x45050B, 0x78000A, 0xB40A78, 0x780580  /* 0x009770 ..7..P..2.....E..xx....x */
                                                  1583:      .pword      0x3700AF, 0x784490, 0x7840D0, 0x9FEFA1, 0x780100, 0x784752, 0x784052, 0x7840D2  /* 0x009780 ..7.Dx.@x.....xRGxR@x.@x */
                                                  1584:      .pword      0x9FB7F2, 0x780182, 0x784153, 0x9FB7F3, 0x200405, 0x20F224, 0x628194, 0x320004  /* 0x009790 .....xSAx..... $. ..b..2 */
                                                  1585:      .pword      0x52006B, 0x784010, 0x9FE7C0, 0x37000A, 0x5781FC, 0x07C864, 0xE00400, 0x3A0006  /* 0x0097A0 k.R.@x.....7..Wd.......: */
                                                  1586:      .pword      0xFB858B, 0x45050B, 0x78000A, 0xB40A78, 0x780580, 0x370092, 0x97B88F, 0xE00001  /* 0x0097B0 .....E..xx....x..7...... */
                                                  1587:      .pword      0x32000B, 0x904061, 0x504F89, 0x3200C4, 0x780401, 0x780418, 0xE00008, 0x320004  /* 0x0097C0 ..2a@..OP..2..x..x.....2 */
                                                  1588:      .pword      0x904068, 0x504F89, 0x3AFFFA, 0x37000E, 0x200080, 0x07B63B, 0x780400, 0xE00008  /* 0x0097D0 h@..OP..:..7.. ;....x... */
                                                  1589:      .pword      0x32000E, 0x984469, 0x97E14F, 0x984472, 0xEB0000, 0x980410, 0x980420, 0x97B98F  /* 0x0097E0 ..2iD.O..rD....... ..... */
                                                  1590:      .pword      0x780C03, 0x9FBF88, 0x200060, 0x07B62D, 0x9FB7E0, 0xE00000, 0x3A00AB, 0x97B2FF  /* 0x0097F0 ..x...`. -..........:... */
                                                  1591:      .pword      0xE80585, 0xB3C011, 0x370069, 0x97B06F, 0x980420, 0xFB858B, 0x45050B, 0x8053C9  /* 0x009800 ......i.7o.. .......E.S. */
                                                  1592:      .pword      0x44858A, 0x370004, 0xFB858B, 0x45050B, 0x8053C9, 0x44858A, 0x560F8A, 0x360058  /* 0x009810 ..D..7.....E.S...D..VX.6 */
                                                  1593:      .pword      0xE0040E, 0x3200A4, 0xEB4680, 0x78441B, 0xB3C051, 0x10CFDB, 0x320004, 0xFB8408  /* 0x009820 .....2.F..DxQ.......2... */
                                                  1594:      .pword      0x450508, 0x44858A, 0x370047, 0x200220, 0x07B60C, 0x780080, 0xA7F001, 0xEA0081  /* 0x009830 ..E..DG.7 . .....x...... */
                                                  1595:      .pword      0xE90081, 0xDE08CF, 0x78415B, 0x985822, 0x78010B, 0x7841D2, 0x985833, 0xFB81D2  /* 0x009840 ......[Ax"X...x.Ax3X.... */
                                                  1596:      .pword      0x980043, 0xFB8252, 0xDD2248, 0x420183, 0x980043, 0x904192, 0xFB8183, 0x980023  /* 0x009850 C..R..H"...BC...A....#.. */
                                                  1597:      .pword      0xEB0100, 0x980012, 0x900210, 0xA0A004, 0x980014, 0x900210, 0xA09004, 0x980014  /* 0x009860 ........................ */
                                                  1598:      .pword      0xB82260, 0x980804, 0x980815, 0x985802, 0x97E2CF, 0x985815, 0x900950, 0x203004  /* 0x009870 `"........X.....X.P...0  */
                                                  1599:      .pword      0x610104, 0x201005, 0x510F85, 0x3A0011, 0xE00003, 0x3A0003, 0x200012, 0x980022  /* 0x009880 ..a.. ..Q..:.....:.. ".. */
                                                  1600:      .pword      0x370004, 0x518FF0, 0x360002, 0x200102, 0x980022, 0x900120, 0xE90102, 0x200013  /* 0x009890 ..7..Q..6.. ".. .......  */
                                                  1601:      .pword      0xDD1902, 0x980022, 0x900110, 0xA1A002, 0x980012, 0x900120, 0x980032, 0x97B1EF  /* 0x0098A0 ..."........... ..2..... */
                                                  1602:      .pword      0x9001A3, 0x780803, 0x97B26F, 0x980220, 0xE8468D, 0xFB8408, 0x450508, 0x44858A  /* 0x0098B0 .....xo.. ...F......E..D */
                                                  1603:      .pword      0xE00401, 0x3A000A, 0x560F8A, 0x360007, 0x574F8D, 0x3EFFAD, 0xEB4080, 0x370004  /* 0x0098C0 .....:..V..6.OW..>.@...7 */
                                                  1604:      .pword      0xEB4680, 0x78408D, 0x370001, 0xEB4080, 0x56CF8E, 0x3A0007, 0xE00401, 0x3A0008  /* 0x0098D0 .F..@x..7.@...V..:.....: */
                                                  1605:      .pword      0x560F8A, 0x3EFF34, 0x97BC8F, 0xEB4080, 0x370004, 0x97BC8F, 0xB3C011, 0x370001  /* 0x0098E0 ..V4.>....@...7........7 */
                                                  1606:      .pword      0x97BC8F, 0xEB4000, 0xE00009, 0x320026, 0xE00401, 0x32001C, 0x370001, 0x78048A  /* 0x0098F0 ....@....&.2.....2..7..x */
                                                  1607:      .pword      0x780519, 0x900419, 0xE00008, 0x320010, 0x780298, 0x980495, 0x900028, 0xE00000  /* 0x009900 ..x........2..x...(..... */
                                                  1608:      .pword      0x320006, 0x780090, 0x980421, 0x07B538, 0x900028, 0xE00000, 0x3AFFFA, 0x780008  /* 0x009910 ..2..x!..8..(.......:..x */
                                                  1609:      .pword      0x07B533, 0x900419, 0xE00008, 0x3AFFF0, 0x780009, 0x07B52E, 0xE0000A, 0x3AFFE7  /* 0x009920 3..........:..x........: */
                                                  1610:      .pword      0xEB4000, 0x370008, 0x20F120, 0x97E90F, 0x784802, 0x97E99F, 0xFB8003, 0x8878D0  /* 0x009930 .@...7 . ....Hx.......x. */
                                                  1611:      .pword      0x8878F9, 0xB3C010, 0x78074F, 0xBE064F, 0xBE054F, 0xBE044F, 0xB1010F, 0x060000  /* 0x009940 .x....O.xO..O..O........ */
                                                  1612:      .pword      0x97BC0F, 0x37FF50, 0x900298, 0x97B26F, 0x780A05, 0x97E82F, 0x984220, 0xEB0000  /* 0x009950 ...P.7...o....x/.. B.... */
                                                  1613:      .pword      0x980220, 0x980414, 0x97E8AF, 0xE00401, 0x32FF4E, 0x37FF54, 0xEB4680, 0x37FFB8  /* 0x009960  ...........N.2T.7.F...7 */
                                                  1614:      .pword      0x4787F0, 0xBE9F88, 0xBE9F8A, 0xBE9F8C, 0x781F8E, 0x780700, 0x90686E, 0x9FEFE0  /* 0x009970 ..G...........x..xnh.... */
                                                  1615:      .pword      0x504FE1, 0x32000F, 0x504FE3, 0x3A001B, 0xDD1C42, 0xDE14CE, 0x740489, 0xDD1442  /* 0x009980 .OP..2.OP..:B.......tB.. */
                                                  1616:      .pword      0x2FFF82, 0x20FFF3, 0x9FB7B2, 0x9FB7C3, 0x2FFFFA, 0x20FFFB, 0xEB4180, 0x9FE7C3  /* 0x009990 ../.. ......../.. .A.... */
                                                  1617:      .pword      0x370018, 0xB91863, 0xB81163, 0x400183, 0x614261, 0x9FE7C4, 0xD10483, 0xD38402  /* 0x0099A0 ..7c..c....@aBa......... */
                                                  1618:      .pword      0x20FF80, 0x200001, 0x9FB7B0, 0x9FB7C1, 0x2FFFFA, 0x20000B, 0x37000A, 0x410402  /* 0x0099B0 .. .. ......../.. ..7..A */
                                                  1619:      .pword      0x498483, 0x2FFF82, 0x200003, 0x9FB7B2, 0x9FB7C3, 0x2FFFFA, 0x20000B, 0xEB4180  /* 0x0099C0 ..I../.. ......../.. .A. */
                                                  1620:      .pword      0x9FE7C3, 0x900E4E, 0x900EDE, 0xBE010C, 0xBE0008, 0x07B4C6, 0x90012E, 0x9001BE  /* 0x0099D0 ...N.................... */
                                                  1621:      .pword      0x410200, 0x498281, 0x9FB7D4, 0x9FB7E5, 0x560161, 0x5E81E0, 0x610008, 0x618209  /* 0x0099E0 ..A..I......a.V..^..a..a */
                                                  1622:      .pword      0xEB0280, 0xDD24C0, 0x200008, 0xB80261, 0x740404, 0x748485, 0x90102E, 0x900620  /* 0x0099F0 ....$... a....t..t... .. */
                                                  1623:      .pword      0x9006B0, 0x97B05F, 0x97B0EF, 0x560F80, 0x5E8F81, 0x3A0067, 0x97E8EF, 0x50CFE3  /* 0x009A00 ..._.......V..^g.:.....P */
                                                  1624:      .pword      0x3A0004, 0x90101E, 0x780088, 0x07D3F3, 0x3700C5, 0x97EA6F, 0x524FE2, 0x3A0005  /* 0x009A10 ..:.....x.....7o...OR..: */
                                                  1625:      .pword      0x90101E, 0x780088, 0x07D481, 0xEB0080, 0x3700BD, 0xB80060, 0x97EAEF, 0x52CFE1  /* 0x009A20 .....x........7`.......R */
                                                  1626:      .pword      0x3A00B9, 0x90101E, 0x400008, 0xFB8210, 0xEB0280, 0x9FB7D4, 0x9FB7E5, 0x97E2CF  /* 0x009A30 ..:.....@............... */
                                                  1627:      .pword      0xE00405, 0x320008, 0x97B05F, 0x97B0EF, 0xDD0A4C, 0xDE0044, 0x720000, 0xDE08C4  /* 0x009A40 .....2_.....L..D....r... */
                                                  1628:      .pword      0x9FB7D0, 0x9FB7E1, 0x440461, 0x4C84E0, 0x610008, 0x618109, 0xEB0180, 0xDD12C0  /* 0x009A50 ......a.D..L..a..a...... */
                                                  1629:      .pword      0x200004, 0xB80161, 0x720202, 0x728283, 0x9FB7F4, 0x9FBF85, 0x520FE0, 0x5A8FE0  /* 0x009A60 .. a....r..r........R..Z */
                                                  1630:      .pword      0x3A0018, 0x200011, 0x78000E, 0x07C897, 0xE00400, 0x32009B, 0x460461, 0x4E84E0  /* 0x009A70 ..:.. ..x........2a.F..N */
                                                  1631:      .pword      0x90113E, 0x90109E, 0x90104E, 0x900242, 0xBE0108, 0x010004, 0xE00400, 0x3A0006  /* 0x009A80 >.....N..B.............: */
                                                  1632:      .pword      0x90102E, 0xEB8100, 0xEB8180, 0x980022, 0x980033, 0x37008B, 0x90102E, 0x980028  /* 0x009A90 ........."..3....7...(.. */
                                                  1633:      .pword      0x980039, 0x90101E, 0x97B2FF, 0x400005, 0xFB8110, 0xEB0180, 0x97E04F, 0xE00400  /* 0x009AA0 9..........@......O..... */
                                                  1634:      .pword      0x320009, 0xDD1844, 0xDE10CC, 0x700081, 0xDD1044, 0x97B15F, 0x97B1EF, 0x400002  /* 0x009AB0 ..2D.......pD.._.......@ */
                                                  1635:      .pword      0x488083, 0x370070, 0x61016F, 0xEB0180, 0xDD1848, 0xDE10C8, 0x700081, 0xDD1048  /* 0x009AC0 ..Hp.7o.a...H.......pH.. */
                                                  1636:      .pword      0x97B25F, 0x97B2EF, 0x400004, 0x488085, 0x370065, 0x200011, 0x78000E, 0x07C863  /* 0x009AD0 _.......@..He.7.. ..xc.. */
                                                  1637:      .pword      0xE00400, 0x320067, 0x90113E, 0x90109E, 0x90104E, 0x900242, 0x97B15F, 0x97B1EF  /* 0x009AE0 ...g.2>.....N..B.._..... */
                                                  1638:      .pword      0x010004, 0xE00400, 0x3A0006, 0x90102E, 0xEB8100, 0xEB8180, 0x980022, 0x980033  /* 0x009AF0 ........:........."..3.. */
                                                  1639:      .pword      0x370058, 0x90102E, 0x97B15F, 0x97B1EF, 0x980022, 0x980033, 0x90696E, 0x514FE3  /* 0x009B00 X.7..._....."..3..ni..OQ */
                                                  1640:      .pword      0x3A0004, 0x90101E, 0x780088, 0x07D373, 0x370045, 0x514FE2, 0x3A0005, 0x90101E  /* 0x009B10 ..:.....xs..E.7.OQ..:... */
                                                  1641:      .pword      0x780088, 0x07D402, 0xEB0080, 0x37003E, 0xB80060, 0x514FE1, 0x3A003B, 0x90109E  /* 0x009B20 ..x......>.7`...OQ;.:... */
                                                  1642:      .pword      0x408008, 0xFB8110, 0xEB0180, 0x97E24F, 0xE00404, 0x32001C, 0xDD1ACC, 0xDE1144  /* 0x009B30 ..@......O.......2...D.. */
                                                  1643:      .pword      0x728102, 0xDE19C4, 0x440461, 0x4C84E0, 0x900A4E, 0x900ADE, 0x520261, 0x5A82E0  /* 0x009B40 ..r...a.D..LN.....a.R..Z */
                                                  1644:      .pword      0x620008, 0x628309, 0xEB0380, 0xDD32C0, 0x200004, 0xB80361, 0x720206, 0x728287  /* 0x009B50 ..b..b....2... a....r..r */
                                                  1645:      .pword      0x408084, 0xFB8211, 0xEB0280, 0xDD2844, 0xDE20CC, 0x700081, 0xDD2044, 0x410000  /* 0x009B60 ..@......D(.. ...pD ...A */
                                                  1646:      .pword      0x498081, 0x370018, 0x440461, 0x4C84E0, 0x900A4E, 0x900ADE, 0x520261, 0x5A82E0  /* 0x009B70 ..I..7a.D..LN.....a.R..Z */
                                                  1647:      .pword      0x620008, 0x628309, 0xEB0380, 0xDD32C0, 0x200004, 0xB80361, 0x720206, 0x728287  /* 0x009B80 ..b..b....2... a....r..r */
                                                  1648:      .pword      0x408084, 0xFB8211, 0x62026F, 0xEB0280, 0xDD2848, 0xDE20C8, 0x700081, 0xDD2048  /* 0x009B90 ..@...o.b...H(.. ...pH . */
                                                  1649:      .pword      0x410000, 0x498081, 0xBE0500, 0x97B03F, 0x97B0CF, 0x550F80, 0x5D8F81, 0x360001  /* 0x009BA0 ..A..I...?.......U..]..6 */
                                                  1650:      .pword      0xBE0500, 0xBE000A, 0x78074F, 0xBE064F, 0xBE054F, 0xBE044F, 0xB1010F, 0x060000  /* 0x009BB0 ......O.xO..O..O........ */
                                                  1651:      .pword      0x4787F8, 0xBE9F88, 0xBE9F8A, 0xBE9F8C, 0x781F8E, 0xBE0600, 0x807B40, 0x9FB7D0  /* 0x009BC0 ..G...........x...@{.... */
                                                  1652:      .pword      0x807B22, 0x807B33, 0x9FB7F2, 0x9FBF83, 0x9FB792, 0x9FB7A3, 0x9FB7B0, 0x07CF7F  /* 0x009BD0 "{.3{................... */
                                                  1653:      .pword      0x780080, 0xEB0000, 0xE00001, 0x3A00FD, 0x97B1DF, 0x987180, 0xEB0000, 0xE0000C  /* 0x009BE0 ..x........:....q....... */
                                                  1654:      .pword      0x3200F8, 0xE0000D, 0x3200F6, 0x97B07F, 0x97B88F, 0x500FE0, 0x588FE0, 0x32009F  /* 0x009BF0 ..2.....2........P..X..2 */
                                                  1655:      .pword      0x900063, 0x9000F3, 0x97B17F, 0x97B98F, 0x510F80, 0x598F81, 0x32009D, 0xEB0180  /* 0x009C00 c.............Q..Y..2... */
                                                  1656:      .pword      0x9FB7E3, 0xEB4700, 0xEB0480, 0xB3C20B, 0x280001, 0x57807E, 0x07C5D7, 0x400FE1  /* 0x009C10 ....G.........(~.W.....@ */
                                                  1657:      .pword      0x3A0005, 0xB3C0D0, 0x97B0DF, 0x987080, 0xEB0000, 0x3700DB, 0x97B01F, 0x97B0AF  /* 0x009C20 ..:.......p......7...... */
                                                  1658:      .pword      0x9FAFE0, 0x9FAFF1, 0xEB0100, 0x9FB782, 0x20002A, 0x500FE0, 0x588FE0, 0x3A0006  /* 0x009C30 ............*. ..P..X..: */
                                                  1659:      .pword      0x97B1DF, 0x900163, 0x9001F3, 0x9FAFE2, 0x9FAFF3, 0xEB0500, 0x78020A, 0x2FFE03  /* 0x009C40 ...c................x../ */
                                                  1660:      .pword      0x41818F, 0x2FFDC2, 0x41010F, 0x5780F8, 0x57807E, 0x07BC96, 0x780400, 0x780008  /* 0x009C50 ..A../..A..W~.W.....x..x */
                                                  1661:      .pword      0x0701C6, 0x97B17F, 0x97B98F, 0x500F82, 0x588F83, 0x32000D, 0xE8050A, 0xE00008  /* 0x009C60 ...........P..X..2...... */
                                                  1662:      .pword      0x320002, 0xE00418, 0x3AFFEB, 0x904838, 0x504FEF, 0x32FFE8, 0xB3C0D0, 0x97B1DF  /* 0x009C70 ..2.....:8H..OP..2...... */
                                                  1663:      .pword      0x987180, 0xEB0000, 0x3700AE, 0x97B01F, 0x97B0AF, 0x9FB7F0, 0x9FBF81, 0x904828  /* 0x009C80 .q......7............(H. */
                                                  1664:      .pword      0x504F8B, 0x3A0009, 0xB3C0A0, 0xE94000, 0xFB0080, 0x78C0E8, 0x50CF8B, 0x32FFFB  /* 0x009C90 .OP..:....@......x..P..2 */
                                                  1665:      .pword      0x504FE7, 0x34001B, 0x370001, 0xB3C0A0, 0xFB0200, 0xB3C013, 0xEB0100, 0xFB0080  /* 0x009CA0 .OP..4..7............... */
                                                  1666:      .pword      0x78C0E8, 0x7CF601, 0xE80489, 0xE94000, 0x548F8D, 0x3A0002, 0x784703, 0x780482  /* 0x009CB0 ..x..|....@...T..:.Gx..x */
                                                  1667:      .pword      0x504FE7, 0x3CFFF5, 0x97B16F, 0x5100E6, 0x408084, 0x9FB7E1, 0xB3C2E1, 0x7CF601  /* 0x009CC0 .OP..<o....Q..@........| */
                                                  1668:      .pword      0xE80489, 0x548F8D, 0x3A0002, 0xB3C01E, 0xEB0480, 0xFB0080, 0x78C0E8, 0x50CF8B  /* 0x009CD0 .....T..:...........x..P */
                                                  1669:      .pword      0x3A0005, 0xE94000, 0xFB0080, 0x78C0E8, 0x50CF8B, 0x32FFFB, 0xFB0200, 0xE00400  /* 0x009CE0 ..:.@......x..P..2...... */
                                                  1670:      .pword      0x35000D, 0xB3C013, 0xEB0100, 0xFB0080, 0x78C0E8, 0x7CF601, 0xE80489, 0xE94000  /* 0x009CF0 ..5...........x..|....@. */
                                                  1671:      .pword      0x548F8D, 0x3A0002, 0x784703, 0x780482, 0x404FE1, 0x3AFFF5, 0x97B1EF, 0xE88003  /* 0x009D00 ..T..:.Gx..x.O@..:...... */
                                                  1672:      .pword      0x400004, 0x9FB7E0, 0xB3C2F0, 0x7CF600, 0xE80489, 0x548F8D, 0x3A0002, 0xB3C01E  /* 0x009D10 ..@........|.....T..:... */
                                                  1673:      .pword      0xEB0480, 0x97B07F, 0x97B88F, 0x500FE0, 0x588FE0, 0x320012, 0x97B15F, 0x900062  /* 0x009D20 ...........P..X..2_..b.. */
                                                  1674:      .pword      0x9000F2, 0x97B17F, 0x97B98F, 0x500F82, 0x588F83, 0x3AFF6E, 0x370009, 0xEB0180  /* 0x009D30 ...........P..Xn.:..7... */
                                                  1675:      .pword      0x9FB7E3, 0xEB4700, 0xEB0480, 0x370004, 0xEB0000, 0x9FB7E0, 0xEB4700, 0xEB0480  /* 0x009D40 ....G......7.......G.... */
                                                  1676:      .pword      0x97B0EF, 0xE88001, 0xB3C3A1, 0x7CF601, 0xE80489, 0x548F8D, 0x3A0002, 0xB3C01E  /* 0x009D50 ...........|.....T..:... */
                                                  1677:      .pword      0xEB0480, 0x97B15F, 0x907112, 0x7CF602, 0xE80089, 0x508F8D, 0x320003, 0xE00001  /* 0x009D60 ..._...q...|.....P..2... */
                                                  1678:      .pword      0x3A0003, 0x370001, 0xB3C01E, 0x78048D, 0xE0040E, 0x3A0003, 0xE00009, 0x3C0023  /* 0x009D70 ..:..7.....x.....:...#.< */
                                                  1679:      .pword      0x37002D, 0xE00009, 0x34000B, 0x78008C, 0x460109, 0xE8020C, 0xE90189, 0xD10183  /* 0x009D80 -.7.....4..x..F......... */
                                                  1680:      .pword      0x420203, 0x784191, 0x785892, 0x785103, 0x508F84, 0x3AFFFB, 0xE9020D, 0x460204  /* 0x009D90 ..B.Ax.Xx.Qx..P..:.....F */
                                                  1681:      .pword      0x52018C, 0xE90083, 0x508109, 0xA94042, 0x34000C, 0xE80489, 0x460109, 0x460603  /* 0x009DA0 ..R.....PB@...4.....F..F */
                                                  1682:      .pword      0xEA8489, 0x408089, 0x784192, 0x78591C, 0x785603, 0xE98081, 0xE88181, 0xA94042  /* 0x009DB0 .....@.Ax.Yx.Vx......B@. */
                                                  1683:      .pword      0x3CFFF9, 0xEB4A00, 0x37000E, 0x78008C, 0x460109, 0xE8020C, 0xE90189, 0xD10183  /* 0x009DC0 ..<.J...7..x..F......... */
                                                  1684:      .pword      0x420203, 0x784191, 0x785892, 0x785103, 0x508F84, 0x3AFFFB, 0x460489, 0xEB4080  /* 0x009DD0 ..B.Ax.Xx.Qx..P..:..F.@. */
                                                  1685:      .pword      0x984491, 0x78074F, 0xBE064F, 0xBE054F, 0xBE044F, 0xB1018F, 0x060000, 0x4787F6  /* 0x009DE0 .D.O.xO..O..O..........G */
                                                  1686:      .pword      0xBE9F88, 0xBE9F8A, 0xBE9F8C, 0x781F8E, 0x780500, 0x90113A, 0x90108A, 0x90104A  /* 0x009DF0 ...........x..x:.....J.. */
                                                  1687:      .pword      0x900242, 0xBE011A, 0x010004, 0x784080, 0x200080, 0xE00401, 0x3200EA, 0x90102A  /* 0x009E00 B.........@x.. .....2*.. */
                                                  1688:      .pword      0x78183A, 0x78102A, 0x90160A, 0x93F96C, 0x200030, 0xB3C551, 0x514F81, 0x3A00E1  /* 0x009E10 :.x*.x...l..0. Q...OQ..: */
                                                  1689:      .pword      0x93F97C, 0xB3CAA1, 0x514F81, 0x3A00DD, 0xEB4000, 0x9FE7B0, 0x9FE7A0, 0x370004  /* 0x009E20 |......OQ..:.@.........7 */
                                                  1690:      .pword      0xB3C011, 0x9FE7B1, 0xB3C012, 0x9FE7A2, 0x90158A, 0x2000E1, 0x78000B, 0x07D274  /* 0x009E30 ................. ..xt.. */
                                                  1691:      .pword      0x9049DB, 0x9FEF83, 0x986D53, 0xB80261, 0x9FB7A4, 0x9FB7B5, 0x42033A, 0x4A83AA  /* 0x009E40 .I....Sm.a........:.B..J */
                                                  1692:      .pword      0x9FB7F6, 0x9FBF87, 0x980526, 0x980537, 0x90540B, 0x986D48, 0x200161, 0x78000B  /* 0x009E50 ......&..7...T.Hm.a. ..x */
                                                  1693:      .pword      0x07D263, 0xEB0080, 0x980D60, 0x980D71, 0x500FE0, 0x588FE0, 0x3A0005, 0x200241  /* 0x009E60 c.....`..q....P..X..:A.  */
                                                  1694:      .pword      0x78000B, 0x07D1C5, 0x980D60, 0x980D71, 0x90096A, 0xFB8408, 0xEB0480, 0x90087A  /* 0x009E70 ..x...`..q..j........z.. */
                                                  1695:      .pword      0xB98008, 0xB81208, 0x9FB7D4, 0x9FB7E5, 0x400285, 0x9FB7E5, 0x97B37F, 0x97BB8F  /* 0x009E80 ..............@......... */
                                                  1696:      .pword      0x97B05F, 0x97B0EF, 0x400306, 0x488387, 0x9FB7F6, 0x9FBF87, 0x980546, 0x980557  /* 0x009E90 _.......@..H......F..W.. */
                                                  1697:      .pword      0x200111, 0x78000B, 0x07D241, 0x780700, 0x98155E, 0x200131, 0x78000B, 0x07D23C  /* 0x009EA0 .. ..xA....x^..1. ..x<.. */
                                                  1698:      .pword      0xB80461, 0x540FE0, 0x5C8FE0, 0x3A0004, 0x200201, 0x78000B, 0x07D1A0, 0xBE0400  /* 0x009EB0 a....T..\..:.. ..x...... */
                                                  1699:      .pword      0x2000B1, 0x78000B, 0x07D231, 0x780680, 0x200240, 0xE0000D, 0x32004B, 0xA3080D  /* 0x009EC0 .. ..x1....x@. ...K.2... */
                                                  1700:      .pword      0x3A0049, 0xDD7045, 0xE90000, 0x40000D, 0x090011, 0xD8800D, 0xB80161, 0x9FAFF2  /* 0x009ED0 I.:Ep......@......a..... */
                                                  1701:      .pword      0x9FB783, 0x97B22F, 0x97B2BF, 0x540004, 0x5C8085, 0x97B35F, 0x97B3EF, 0x500006  /* 0x009EE0 .../.......T..\_.......P */
                                                  1702:      .pword      0x588087, 0x500002, 0x588083, 0x97EB8F, 0xFB8107, 0xEB0180, 0x07B235, 0x980D20  /* 0x009EF0 ..X..P..X.........5.. .. */
                                                  1703:      .pword      0x980D31, 0xB3C032, 0x986D62, 0x2FFF42, 0x200003, 0x500F82, 0x588F83, 0x3E0002  /* 0x009F00 1..2..bm.B./.. ..P..X..> */
                                                  1704:      .pword      0xB3C022, 0x986D62, 0x20FF44, 0x200005, 0x500F84, 0x588F85, 0x3E0003, 0xB3C010  /* 0x009F10 "..bm.D. .. ..P..X..>... */
                                                  1705:      .pword      0x986D60, 0x370011, 0x90686A, 0x504FE3, 0x3A000E, 0x2002C1, 0x78000B, 0x07D167  /* 0x009F20 `m...7jh..OP..:.. ..xg.. */
                                                  1706:      .pword      0x980560, 0x980571, 0x97AB7F, 0x97B38F, 0x97B17F, 0x97B98F, 0x410006, 0x498087  /* 0x009F30 `..q................A..I */
                                                  1707:      .pword      0x980D00, 0x980D11, 0x37000A, 0xB82260, 0x980564, 0x980575, 0xDE7044, 0x97B37F  /* 0x009F40 ........7`".d..u..Dp.... */
                                                  1708:      .pword      0x97BB8F, 0x400006, 0x4B80E0, 0x980D00, 0x980D11, 0x200240, 0x202001, 0x568F81  /* 0x009F50 .....@..K......@. .  ..V */
                                                  1709:      .pword      0x3E0001, 0xEB0000, 0x9068EA, 0x50CFE3, 0x320007, 0xE00000, 0x32003A, 0x90C12C  /* 0x009F60 ..>....h...P..2...:.2,.. */
                                                  1710:      .pword      0xB3CD81, 0x414081, 0x50CFE1, 0x3E0035, 0x90513C, 0xFB8102, 0x9050CC, 0xDD08C8  /* 0x009F70 ....@A..P5.><Q.....P.... */
                                                  1711:      .pword      0x710081, 0x3A0008, 0x90C12C, 0xB3CD81, 0x414081, 0x50CFE1, 0x3E0005, 0xE00000  /* 0x009F80 ..q..:,......@A..P..>... */
                                                  1712:      .pword      0x320028, 0x370003, 0x200030, 0x370001, 0x200030, 0x97E3AF, 0xE00407, 0x3A0010  /* 0x009F90 (.2..70. ..70. ........: */
                                                  1713:      .pword      0x90123A, 0x90108A, 0x90702C, 0xFB8000, 0x90713C, 0xDD1148, 0x700102, 0xBE031A  /* 0x009FA0 :.....,p....<q.H....p... */
                                                  1714:      .pword      0x410106, 0x4B81E0, 0x90104A, 0x900244, 0x010004, 0xE00400, 0x320011, 0x37FF3A  /* 0x009FB0 ..A..KJ..D..........2:.7 */
                                                  1715:      .pword      0x97E3BF, 0xE00407, 0x3A000E, 0x90123A, 0x90108A, 0x200066, 0x200007, 0x43013A  /* 0x009FC0 ........::.....f. .. :.C */
                                                  1716:      .pword      0x4B81AA, 0x90104A, 0x900244, 0x010004, 0xE00400, 0x3AFF2A, 0x200080, 0x370001  /* 0x009FD0 ..KJ..D........*.:.. ..7 */
                                                  1717:      .pword      0x200080, 0x78074F, 0xBE064F, 0xBE054F, 0xBE044F, 0xB1016F, 0x060000, 0x900A20  /* 0x009FE0 .. O.xO..O..O..o..... .. */
                                                  1718:      .pword      0xEB0280, 0xDD22C0, 0x200004, 0x900950, 0xEB0180, 0x720002, 0x728083, 0x060000  /* 0x009FF0 ...."... P.......r..r... */
                                                  1719:      .popsection
                                                  1720:  
                                                  1721:      ; Bootloader code block intended for program region 'CONFIG4'
                                                  1722:      ; 0x00ABF8 to 0x00ABFA, length 0x000002 (3 bytes; needs 0 pages)
                                                  1723:      .pushsection    EZBL_BTLDR_CONFIG_WORD_CONFIG4, address(0x00ABF8), code, keep
                                                  1724:      .pword      0x00FF33                                                                        /* 0x00ABF8 3..                      */
                                                  1725:      .popsection
                                                  1726:  
                                                  1727:      ; Bootloader code block intended for program region 'CONFIG3'
                                                  1728:      ; 0x00ABFA to 0x00ABFC, length 0x000002 (3 bytes; needs 0 pages)
                                                  1729:      .pushsection    EZBL_BTLDR_CONFIG_WORD_CONFIG3, address(0x00ABFA), code, keep
                                                  1730:      .pword      0x00FFC0                                                                        /* 0x00ABFA ...                      */
                                                  1731:      .popsection
                                                  1732:  
                                                  1733:      ; Bootloader code block intended for program region 'CONFIG2'
                                                  1734:      ; 0x00ABFC to 0x00ABFE, length 0x000002 (3 bytes; needs 0 pages)
                                                  1735:      .pushsection    EZBL_BTLDR_CONFIG_WORD_CONFIG2, address(0x00ABFC), code, keep
                                                  1736:      .pword      0x003B8E                                                                        /* 0x00ABFC .;.                      */
                                                  1737:      .popsection
                                                  1738:  
                                                  1739:      ; Bootloader code block intended for program region 'CONFIG1'
                                                  1740:      ; 0x00ABFE to 0x00AC00, length 0x000002 (3 bytes; needs 0 pages)
                                                  1741:      .pushsection    EZBL_BTLDR_CONFIG_WORD_CONFIG1, address(0x00ABFE), code, keep
                                                  1742:      .pword      0x003F60                                                                        /* 0x00ABFE `?.                      */
                                                  1743:      .popsection
                                                  1744:  
                                                  1745:  
                                                  1746:  #if !defined(EZBL_HIDE_BOOT_SYMBOLS)
                                                  1747:  
                                                  1748:  ;----Bootloader symbol export table----
                                                  1749:      .weak       ___curbrk
                                                  1750:      .weak       ___curbrk
                                                  1751:      .weak       _bufferStatus
                                                  1752:      .type       _bufferStatus, @object
                                                  1753:      .weak       _ButtonsLastState
                                                  1754:      .type       _ButtonsLastState, @object
                                                  1755:      .weak       _ButtonsPushed
                                                  1756:      .type       _ButtonsPushed, @object
                                                  1757:      .weak       _ButtonsReleased
                                                  1758:      .type       _ButtonsReleased, @object
                                                  1759:      .weak       _ButtonsToggled
                                                  1760:      .type       _ButtonsToggled, @object
                                                  1761:      .weak       _deviceAddress
                                                  1762:      .type       _deviceAddress, @object
                                                  1763:      .weak       _EZBL_appIsRunning
                                                  1764:      .weak       _EZBL_AppPreInstall
                                                  1765:      .type       _EZBL_AppPreInstall, @object
                                                  1766:      .global     _EZBL_ForwardBootloaderISR
                                                  1767:      .weak       _EZBL_NVMKey
                                                  1768:      .weak       _gDataBuffer
                                                  1769:      .type       _gDataBuffer, @object
                                                  1770:      .weak       _gDriveArray
                                                  1771:      .type       _gDriveArray, @object
                                                  1772:      .weak       _gDriveSlotOpen
                                                  1773:      .type       _gDriveSlotOpen, @object
                                                  1774:      .weak       _gFATBuffer
                                                  1775:      .type       _gFATBuffer, @object
                                                  1776:      .weak       _globalParameters
                                                  1777:      .type       _globalParameters, @object
                                                  1778:      .weak       _NOW_dispatcherActive
                                                  1779:      .weak       _NOW_Fcy
                                                  1780:      .weak       _NOW_internalCount
                                                  1781:      .weak       _NOW_microsecond
                                                  1782:      .type       _NOW_microsecond, @object
                                                  1783:      .weak       _NOW_millisecond
                                                  1784:      .type       _NOW_millisecond, @object
                                                  1785:      .weak       _NOW_ms
                                                  1786:      .weak       _NOW_sec
                                                  1787:      .weak       _NOW_second
                                                  1788:      .type       _NOW_second, @object
                                                  1789:      .weak       _NOW_systemFrequency
                                                  1790:      .type       _NOW_systemFrequency, @object
                                                  1791:      .weak       _NOW_timeOffset
                                                  1792:      .weak       _NOW_timerCallbackHead
                                                  1793:      .weak       _NOW_timerSFRPtr
                                                  1794:      .weak       _NOW_us
                                                  1795:      .weak       _pCurrentConfigurationDescriptor
                                                  1796:      .type       _pCurrentConfigurationDescriptor, @object
                                                  1797:      .weak       _pDeviceDescriptor
                                                  1798:      .type       _pDeviceDescriptor, @object
                                                  1799:      .weak       _timestampGet
                                                  1800:      .type       _timestampGet, @object
                                                  1801:      .weak       _usbClientDrvTable
                                                  1802:      .weak       _usbMediaInterfaceTable
                                                  1803:      .weak       _usbOverrideHostState
                                                  1804:      .type       _usbOverrideHostState, @object
                                                  1805:      .weak       _usbTPL
                                                  1806:      .weak       _ButtonPeek
                                                  1807:      .weak       _ButtonRead
                                                  1808:      .weak       _EZBL_AddrInTable
                                                  1809:      .weak       _EZBL_CRC32
                                                  1810:      .weak       _EZBL_CallISR
                                                  1811:      .weak       _EZBL_DisableInterrupts
                                                  1812:      .weak       _EZBL_EraseAll
                                                  1813:      .weak       _EZBL_EraseAppSpace
                                                  1814:      .weak       _EZBL_ErasePage
                                                  1815:      .weak       _EZBL_IsAppPresent
                                                  1816:      .weak       _EZBL_IsPageErased
                                                  1817:      .type       _EZBL_MSDBootloaderTask, @function
                                                  1818:      .weak       _EZBL_MSDBootloaderTask
                                                  1819:      .weak       _EZBL_MapInv
                                                  1820:      .type       _EZBL_MapInvEx, @function
                                                  1821:      .weak       _EZBL_MapInvEx
                                                  1822:      .weak       _EZBL_Mul3Div2
                                                  1823:      .type       _EZBL_PreInstall, @function
                                                  1824:      .weak       _EZBL_PreInstall
                                                  1825:      .weak       _EZBL_RAMCompare
                                                  1826:      .weak       _EZBL_RAMCopy
                                                  1827:      .type       _EZBL_RAMCopyEx, @function
                                                  1828:      .weak       _EZBL_RAMCopyEx
                                                  1829:      .weak       _EZBL_RAMSet
                                                  1830:      .type       _EZBL_RAMSetEx, @function
                                                  1831:      .weak       _EZBL_RAMSetEx
                                                  1832:      .type       _EZBL_ROMCompare, @function
                                                  1833:      .weak       _EZBL_ROMCompare
                                                  1834:      .weak       _EZBL_ROMCompareEx
                                                  1835:      .weak       _EZBL_ReadFlash
                                                  1836:      .type       _EZBL_ReadFlashInstruction, @function
                                                  1837:      .weak       _EZBL_ReadFlashInstruction
                                                  1838:      .weak       _EZBL_ReadPackedFlash
                                                  1839:      .weak       _EZBL_ReadTablePair
                                                  1840:      .weak       _EZBL_RestoreAppErasable
                                                  1841:      .weak       _EZBL_RestoreInterrupts
                                                  1842:      .weak       _EZBL_VerifyROM
                                                  1843:      .weak       _EZBL_WriteNVMCON
                                                  1844:      .type       _EZBL_WriteROM, @function
                                                  1845:      .weak       _EZBL_WriteROM
                                                  1846:      .weak       _EZBL_WriteROMEx
                                                  1847:      .type       _EZBL_WriteROMOnlyOnce, @function
                                                  1848:      .weak       _EZBL_WriteROMOnlyOnce
                                                  1849:      .weak       _EZBL_WriteROMOnlyOnceEx
                                                  1850:      .type       _FILEIO_CacheDirectory, @function
                                                  1851:      .weak       _FILEIO_CacheDirectory
                                                  1852:      .type       _FILEIO_CharToDrive, @function
                                                  1853:      .weak       _FILEIO_CharToDrive
                                                  1854:      .type       _FILEIO_Close, @function
                                                  1855:      .weak       _FILEIO_Close
                                                  1856:      .type       _FILEIO_ClusterAllocate, @function
                                                  1857:      .weak       _FILEIO_ClusterAllocate
                                                  1858:      .type       _FILEIO_ClusterToSector, @function
                                                  1859:      .weak       _FILEIO_ClusterToSector
                                                  1860:      .type       _FILEIO_CreateFirstCluster, @function
                                                  1861:      .weak       _FILEIO_CreateFirstCluster
                                                  1862:      .type       _FILEIO_DirectoryChange, @function
                                                  1863:      .weak       _FILEIO_DirectoryChange
                                                  1864:      .type       _FILEIO_DirectoryChangeSingle, @function
                                                  1865:      .weak       _FILEIO_DirectoryChangeSingle
                                                  1866:      .type       _FILEIO_DirectoryEntryCache, @function
                                                  1867:      .weak       _FILEIO_DirectoryEntryCache
                                                  1868:      .type       _FILEIO_DirectoryEntryCreate, @function
                                                  1869:      .weak       _FILEIO_DirectoryEntryCreate
                                                  1870:      .type       _FILEIO_DirectoryEntryFindEmpty, @function
                                                  1871:      .weak       _FILEIO_DirectoryEntryFindEmpty
                                                  1872:      .type       _FILEIO_DirectoryEntryPopulate, @function
                                                  1873:      .weak       _FILEIO_DirectoryEntryPopulate
                                                  1874:      .type       _FILEIO_DirectoryMake, @function
                                                  1875:      .weak       _FILEIO_DirectoryMake
                                                  1876:      .type       _FILEIO_DirectoryMakeSingle, @function
                                                  1877:      .weak       _FILEIO_DirectoryMakeSingle
                                                  1878:      .type       _FILEIO_DirectoryRemove, @function
                                                  1879:      .weak       _FILEIO_DirectoryRemove
                                                  1880:      .type       _FILEIO_DirectoryRemoveSingle, @function
                                                  1881:      .weak       _FILEIO_DirectoryRemoveSingle
                                                  1882:      .type       _FILEIO_DotEntryWrite, @function
                                                  1883:      .weak       _FILEIO_DotEntryWrite
                                                  1884:      .type       _FILEIO_DriveMount, @function
                                                  1885:      .weak       _FILEIO_DriveMount
                                                  1886:      .type       _FILEIO_DrivePropertiesGet, @function
                                                  1887:      .weak       _FILEIO_DrivePropertiesGet
                                                  1888:      .type       _FILEIO_DriveUnmount, @function
                                                  1889:      .weak       _FILEIO_DriveUnmount
                                                  1890:      .type       _FILEIO_Eof, @function
                                                  1891:      .weak       _FILEIO_Eof
                                                  1892:      .type       _FILEIO_EraseCluster, @function
                                                  1893:      .weak       _FILEIO_EraseCluster
                                                  1894:      .type       _FILEIO_EraseClusterChain, @function
                                                  1895:      .weak       _FILEIO_EraseClusterChain
                                                  1896:      .type       _FILEIO_EraseFile, @function
                                                  1897:      .weak       _FILEIO_EraseFile
                                                  1898:      .type       _FILEIO_ErrorClear, @function
                                                  1899:      .weak       _FILEIO_ErrorClear
                                                  1900:      .type       _FILEIO_ErrorGet, @function
                                                  1901:      .weak       _FILEIO_ErrorGet
                                                  1902:      .type       _FILEIO_FATWrite, @function
                                                  1903:      .weak       _FILEIO_FATWrite
                                                  1904:      .type       _FILEIO_FileNameTypeGet, @function
                                                  1905:      .weak       _FILEIO_FileNameTypeGet
                                                  1906:      .type       _FILEIO_FileSystemTypeGet, @function
                                                  1907:      .weak       _FILEIO_FileSystemTypeGet
                                                  1908:      .type       _FILEIO_Find, @function
                                                  1909:      .weak       _FILEIO_Find
                                                  1910:      .type       _FILEIO_FindEmptyCluster, @function
                                                  1911:      .weak       _FILEIO_FindEmptyCluster
                                                  1912:      .type       _FILEIO_FindNextDelimiter, @function
                                                  1913:      .weak       _FILEIO_FindNextDelimiter
                                                  1914:      .type       _FILEIO_FindShortFileName, @function
                                                  1915:      .weak       _FILEIO_FindShortFileName
                                                  1916:      .type       _FILEIO_Flush, @function
                                                  1917:      .weak       _FILEIO_Flush
                                                  1918:      .type       _FILEIO_FlushBuffer, @function
                                                  1919:      .weak       _FILEIO_FlushBuffer
                                                  1920:      .type       _FILEIO_ForceRecache, @function
                                                  1921:      .weak       _FILEIO_ForceRecache
                                                  1922:      .type       _FILEIO_FormatShortFileName, @function
                                                  1923:      .weak       _FILEIO_FormatShortFileName
                                                  1924:      .type       _FILEIO_GetChar, @function
                                                  1925:      .weak       _FILEIO_GetChar
                                                  1926:      .type       _FILEIO_GetSingleBuffer, @function
                                                  1927:      .weak       _FILEIO_GetSingleBuffer
                                                  1928:      .type       _FILEIO_Initialize, @function
                                                  1929:      .weak       _FILEIO_Initialize
                                                  1930:      .type       _FILEIO_IsClusterAllocated, @function
                                                  1931:      .weak       _FILEIO_IsClusterAllocated
                                                  1932:      .type       _FILEIO_LoadMBR, @function
                                                  1933:      .weak       _FILEIO_LoadMBR
                                                  1934:      .type       _FILEIO_MediaDetect, @function
                                                  1935:      .weak       _FILEIO_MediaDetect
                                                  1936:      .type       _FILEIO_NextClusterGet, @function
                                                  1937:      .weak       _FILEIO_NextClusterGet
                                                  1938:      .type       _FILEIO_Open, @function
                                                  1939:      .weak       _FILEIO_Open
                                                  1940:      .type       _FILEIO_PutChar, @function
                                                  1941:      .weak       _FILEIO_PutChar
                                                  1942:      .type       _FILEIO_Read, @function
                                                  1943:      .weak       _FILEIO_Read
                                                  1944:      .type       _FILEIO_RegisterTimestampGet, @function
                                                  1945:      .weak       _FILEIO_RegisterTimestampGet
                                                  1946:      .type       _FILEIO_Remove, @function
                                                  1947:      .weak       _FILEIO_Remove
                                                  1948:      .type       _FILEIO_Rename, @function
                                                  1949:      .weak       _FILEIO_Rename
                                                  1950:      .type       _FILEIO_Seek, @function
                                                  1951:      .weak       _FILEIO_Seek
                                                  1952:      .type       _FILEIO_ShortFileNameCompare, @function
                                                  1953:      .weak       _FILEIO_ShortFileNameCompare
                                                  1954:      .type       _FILEIO_ShortFileNameConvert, @function
                                                  1955:      .weak       _FILEIO_ShortFileNameConvert
                                                  1956:      .type       _FILEIO_Tell, @function
                                                  1957:      .weak       _FILEIO_Tell
                                                  1958:      .type       _FILEIO_Write, @function
                                                  1959:      .weak       _FILEIO_Write
                                                  1960:      .type       _GetTimestamp, @function
                                                  1961:      .weak       _GetTimestamp
                                                  1962:      .type       _LEDInv, @function
                                                  1963:      .weak       _LEDInv
                                                  1964:      .weak       _LEDSet
                                                  1965:      .weak       _LEDToggle
                                                  1966:      .type       _LEDWrite, @function
                                                  1967:      .weak       _LEDWrite
                                                  1968:      .weak       _NOW_32
                                                  1969:      .weak       _NOW_64
                                                  1970:      .weak       _NOW_CreateTask
                                                  1971:      .type       _NOW_EnableInterrupts, @function
                                                  1972:      .weak       _NOW_EnableInterrupts
                                                  1973:      .weak       _NOW_EndTask
                                                  1974:      .weak       _NOW_ISR
                                                  1975:      .weak       _NOW_IntEnable
                                                  1976:      .weak       _NOW_TMR1_ResetConst
                                                  1977:      .weak       _NOW_TaskDispatcher
                                                  1978:      .weak       _NOW_Wait
                                                  1979:      .type       _ReadRam16bit, @function
                                                  1980:      .weak       _ReadRam16bit
                                                  1981:      .type       _ReadRam32bit, @function
                                                  1982:      .weak       _ReadRam32bit
                                                  1983:      .type       _SYS_Initialize, @function
                                                  1984:      .weak       _SYS_Initialize
                                                  1985:      .type       _USBHostClearEndpointErrors, @function
                                                  1986:      .weak       _USBHostClearEndpointErrors
                                                  1987:      .type       _USBHostDeviceStatus, @function
                                                  1988:      .weak       _USBHostDeviceStatus
                                                  1989:      .type       _USBHostInit, @function
                                                  1990:      .weak       _USBHostInit
                                                  1991:      .type       _USBHostIssueDeviceRequest, @function
                                                  1992:      .weak       _USBHostIssueDeviceRequest
                                                  1993:      .type       _USBHostMSDDeviceStatus, @function
                                                  1994:      .weak       _USBHostMSDDeviceStatus
                                                  1995:      .type       _USBHostMSDEventHandler, @function
                                                  1996:      .weak       _USBHostMSDEventHandler
                                                  1997:      .type       _USBHostMSDInitialize, @function
                                                  1998:      .weak       _USBHostMSDInitialize
                                                  1999:      .type       _USBHostMSDSCSIEventHandler, @function
                                                  2000:      .weak       _USBHostMSDSCSIEventHandler
                                                  2001:      .type       _USBHostMSDSCSIInitialize, @function
                                                  2002:      .weak       _USBHostMSDSCSIInitialize
                                                  2003:      .type       _USBHostMSDSCSIMediaDeinitialize, @function
                                                  2004:      .weak       _USBHostMSDSCSIMediaDeinitialize
                                                  2005:      .type       _USBHostMSDSCSIMediaDetect, @function
                                                  2006:      .weak       _USBHostMSDSCSIMediaDetect
                                                  2007:      .type       _USBHostMSDSCSIMediaInitialize, @function
                                                  2008:      .weak       _USBHostMSDSCSIMediaInitialize
                                                  2009:      .type       _USBHostMSDSCSISectorRead, @function
                                                  2010:      .weak       _USBHostMSDSCSISectorRead
                                                  2011:      .type       _USBHostMSDSCSISectorWrite, @function
                                                  2012:      .weak       _USBHostMSDSCSISectorWrite
                                                  2013:      .type       _USBHostMSDSCSIWriteProtectState, @function
                                                  2014:      .weak       _USBHostMSDSCSIWriteProtectState
                                                  2015:      .type       _USBHostMSDTransfer, @function
                                                  2016:      .weak       _USBHostMSDTransfer
                                                  2017:      .type       _USBHostMSDTransferIsComplete, @function
                                                  2018:      .weak       _USBHostMSDTransferIsComplete
                                                  2019:      .type       _USBHostRead, @function
                                                  2020:      .weak       _USBHostRead
                                                  2021:      .type       _USBHostSetNAKTimeout, @function
                                                  2022:      .weak       _USBHostSetNAKTimeout
                                                  2023:      .type       _USBHostShutdown, @function
                                                  2024:      .weak       _USBHostShutdown
                                                  2025:      .type       _USBHostTransferIsComplete, @function
                                                  2026:      .weak       _USBHostTransferIsComplete
                                                  2027:      .type       _USBHostWrite, @function
                                                  2028:      .weak       _USBHostWrite
                                                  2029:      .weak       _USB_ApplicationEventHandler
                                                  2030:      .weak       __Getmem
                                                  2031:      .weak       __T1Interrupt
                                                  2032:      .type       __USB1Interrupt, @function
                                                  2033:      .weak       __USB1Interrupt
                                                  2034:      .type       __USBHostMSDSCSI_TestUnitReady, @function
                                                  2035:      .weak       __USBHostMSDSCSI_TestUnitReady
                                                  2036:      .type       __USBHostMSD_GetNextTag, @function
                                                  2037:      .weak       __USBHostMSD_GetNextTag
                                                  2038:      .type       __USBHostMSD_ResetStateJump, @function
                                                  2039:      .weak       __USBHostMSD_ResetStateJump
                                                  2040:      .type       __USB_CheckCommandAndEnumerationAttempts, @function
                                                  2041:      .weak       __USB_CheckCommandAndEnumerationAttempts
                                                  2042:      .type       __USB_FindClassDriver, @function
                                                  2043:      .weak       __USB_FindClassDriver
                                                  2044:      .type       __USB_FindDeviceLevelClientDriver, @function
                                                  2045:      .weak       __USB_FindDeviceLevelClientDriver
                                                  2046:      .type       __USB_FindEndpoint, @function
                                                  2047:      .weak       __USB_FindEndpoint
                                                  2048:      .type       __USB_FindServiceEndpoint, @function
                                                  2049:      .weak       __USB_FindServiceEndpoint
                                                  2050:      .type       __USB_FreeConfigMemory, @function
                                                  2051:      .weak       __USB_FreeConfigMemory
                                                  2052:      .type       __USB_FreeMemory, @function
                                                  2053:      .weak       __USB_FreeMemory
                                                  2054:      .type       __USB_InitControlRead, @function
                                                  2055:      .weak       __USB_InitControlRead
                                                  2056:      .type       __USB_InitControlWrite, @function
                                                  2057:      .weak       __USB_InitControlWrite
                                                  2058:      .type       __USB_InitRead, @function
                                                  2059:      .weak       __USB_InitRead
                                                  2060:      .type       __USB_InitWrite, @function
                                                  2061:      .weak       __USB_InitWrite
                                                  2062:      .type       __USB_NotifyClients, @function
                                                  2063:      .weak       __USB_NotifyClients
                                                  2064:      .type       __USB_ResetDATA0, @function
                                                  2065:      .weak       __USB_ResetDATA0
                                                  2066:      .type       __USB_SendToken, @function
                                                  2067:      .weak       __USB_SendToken
                                                  2068:      .type       __USB_SetBDT, @function
                                                  2069:      .weak       __USB_SetBDT
                                                  2070:      .weak       ___udivsi3
                                                  2071:      .weak       _brk
                                                  2072:      .weak       _free
                                                  2073:      .type       _main, @function
                                                  2074:      .weak       _main
                                                  2075:      .weak       _malloc
                                                  2076:      .weak       _memcmp
                                                  2077:      .weak       _memcpy
                                                  2078:      .weak       _memset
                                                  2079:      .weak       _sbrk
                                                  2080:      .weak       _strlen
                                                  2081:      .weak       _strncpy
                                                  2082:      .weak       _EZBL_ButtonMap
                                                  2083:      .weak       _EZBL_InstallFILEIO2Flash
                                                  2084:      .weak       _EZBL_LEDMap
                                                  2085:      .weak       _EZBL_bootIDHash
                                                  2086:      .weak       _EZBL_bootIDHash0
                                                  2087:      .weak       _EZBL_bootIDHash1
                                                  2088:      .weak       _EZBL_bootIDHash2
                                                  2089:      .weak       _EZBL_bootIDHash3
                                                  2090:      .type       _FILEIO_DirectoryGetCurrent, @function
                                                  2091:      .weak       _FILEIO_DirectoryGetCurrent
                                                  2092:      .type       _FILEIO_FATRead, @function
                                                  2093:      .weak       _FILEIO_FATRead
                                                  2094:      .type       _FILEIO_FullClusterNumberGet, @function
                                                  2095:      .weak       _FILEIO_FullClusterNumberGet
                                                  2096:      .type       _FILEIO_LoadBootSector, @function
                                                  2097:      .weak       _FILEIO_LoadBootSector
                                                  2098:      .type       _USBHostMSDTasks, @function
                                                  2099:      .weak       _USBHostMSDTasks
                                                  2100:      .type       _USBHostTasks, @function
                                                  2101:      .weak       _USBHostTasks
                                                  2102:      .type       _USB_HostInterruptHandler, @function
                                                  2103:      .weak       _USB_HostInterruptHandler
                                                  2104:      .type       __USB_FindNextToken, @function
                                                  2105:      .weak       __USB_FindNextToken
                                                  2106:      .type       __USB_ParseConfigurationDescriptor, @function
                                                  2107:      .weak       __USB_ParseConfigurationDescriptor
                                                  2108:      .type       _gLongFileNameCharacters, @object
                                                  2109:      .weak       _gLongFileNameCharacters
                                                  2110:      .type       _gShortFileNameCharacters, @object
                                                  2111:      .weak       _gShortFileNameCharacters
                                                  2112:      .weak       _gUSBDrive
                                                  2113:      .weak       _EZBL_ADDRESSES_PER_SECTOR
                                                  2114:      .weak       _EZBL_APP_RESET_BASE
                                                  2115:      .weak       _EZBL_appBootloadState
                                                  2116:      .weak       _EZBL_BACKBUG_ADDRESS
                                                  2117:      .weak       _EZBL_BACKBUG_MASK
                                                  2118:      .weak       _EZBL_BOOTLOADER_SIZE
                                                  2119:      .weak       _EZBL_ButtonMapLen
                                                  2120:      .weak       _EZBL_CODE_PROTECT_ADDRESS
                                                  2121:      .weak       _EZBL_CODE_PROTECT_MASK
                                                  2122:      .weak       _EZBL_CONFIG_BASE
                                                  2123:      .weak       _EZBL_CONFIG_END_ADDRESS
                                                  2124:      .weak       _EZBL_CONFIG1
                                                  2125:      .weak       _EZBL_CONFIG2
                                                  2126:      .weak       _EZBL_CONFIG3
                                                  2127:      .weak       _EZBL_CONFIG4
                                                  2128:      .weak       _EZBL_DEVID_ADDRESS
                                                  2129:      .weak       _EZBL_DEVID_MASK
                                                  2130:      .weak       _EZBL_DEVID_VALUE
                                                  2131:      .weak       _EZBL_FORWARD_IRQ_T1
                                                  2132:      .weak       _EZBL_FORWARD_IRQ_USB1
                                                  2133:      .weak       _EZBL_FORWARD_MASK_T1
                                                  2134:      .weak       _EZBL_FORWARD_MASK_USB1
                                                  2135:      .weak       _EZBL_FORWARD_POS_T1
                                                  2136:      .weak       _EZBL_FORWARD_POS_USB1
                                                  2137:      .weak       _EZBL_IGT_BASE
                                                  2138:      .weak       _EZBL_LEDMapLen
                                                  2139:      .weak       _EZBL_MAIN_FLASH_BASE
                                                  2140:      .weak       _EZBL_MAIN_FLASH_END_ADDRESS
                                                  2141:      .weak       _EZBL_RESERVED_BIT_ADDRESS
                                                  2142:      .weak       _EZBL_RESERVED_BIT_MASK
                                                  2143:      .weak       _EZBL_REVID_ADDRESS
                                                  2144:      .weak       _EZBL_REVID_MASK
                                                  2145:      .weak       EZBL_Dispatch_T1Interrupt
                                                  2146:      .weak       EZBL_Dispatch_USB1Interrupt
                                                  2147:  
                                                  2148:  
                                                  2149:  
                                                  2150:  ;----Bootloader symbol addresses----
                                                  2151:      .equ        ___curbrk, 0x000F7C
                                                  2152:      .equ        ___curbrk, 0x000F7C
                                                  2153:      .equ        _bufferStatus, 0x000F34
                                                  2154:      .equ        _ButtonsLastState, 0x000F6E
                                                  2155:      .equ        _ButtonsPushed, 0x000F72
                                                  2156:      .equ        _ButtonsReleased, 0x000F74
                                                  2157:      .equ        _ButtonsToggled, 0x000F70
                                                  2158:      .equ        _deviceAddress, 0x000A90
                                                  2159:      .equ        _EZBL_appIsRunning, 0x000F76
                                                  2160:      .equ        _EZBL_AppPreInstall, 0x000A92
                                                  2161:      .equ        _EZBL_ForwardBootloaderISR, 0x000A68
                                                  2162:      .equ        _EZBL_NVMKey, 0x000A9A
                                                  2163:      .equ        _gDataBuffer, 0x000AA4
                                                  2164:      .equ        _gDriveArray, 0x000EDE
                                                  2165:      .equ        _gDriveSlotOpen, 0x000A74
                                                  2166:      .equ        _gFATBuffer, 0x000CA4
                                                  2167:      .equ        _globalParameters, 0x000F64
                                                  2168:      .equ        _NOW_dispatcherActive, 0x000AA2
                                                  2169:      .equ        _NOW_Fcy, 0x000A70
                                                  2170:      .equ        _NOW_internalCount, 0x000F40
                                                  2171:      .equ        _NOW_microsecond, 0x000A9E
                                                  2172:      .equ        _NOW_millisecond, 0x000A6C
                                                  2173:      .equ        _NOW_ms, 0x000A6C
                                                  2174:      .equ        _NOW_sec, 0x000A70
                                                  2175:      .equ        _NOW_second, 0x000A70
                                                  2176:      .equ        _NOW_systemFrequency, 0x000A70
                                                  2177:      .equ        _NOW_timeOffset, 0x000F78
                                                  2178:      .equ        _NOW_timerCallbackHead, 0x000AA0
                                                  2179:      .equ        _NOW_timerSFRPtr, 0x000A9C
                                                  2180:      .equ        _NOW_us, 0x000A9E
                                                  2181:      .equ        _pCurrentConfigurationDescriptor, 0x000A78
                                                  2182:      .equ        _pDeviceDescriptor, 0x000A7A
                                                  2183:      .equ        _timestampGet, 0x000A76
                                                  2184:      .equ        _usbClientDrvTable, 0x000F5A
                                                  2185:      .equ        _usbMediaInterfaceTable, 0x000F50
                                                  2186:      .equ        _usbOverrideHostState, 0x000A7C
                                                  2187:      .equ        _usbTPL, 0x000F24
                                                  2188:      .equ        _ButtonPeek, 0x004216
                                                  2189:      .equ        _ButtonRead, 0x00414C
                                                  2190:      .equ        _EZBL_AddrInTable, 0x003BEE
                                                  2191:      .equ        _EZBL_CRC32, 0x003BAC
                                                  2192:      .equ        _EZBL_CallISR, 0x004334
                                                  2193:      .equ        _EZBL_DisableInterrupts, 0x004352
                                                  2194:      .equ        _EZBL_EraseAll, 0x003E9C
                                                  2195:      .equ        _EZBL_EraseAppSpace, 0x001F60
                                                  2196:      .equ        _EZBL_ErasePage, 0x004016
                                                  2197:      .equ        _EZBL_IsAppPresent, 0x003DCE
                                                  2198:      .equ        _EZBL_IsPageErased, 0x0040DC
                                                  2199:      .equ        _EZBL_MSDBootloaderTask, 0x001342
                                                  2200:      .equ        _EZBL_MapInv, 0x003FE6
                                                  2201:      .equ        _EZBL_MapInvEx, 0x003FE8
                                                  2202:      .equ        _EZBL_Mul3Div2, 0x00435A
                                                  2203:      .equ        _EZBL_PreInstall, 0x003F8A
                                                  2204:      .equ        _EZBL_RAMCompare, 0x004288
                                                  2205:      .equ        _EZBL_RAMCopy, 0x00416C
                                                  2206:      .equ        _EZBL_RAMCopyEx, 0x00416C
                                                  2207:      .equ        _EZBL_RAMSet, 0x004340
                                                  2208:      .equ        _EZBL_RAMSetEx, 0x004340
                                                  2209:      .equ        _EZBL_ROMCompare, 0x002C40
                                                  2210:      .equ        _EZBL_ROMCompareEx, 0x002C42
                                                  2211:      .equ        _EZBL_ReadFlash, 0x0042C8
                                                  2212:      .equ        _EZBL_ReadFlashInstruction, 0x0042C8
                                                  2213:      .equ        _EZBL_ReadPackedFlash, 0x003A96
                                                  2214:      .equ        _EZBL_ReadTablePair, 0x004128
                                                  2215:      .equ        _EZBL_RestoreAppErasable, 0x0029C2
                                                  2216:      .equ        _EZBL_RestoreInterrupts, 0x004368
                                                  2217:      .equ        _EZBL_VerifyROM, 0x00271C
                                                  2218:      .equ        _EZBL_WriteNVMCON, 0x003D26
                                                  2219:      .equ        _EZBL_WriteROM, 0x000C02
                                                  2220:      .equ        _EZBL_WriteROMEx, 0x000C04
                                                  2221:      .equ        _EZBL_WriteROMOnlyOnce, 0x0031B0
                                                  2222:      .equ        _EZBL_WriteROMOnlyOnceEx, 0x0031B2
                                                  2223:      .equ        _FILEIO_CacheDirectory, 0x00211E
                                                  2224:      .equ        _FILEIO_CharToDrive, 0x00422E
                                                  2225:      .equ        _FILEIO_Close, 0x00425A
                                                  2226:      .equ        _FILEIO_ClusterAllocate, 0x00332A
                                                  2227:      .equ        _FILEIO_ClusterToSector, 0x0039BC
                                                  2228:      .equ        _FILEIO_CreateFirstCluster, 0x002E8A
                                                  2229:      .equ        _FILEIO_DirectoryChange, 0x003C6C
                                                  2230:      .equ        _FILEIO_DirectoryChangeSingle, 0x0027CC
                                                  2231:      .equ        _FILEIO_DirectoryEntryCache, 0x001588
                                                  2232:      .equ        _FILEIO_DirectoryEntryCreate, 0x003C2E
                                                  2233:      .equ        _FILEIO_DirectoryEntryFindEmpty, 0x00312C
                                                  2234:      .equ        _FILEIO_DirectoryEntryPopulate, 0x001E80
                                                  2235:      .equ        _FILEIO_DirectoryMake, 0x003880
                                                  2236:      .equ        _FILEIO_DirectoryMakeSingle, 0x001BB0
                                                  2237:      .equ        _FILEIO_DirectoryRemove, 0x002CD6
                                                  2238:      .equ        _FILEIO_DirectoryRemoveSingle, 0x0032AE
                                                  2239:      .equ        _FILEIO_DotEntryWrite, 0x002DFA
                                                  2240:      .equ        _FILEIO_DriveMount, 0x00291C
                                                  2241:      .equ        _FILEIO_DrivePropertiesGet, 0x00121A
                                                  2242:      .equ        _FILEIO_DriveUnmount, 0x0036C6
                                                  2243:      .equ        _FILEIO_Eof, 0x0041AA
                                                  2244:      .equ        _FILEIO_EraseCluster, 0x003026
                                                  2245:      .equ        _FILEIO_EraseClusterChain, 0x002384
                                                  2246:      .equ        _FILEIO_EraseFile, 0x001CA8
                                                  2247:      .equ        _FILEIO_ErrorClear, 0x00431C
                                                  2248:      .equ        _FILEIO_ErrorGet, 0x0042B8
                                                  2249:      .equ        _FILEIO_FATWrite, 0x000742
                                                  2250:      .equ        _FILEIO_FileNameTypeGet, 0x0019BE
                                                  2251:      .equ        _FILEIO_FileSystemTypeGet, 0x0042A8
                                                  2252:      .equ        _FILEIO_Find, 0x002040
                                                  2253:      .equ        _FILEIO_FindEmptyCluster, 0x0022C0
                                                  2254:      .equ        _FILEIO_FindNextDelimiter, 0x0040B6
                                                  2255:      .equ        _FILEIO_FindShortFileName, 0x00146A
                                                  2256:      .equ        _FILEIO_Flush, 0x0021F4
                                                  2257:      .equ        _FILEIO_FlushBuffer, 0x002BA6
                                                  2258:      .equ        _FILEIO_ForceRecache, 0x003F2E
                                                  2259:      .equ        _FILEIO_FormatShortFileName, 0x002FA2
                                                  2260:      .equ        _FILEIO_GetChar, 0x0041C6
                                                  2261:      .equ        _FILEIO_GetSingleBuffer, 0x003ADE
                                                  2262:      .equ        _FILEIO_Initialize, 0x003ECE
                                                  2263:      .equ        _FILEIO_IsClusterAllocated, 0x003B24
                                                  2264:      .equ        _FILEIO_LoadMBR, 0x001AB8
                                                  2265:      .equ        _FILEIO_MediaDetect, 0x00434A
                                                  2266:      .equ        _FILEIO_NextClusterGet, 0x002B0A
                                                  2267:      .equ        _FILEIO_Open, 0x0010EC
                                                  2268:      .equ        _FILEIO_PutChar, 0x0041E2
                                                  2269:      .equ        _FILEIO_Read, 0x000AAA
                                                  2270:      .equ        _FILEIO_RegisterTimestampGet, 0x00436E
                                                  2271:      .equ        _FILEIO_Remove, 0x002500
                                                  2272:      .equ        _FILEIO_Rename, 0x000FBC
                                                  2273:      .equ        _FILEIO_Seek, 0x000932
                                                  2274:      .equ        _FILEIO_ShortFileNameCompare, 0x0030AA
                                                  2275:      .equ        _FILEIO_ShortFileNameConvert, 0x00339A
                                                  2276:      .equ        _FILEIO_Tell, 0x004310
                                                  2277:      .equ        _FILEIO_Write, 0x000D4E
                                                  2278:      .equ        _GetTimestamp, 0x0042F4
                                                  2279:      .equ        _LEDInv, 0x004362
                                                  2280:      .equ        _LEDSet, 0x004302
                                                  2281:      .equ        _LEDToggle, 0x004362
                                                  2282:      .equ        _LEDWrite, 0x004302
                                                  2283:      .equ        _NOW_32, 0x004066
                                                  2284:      .equ        _NOW_64, 0x004066
                                                  2285:      .equ        _NOW_CreateTask, 0x003970
                                                  2286:      .equ        _NOW_EnableInterrupts, 0x004296
                                                  2287:      .equ        _NOW_EndTask, 0x004244
                                                  2288:      .equ        _NOW_ISR, 0x00408E
                                                  2289:      .equ        _NOW_IntEnable, 0x004296
                                                  2290:      .equ        _NOW_TMR1_ResetConst, 0x003FB8
                                                  2291:      .equ        _NOW_TaskDispatcher, 0x003230
                                                  2292:      .equ        _NOW_Wait, 0x00403E
                                                  2293:      .equ        _ReadRam16bit, 0x004328
                                                  2294:      .equ        _ReadRam32bit, 0x0041FE
                                                  2295:      .equ        _SYS_Initialize, 0x003EFE
                                                  2296:      .equ        _USBHostClearEndpointErrors, 0x004102
                                                  2297:      .equ        _USBHostDeviceStatus, 0x003A06
                                                  2298:      .equ        _USBHostInit, 0x003E38
                                                  2299:      .equ        _USBHostIssueDeviceRequest, 0x0018B6
                                                  2300:      .equ        _USBHostMSDDeviceStatus, 0x0037D4
                                                  2301:      .equ        _USBHostMSDEventHandler, 0x00382A
                                                  2302:      .equ        _USBHostMSDInitialize, 0x001D9E
                                                  2303:      .equ        _USBHostMSDSCSIEventHandler, 0x003406
                                                  2304:      .equ        _USBHostMSDSCSIInitialize, 0x004372
                                                  2305:      .equ        _USBHostMSDSCSIMediaDeinitialize, 0x004376
                                                  2306:      .equ        _USBHostMSDSCSIMediaDetect, 0x0042E6
                                                  2307:      .equ        _USBHostMSDSCSIMediaInitialize, 0x00051C
                                                  2308:      .equ        _USBHostMSDSCSISectorRead, 0x002A68
                                                  2309:      .equ        _USBHostMSDSCSISectorWrite, 0x002668
                                                  2310:      .equ        _USBHostMSDSCSIWriteProtectState, 0x00437A
                                                  2311:      .equ        _USBHostMSDTransfer, 0x0025B4
                                                  2312:      .equ        _USBHostMSDTransferIsComplete, 0x003924
                                                  2313:      .equ        _USBHostRead, 0x0034DA
                                                  2314:      .equ        _USBHostSetNAKTimeout, 0x003F5C
                                                  2315:      .equ        _USBHostShutdown, 0x003E6A
                                                  2316:      .equ        _USBHostTransferIsComplete, 0x003606
                                                  2317:      .equ        _USBHostWrite, 0x00353E
                                                  2318:      .equ        _USB_ApplicationEventHandler, 0x003D98
                                                  2319:      .equ        __Getmem, 0x000508
                                                  2320:      .equ        __T1Interrupt, 0x00408E
                                                  2321:      .equ        __USB1Interrupt, 0x000304
                                                  2322:      .equ        __USBHostMSDSCSI_TestUnitReady, 0x003666
                                                  2323:      .equ        __USBHostMSD_GetNextTag, 0x0042D8
                                                  2324:      .equ        __USBHostMSD_ResetStateJump, 0x002D68
                                                  2325:      .equ        __USB_CheckCommandAndEnumerationAttempts, 0x003E04
                                                  2326:      .equ        __USB_FindClassDriver, 0x002874
                                                  2327:      .equ        __USB_FindDeviceLevelClientDriver, 0x0017AE
                                                  2328:      .equ        __USB_FindEndpoint, 0x003CE8
                                                  2329:      .equ        __USB_FindServiceEndpoint, 0x002444
                                                  2330:      .equ        __USB_FreeConfigMemory, 0x003472
                                                  2331:      .equ        __USB_FreeMemory, 0x003B68
                                                  2332:      .equ        __USB_InitControlRead, 0x003A4E
                                                  2333:      .equ        __USB_InitControlWrite, 0x0038D2
                                                  2334:      .equ        __USB_InitRead, 0x003724
                                                  2335:      .equ        __USB_InitWrite, 0x00377C
                                                  2336:      .equ        __USB_NotifyClients, 0x002F1A
                                                  2337:      .equ        __USB_ResetDATA0, 0x003CAA
                                                  2338:      .equ        __USB_SendToken, 0x003D60
                                                  2339:      .equ        __USB_SetBDT, 0x0016A2
                                                  2340:      .equ        ___udivsi3, 0x000368
                                                  2341:      .equ        _brk, 0x00034C
                                                  2342:      .equ        _free, 0x000388
                                                  2343:      .equ        _main, 0x00418C
                                                  2344:      .equ        _malloc, 0x000452
                                                  2345:      .equ        _memcmp, 0x0004A6
                                                  2346:      .equ        _memcpy, 0x0004C2
                                                  2347:      .equ        _memset, 0x0004D0
                                                  2348:      .equ        _sbrk, 0x000324
                                                  2349:      .equ        _strlen, 0x0004DE
                                                  2350:      .equ        _strncpy, 0x0004EA
                                                  2351:      .equ        _EZBL_ButtonMap, 0x008024
                                                  2352:      .equ        _EZBL_InstallFILEIO2Flash, 0x0093D6
                                                  2353:      .equ        _EZBL_LEDMap, 0x00801E
                                                  2354:      .equ        _EZBL_bootIDHash, 0x008044
                                                  2355:      .equ        _EZBL_bootIDHash0, 0x008044
                                                  2356:      .equ        _EZBL_bootIDHash1, 0x008048
                                                  2357:      .equ        _EZBL_bootIDHash2, 0x00804C
                                                  2358:      .equ        _EZBL_bootIDHash3, 0x008050
                                                  2359:      .equ        _FILEIO_DirectoryGetCurrent, 0x009BC0
                                                  2360:      .equ        _FILEIO_FATRead, 0x009970
                                                  2361:      .equ        _FILEIO_FullClusterNumberGet, 0x009FEE
                                                  2362:      .equ        _FILEIO_LoadBootSector, 0x009DEE
                                                  2363:      .equ        _USBHostMSDTasks, 0x00889C
                                                  2364:      .equ        _USBHostTasks, 0x008054
                                                  2365:      .equ        _USB_HostInterruptHandler, 0x008D12
                                                  2366:      .equ        __USB_FindNextToken, 0x009094
                                                  2367:      .equ        __USB_ParseConfigurationDescriptor, 0x0096F0
                                                  2368:      .equ        _gLongFileNameCharacters, 0x008014
                                                  2369:      .equ        _gShortFileNameCharacters, 0x008003
                                                  2370:      .equ        _gUSBDrive, 0x008036
                                                  2371:      .equ        _EZBL_ADDRESSES_PER_SECTOR, 0x000400
                                                  2372:      .equ        _EZBL_APP_RESET_BASE, 0x00440C
                                                  2373:      .equ        _EZBL_appBootloadState, 0x004400
                                                  2374:      .equ        _EZBL_BACKBUG_ADDRESS, 0x00ABFE
                                                  2375:      .equ        _EZBL_BACKBUG_MASK, 0x000800
                                                  2376:      .equ        _EZBL_BOOTLOADER_SIZE, 0x006400
                                                  2377:      .equ        _EZBL_ButtonMapLen, 0x000001
                                                  2378:      .equ        _EZBL_CODE_PROTECT_ADDRESS, 0x00ABFE
                                                  2379:      .equ        _EZBL_CODE_PROTECT_MASK, 0x002000
                                                  2380:      .equ        _EZBL_CONFIG_BASE, 0x00ABF8
                                                  2381:      .equ        _EZBL_CONFIG_END_ADDRESS, 0x00AC00
                                                  2382:      .equ        _EZBL_CONFIG1, 0x00ABFE
                                                  2383:      .equ        _EZBL_CONFIG2, 0x00ABFC
                                                  2384:      .equ        _EZBL_CONFIG3, 0x00ABFA
                                                  2385:      .equ        _EZBL_CONFIG4, 0x00ABF8
                                                  2386:      .equ        _EZBL_DEVID_ADDRESS, 0xFF0000
                                                  2387:      .equ        _EZBL_DEVID_MASK, 0xFFFFFF
                                                  2388:      .equ        _EZBL_DEVID_VALUE, 0x004207
                                                  2389:      .equ        _EZBL_FORWARD_IRQ_T1, 0x000003
                                                  2390:      .equ        _EZBL_FORWARD_IRQ_USB1, 0x000056
                                                  2391:      .equ        _EZBL_FORWARD_MASK_T1, 0x000001
                                                  2392:      .equ        _EZBL_FORWARD_MASK_USB1, 0x000002
                                                  2393:      .equ        _EZBL_FORWARD_POS_T1, 0x000000
                                                  2394:      .equ        _EZBL_FORWARD_POS_USB1, 0x000001
                                                  2395:      .equ        _EZBL_IGT_BASE, 0x004410
                                                  2396:      .equ        _EZBL_LEDMapLen, 0x000002
                                                  2397:      .equ        _EZBL_MAIN_FLASH_BASE, 0x000000
                                                  2398:      .equ        _EZBL_MAIN_FLASH_END_ADDRESS, 0x00AC00
                                                  2399:      .equ        _EZBL_RESERVED_BIT_ADDRESS, 0x00ABFE
                                                  2400:      .equ        _EZBL_RESERVED_BIT_MASK, 0x008000
                                                  2401:      .equ        _EZBL_REVID_ADDRESS, 0xFF0002
                                                  2402:      .equ        _EZBL_REVID_MASK, 0xFFFFFF
                                                  2403:      .equ        EZBL_Dispatch_T1Interrupt, 0x000230
                                                  2404:      .equ        EZBL_Dispatch_USB1Interrupt, 0x000236
                                                  2405:  
                                                  2406:  #endif
