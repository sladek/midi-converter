;/*******************************************************************************
;  Easy Bootloader Library Source File
;
;  Description:
;    Reads or peeks data from an EZBL_FIFO
;
;*******************************************************************************/
;
;// DOM-IGNORE-BEGIN
;/*******************************************************************************
;  Copyright (C) 2017 Microchip Technology Inc.
;
;  MICROCHIP SOFTWARE NOTICE AND DISCLAIMER:  You may use this software, and any
;  derivatives created by any person or entity by or on your behalf, exclusively
;  with Microchip's products.  Microchip and its licensors retain all ownership
;  and intellectual property rights in the accompanying software and in all
;  derivatives here to.
;
;  This software and any accompanying information is for suggestion only.  It
;  does not modify Microchip's standard warranty for its products.  You agree
;  that you are solely responsible for testing the software and determining its
;  suitability.  Microchip has no obligation to modify, test, certify, or
;  support the software.
;
;  THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES, WHETHER
;  EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED
;  WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A PARTICULAR
;  PURPOSE APPLY TO THIS SOFTWARE, ITS INTERACTION WITH MICROCHIP'S PRODUCTS,
;  COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
;
;  IN NO EVENT, WILL MICROCHIP BE LIABLE, WHETHER IN CONTRACT, WARRANTY, TORT
;  (INCLUDING NEGLIGENCE OR BREACH OF STATUTORY DUTY), STRICT LIABILITY,
;  INDEMNITY, CONTRIBUTION, OR OTHERWISE, FOR ANY INDIRECT, SPECIAL, PUNITIVE,
;  EXEMPLARY, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, FOR COST OR EXPENSE OF
;  ANY KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWSOEVER CAUSED, EVEN IF
;  MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE.
;  TO THE FULLEST EXTENT ALLOWABLE BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL
;  CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF
;  FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
;
;  MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
;  TERMS.
;*******************************************************************************/
;// DOM-IGNORE-END

	.equ	SR_C, 0x0	; SR<C> is bit 0
	.equ	SR_Z, 0x1	; SR<Z> is bit 1
	.equ	SR_OV, 0x2	; SR<OV> is bit 2
	.equ	SR_N, 0x3	; SR<N> is bit 3
    .macro  skip_next_instr
    btsc    w15, #0     ; Skips next instruction since w15 stack pointer can never be odd
    .endm


/**
 * Reads and removes data from a circular EZBL_FIFO, outputting to a normal RAM
 * array. The tailPtr is incremented and dataCount atomically reduced without
 * needing to disable interrupts.
 *
 * After the data has been removed from the FIFO and copied to *dest, an
 * optional call to the source->onReadCallback() function is made. This call is
 * made only when *onReadCallback is not null.
 *
 * The onRead callback function must have type:
 *      unsigned int yourOnReadFuncName(unsigned int bytesPulled, void *readDest, unsigned int reqReadLen, EZBL_FIFO *srcFIFO);
 * The return value of this callback is returned unchanged by EZBL_FIFORead(),
 * giving you an opportunity to manipulate the read contents, return value,
 * and/or trigger other code to refill any FIFO free space generated by the
 * read. The bytesPulled parameter specifies the byte count removed from the
 * FIFO, *readDest is the original value of *dest, and reqReadLen is the
 * original value of dataLen, and *srcFIFO is the pointer to the FIFO that is
 * calling the callback (so one callback handler function could theoretically
 * handle multiple different FIFOs simultaneously).
 *
 * Note: when implementing the onReadCallback(), *readDest can be null if *dest
 * was null when EZBL_FIFORead() was called. In such cases, the read data was
 * thrown away and cannot be reobtained. Technically the data is still in the
 * FIFO backing RAM and could be read for real through direct access, but since
 * the source->dataCount and tailPtr values have already been updated by the
 * time the callback is called, the data is subject to being overwritten by any
 * asynchronous events that may write to the FIFO. This ordering exists to allow
 * APIs that write to the FIFO to be called directly in the onReadCallback().
 *
 * @param *dest Pointer to write the output data to. If null, no read is
 *              performed but the tailPtr, dataCount, and return value will
 *              still be set as if a normal read took place, effectively
 *              throwing the buffer data away.
 *
 *              If source->onReadCallback() is non-null, it will still be called
 *              for null *dest values. However, in this special case, the
 *              reqReadLen callback parameter is adjusted to match the actual
 *              number of bytes thrown away rather than the original dataLen
 *              value this API was called with. This adjustment allows the
 *              callback to ignore read requests for excess data that is just
 *              being thrown away (ex: EZBL_FIFORead(0, &fifo, 0xFFFF) to flush
 *              the existing FIFO contents without blocking to perform an actual
 *              read of 65535 bytes of data).
 *
 * @param *srcFIFO EZBL_FIFO structure to read data from. Read underflow is
 *                 suppressed.
 *
 *                 If this pointer is null, the function returns immediately
 *                 with 0.
 *
 * @param dataLen Number of bytes to read. This value must be <= 16384 on
 *                dsPIC30, PIC24F, PIC24H, or dsPIC33F families.
 *
 *                Zero length is allowed, resulting in no read operation, but
 *                the source->onReadCallback() callback is still called, if
 *                defined.
 *
 * @return Return value from the source->onReadCallback() function or the number
 *         of bytes read and removed from the FIFO when no callback is defined.
 *         Unless changed by the callback routine, this parameter will be less
 *         than <i>length</i> only if the FIFO has run out of data to read.
 */
; unsigned int EZBL_FIFORead(void *dest, EZBL_FIFO *srcFIFO, unsigned int dataLen);
; unsigned int EZBL_FIFOPeek(void *dest, EZBL_FIFO *srcFIFO, unsigned int dataLen);
	.pushsection    .text.EZBL_FIFOPeekRead, code
	.global         _EZBL_FIFOPeek
    .type           _EZBL_FIFOPeek, @function
	.global         _EZBL_FIFORead
    .type           _EZBL_FIFORead, @function
    .equ            dataCount, 0        ; Byte offsets to the EZBL_FIFO structure elements
    .equ            headPtr, 2
    .equ            tailPtr, 4
    .equ            fifoSize, 6
    .equ            fifoRAM, 8
    .equ            onWriteCallback, 10
    .equ            onReadCallback, 12
    .equ            flushFunction, 14
    .equ            irqNum, 16
    .equ            activity, 18
; w1 should point to one of these:
;struct EZBL_FIFO
;{
;    volatile unsigned int dataCount;    // Number of bytes that exist in the FIFO. i.e. headPtr - tailPtr, adjusted for wraparound and made atomically readable. You must use EZBL_ATOMIC_ADD() and EZBL_ATOMIC_SUB() if this value is to be modified.
;    unsigned char *headPtr;             // Pointer to fifoRAM area for writing
;    unsigned char *tailPtr;             // Pointer to fifoRAM area for reading
;    unsigned int fifoSize;              // Number of bytes allocated to the fifoRAM
;    unsigned char *fifoRAM;             // Main FIFO buffer RAM pointer (or const PSV pointer if only doing reading)
;    unsigned int (*onWriteCallback)(unsigned int bytesPushed, void *writeSrc, unsigned int reqWriteLen, EZBL_FIFO *destFIFO);   // Pointer to a function to be called anytime the FIFO is written (or attempted to be written)
;    unsigned int (*onReadCallback)(unsigned int bytesPulled, void *readDest, unsigned int reqReadLen, EZBL_FIFO *srcFIFO);      // Pointer to a function to be called anytime the FIFO is read (or attempted to be read)
;    unsigned int (*flushFunction)(EZBL_FIFO *fifo, unsigned long timeout); // Pointer to a function to be called anytime the EZBL_FIFOFlush() function is called
;    unsigned int irqNum;                // IRQ Number to associate with this FIFO. This number is used to decode the correct IFSx/IECx/IPCx register/bit(s) to access when calling EZBL_FIFOIntEnable()/EZBL_FIFOIntDisable()/EZBL_FIFOIntClear()/EZBL_FIFOIntRaise()/EZBL_FIFOIntEnableSet()/EZBL_FIFOIntFlagSet()/EZBL_FIFOGetIntEn()/EZBL_FIFOGetIntPri() functions. IRQ numbers are zero-based where 0 indicates the first ordinary peripheral hardware interrupt (i.e. not a trap)
;    volatile EZBL_COM_ACTIVITY activity;// Status bit flags capturing various software and hardware state change events like RX interrupt byte, software RX FIFO read, TX interrupt byte, software TX FIFO write, RX bootloader wake key detection, HW/SW FIFO RX overflow and other activity
;};

_EZBL_FIFOPeek: ; unsigned int EZBL_FIFOPeek(void *dest, EZBL_FIFO *srcFIFO, unsigned int dataLen);
    clr     w5              ; Flag that EZBL_FIFOPeek() was called and we should not alter EZBL_FIFO->tailPtr/dataCount
    skip_next_instr         ; Nullify first instruction of EZBL_FIFORead()
_EZBL_FIFORead: ; unsigned int EZBL_FIFORead(void *dest, EZBL_FIFO *srcFIFO, unsigned int dataLen);
    setm    w5
    add     w1, #0, w3      ; w3 = srcFIFO pointer and test if srcFIFO == null
    btsc    SR, #SR_Z       ; if(srcFIFO == null)
    retlw   #0, w0          ;   return 0;

    push    w5              ; TOS = flag for EZBL_FIFOPeek() vs. EZBL_FIFORead()
    inc     w0, [w15++]     ; TOS = Save dest+1 pointer

    ; w0: dest input, then dataLen (bytesPulled, or firstChunkSize + secondChunkSize)
    ; w1: srcFIFO, then dest
    ; w2: dataLen parameter then reqReadLen onReadCallback() paramter
    ; w3: srcFIFO
    ; w4: srcFIFO->tailPtr
    ; w5: Flag indicating if EZBL_FIFOPeek() was called (Peek == 0, Read == 0xFFFF)
    ; w6: fifoEndAddress
    ; w7: fifoSize, bytesUntilWrap, temporaries


    ; Saturate dataLen at srcFIFO->dataCount max and copy to w0
    mov     [w3+dataCount], w0      ; w0 = srcFIFO->dataCount;
    cp      w0, w2                  ; if(dataCount - dataLen < 0)        // Saturate reads > available data to available data count
    btsc    SR, #SR_C               ;       (skip when borrow required, meaning requested length > available length)
    mov     w2, w0                  ;       w0 = requested length = dataLen (provided);

    mov     [w3+tailPtr], w4        ; tailPtr           = srcFIFO->tailPtr;
    mov     [w3+fifoSize], w7       ; fifoSize          = srcFIFO->fifoSize;
    mov     [w3+fifoRAM], w6        ; fifoBaseAddress   = srcFIFO->fifoRAM;
    add     w6, w7, w6              ; fifoEndAddress    = fifoBaseAddress + fifoSize;

    dec     [--w15], w1             ; w1 = dest-1; if(dest == null)
    bra     Z, NoDest               ;                   goto NoDest

    
    ; Determine how many bytes to copy, ensuring we don't hit the end wrap boundary of the source FIFO
    sub     w6, w4, w7              ; firstChunkSize = bytesUntilWrap = fifoEndAddress - tailPtr;
    cp      w7, w0                  ; if(bytesUntilWrap - dataLen)
    btsc    SR, #SR_C               ;       (skip if borrow required)
    sub     w0, #0, w7              ;       firstChunkSize = dataLen;
    bra     Z, 2f                   ; Skip repeat mov loop if there is no data to read

    ; Do first copy
    dec     w7, w5
    repeat  w5                      ; for(w7 = 0; w7 < firstChunkSize; w7++)
    mov.b   [w4++], [w1++]          ;       *dest++ = *tailPtr++;
2:  cp      w4, w6                  ; if(tailPtr >= fifoEndAddress)
    btsc    SR, #SR_C               ;       tailPtr = srcFIFO->fifoRAM; // Skip if we borrow computing (tailPtr - fifoEndAddress)
    mov     [w3+fifoRAM], w4        ;
    
    ; Do second copy, if needed
    sub     w0, w7, w7              ; secondChunkSize = dataLen - firstChunkSize;
    bra     Z, 1f                   ; if(secondChunkSize == 0) skip reading
    dec     w7, w5                  ;       for(w7 = 0; w7 < secondChunkSize; w7++)
    repeat  w5                      ;
    mov.b   [w4++], [w1++]          ;           *dest++ = *tailPtr++;

    ; Write back new tailPtr and dataCount, but only for EZBL_FIFORead(), not EZBL_FIFOPeek()
1:  sub     w1, w0, w1              ; Regenerate w1 *dest for *readDest onReadCallback() parameter
3:  cp0     [--w15]                 ; Test if EZBL_FIFOPeek() was called
    bra     Z, 0f
    subr    w0, [w3], [w3]          ; srcFIFO->dataCount -= readLen; // done atomically
    mov     w4, [w3+tailPtr]        ; srcFIFO->tailPtr = tailPtr;
0:  mov     [w3+onReadCallback], w7 ; Get onReadCallback() function pointer
    cp0     w7
    btss    SR, #SR_Z
    call    w7                      ; srcFIFO->onReadCallback(unsigned int bytesPulled, void *readDest, unsigned int reqReadLen, EZBL_FIFO *srcFIFO);
    return                          ; return firstChunkSize + secondChunkSize; (or whatever the callback returned)
    
    
NoDest: ; If dest is null, then just compute the proper tailPtr for this read, adjusted to min(data_available, data_requested)
    add     w4, w0, w4              ; tailPtr += dataLen
    cp      w4, w6                  ; if(tailPtr - fifoEndAddress)              // Wrap tailPtr if we crossed the end address
    btsc    SR, #SR_C               ;       (skip when borrow required)
    sub     w4, w7, w4              ;       tailPtr -= srcFIFO->fifoSize;
    mov     w0, w2                  ; When dest is null, a really big value like -1 may be given as the requested read len (in order to discard the FIFO contents, so to prevent the callback from seeing a requested read length and actual read length mismatch, make the requested length match the size we actually have available.)
    bra     3b

    .size   _EZBL_FIFORead, . - _EZBL_FIFORead
    .size   _EZBL_FIFOPeek, . - _EZBL_FIFOPeek
    .popsection
